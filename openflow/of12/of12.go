// Automatically generated by Packet Go code generator.
package of12

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"

	"github.com/packet/packet/src/go/packet"

	"github.com/kandoo/beehive-netctrl/openflow/of"
)

type Ports int

const (
	PP_MAX        Ports = 4294967040
	PP_IN_PORT    Ports = 4294967288
	PP_TABLE      Ports = 4294967289
	PP_NORMAL     Ports = 4294967290
	PP_FLOOD      Ports = 4294967291
	PP_ALL        Ports = 4294967292
	PP_CONTROLLER Ports = 4294967293
	PP_LOCAL      Ports = 4294967294
	PP_ANY        Ports = 4294967295
)

type Groups int

const (
	PG_MAX Groups = 4294967040
	PG_ALL Groups = 4294967292
	PG_ANY Groups = 4294967295
)

type Type int

const (
	PT_PACKET_IN                Type = 10
	PT_FLOW_REMOVED             Type = 11
	PT_PORT_STATUS              Type = 12
	PT_PACKET_OUT               Type = 13
	PT_FLOW_MOD                 Type = 14
	PT_GROUP_MOD                Type = 15
	PT_PORT_MOD                 Type = 16
	PT_TABLE_MOD                Type = 17
	PT_STATS_REQUEST            Type = 18
	PT_STATS_REPLY              Type = 19
	PT_BARRIER_REQUEST          Type = 20
	PT_BARRIER_REPLY            Type = 21
	PT_QUEUE_GET_CONFIG_REQUEST Type = 22
	PT_QUEUE_GET_CONFIG_REPLY   Type = 23
	PT_ROLE_REQUEST             Type = 24
	PT_ROLE_REPLY               Type = 25
)

type ConfigFlags int

const (
	PC_FRAG_NORMAL               ConfigFlags = 0
	PC_FRAG_DROP                 ConfigFlags = 1
	PC_FRAG_REASM                ConfigFlags = 2
	PC_FRAG_MASK                 ConfigFlags = 3
	PC_INVALID_TTL_TO_CONTROLLER ConfigFlags = 4
)

type Capabilities int

const (
	PC_FLOW_STATS   Capabilities = 1
	PC_TABLE_STATS  Capabilities = 2
	PC_PORT_STATS   Capabilities = 4
	PC_STP          Capabilities = 8
	PC_RESERVED     Capabilities = 16
	PC_IP_REASM     Capabilities = 32
	PC_QUEUE_STATS  Capabilities = 64
	PC_ARP_MATCH_IP Capabilities = 128
)

type PortConfig int

const (
	PPC_PORT_DOWN    PortConfig = 1
	PPC_NO_RECV      PortConfig = 4
	PPC_NO_FWD       PortConfig = 32
	PPC_NO_PACKET_IN PortConfig = 64
)

type PortState int

const (
	PPS_LINK_DOWN PortState = 1
	PPS_BLOCKED   PortState = 2
	PPS_LIVE      PortState = 4
)

type PortFeatures int

const (
	PPF_10MB_HD    PortFeatures = 1
	PPF_10MB_FD    PortFeatures = 2
	PPF_100MB_HD   PortFeatures = 4
	PPF_100MB_FD   PortFeatures = 8
	PPF_1GB_HD     PortFeatures = 16
	PPF_1GB_FD     PortFeatures = 32
	PPF_10GB_FD    PortFeatures = 64
	PPF_40GB_FD    PortFeatures = 128
	PPF_100GB_FD   PortFeatures = 256
	PPF_1TB_FD     PortFeatures = 512
	PPF_OTHER      PortFeatures = 1024
	PPF_COPPER     PortFeatures = 2048
	PPF_FIBER      PortFeatures = 4096
	PPF_AUTONEG    PortFeatures = 8192
	PPF_PAUSE      PortFeatures = 16384
	PPF_PAUSE_ASYM PortFeatures = 32768
)

type PortReason int

const (
	PPR_ADD    PortReason = 0
	PPR_DELETE PortReason = 1
	PPR_MODIFY PortReason = 2
)

type ActionType int

const (
	PAT_OUTPUT       ActionType = 0
	PAT_COPY_TTL_OUT ActionType = 11
	PAT_COPY_TTL_IN  ActionType = 12
	PAT_SET_MPLS_TTL ActionType = 15
	PAT_DEC_MPLS_TTL ActionType = 16
	PAT_PUSH_VLAN    ActionType = 17
	PAT_POP_VLAN     ActionType = 18
	PAT_PUSH_MPLS    ActionType = 19
	PAT_POP_MPLS     ActionType = 20
	PAT_SET_QUEUE    ActionType = 21
	PAT_GROUP        ActionType = 22
	PAT_SET_NW_TTL   ActionType = 23
	PAT_DEC_NW_TTL   ActionType = 24
	PAT_SET_FIELD    ActionType = 25
	PAT_EXPERIMENTER ActionType = 65535
)

type InstructionType int

const (
	PIT_GOTO_TABLE     InstructionType = 1
	PIT_WRITE_METADATA InstructionType = 2
	PIT_WRITE_ACTIONS  InstructionType = 3
	PIT_APPLY_ACTIONS  InstructionType = 4
	PIT_CLEAR_ACTIONS  InstructionType = 5
	PIT_EXPERIMENTER   InstructionType = 65535
)

type Buffers int

const (
	P_NO_BUFFER Buffers = 4294967295
)

type FlowModCommand int

const (
	PFC_ADD           FlowModCommand = 0
	PFC_MODIFY        FlowModCommand = 1
	PFC_MODIFY_STRICT FlowModCommand = 2
	PFC_DELETE        FlowModCommand = 3
	PFC_DELETE_STRICT FlowModCommand = 4
)

type FlowWildcards int

const (
	PFW_IN_PORT      FlowWildcards = 1
	PFW_DL_VLAN      FlowWildcards = 2
	PFW_DL_SRC       FlowWildcards = 4
	PFW_DL_DST       FlowWildcards = 8
	PFW_DL_TYPE      FlowWildcards = 16
	PFW_NW_PROTO     FlowWildcards = 32
	PFW_TP_SRC       FlowWildcards = 64
	PFW_TP_DST       FlowWildcards = 128
	PFW_NW_SRC_SHIFT FlowWildcards = 8
	PFW_NW_SRC_BITS  FlowWildcards = 5
	PFW_NW_SRC_MASK  FlowWildcards = 7936
	PFW_NW_SRC_ALL   FlowWildcards = 8192
	PFW_NW_DST_SHIFT FlowWildcards = 14
	PFW_NW_DST_BITS  FlowWildcards = 6
	PFW_NW_DST_MASK  FlowWildcards = 1032192
	PFW_NW_DST_ALL   FlowWildcards = 524288
	PFW_DL_VLAN_PCP  FlowWildcards = 1048576
	PFW_NW_TOS       FlowWildcards = 2097152
	PFW_ALL          FlowWildcards = 4194303
)

type OxmClass int

const (
	PXMC_NXM_0          OxmClass = 0
	PXMC_NXM_1          OxmClass = 1
	PXMC_OPENFLOW_BASIC OxmClass = 32768
	PXMC_EXPERIMENTER   OxmClass = 65535
)

type OXMatchFields int

const (
	PXMT_IN_PORT         OXMatchFields = 0
	PXMT_IN_PHY_PORT     OXMatchFields = 2
	PXMT_METADATA        OXMatchFields = 4
	PXMT_ETH_DST         OXMatchFields = 6
	PXMT_ETH_DST_MASKED  OXMatchFields = 7
	PXMT_ETH_SRC         OXMatchFields = 8
	PXMT_ETH_SRC_MASKED  OXMatchFields = 9
	PXMT_ETH_TYPE        OXMatchFields = 10
	PXMT_VLAN_VID        OXMatchFields = 12
	PXMT_VLAN_PCP        OXMatchFields = 14
	PXMT_IP_DSCP         OXMatchFields = 16
	PXMT_IP_ECN          OXMatchFields = 18
	PXMT_IP_PROTO        OXMatchFields = 20
	PXMT_IPV4_SRC        OXMatchFields = 22
	PXMT_IPV4_SRC_MASKED OXMatchFields = 23
	PXMT_IPV4_DST        OXMatchFields = 24
	PXMT_IPV4_DST_MASKED OXMatchFields = 25
	PXMT_TCP_SRC         OXMatchFields = 26
	PXMT_TCP_DST         OXMatchFields = 28
	PXMT_UDP_SRC         OXMatchFields = 30
	PXMT_UDP_DST         OXMatchFields = 32
	PXMT_SCTP_SRC        OXMatchFields = 34
	PXMT_SCTP_DST        OXMatchFields = 36
	PXMT_ICMPV4_TYPE     OXMatchFields = 38
	PXMT_ICMPV4_CODE     OXMatchFields = 40
	PXMT_ARP_OP          OXMatchFields = 42
	PXMT_ARP_SPA         OXMatchFields = 44
	PXMT_ARP_TPA         OXMatchFields = 46
	PXMT_ARP_SHA         OXMatchFields = 48
	PXMT_ARP_THA         OXMatchFields = 50
	PXMT_IPV6_SRC        OXMatchFields = 52
	PXMT_IPV6_SRC_MASKED OXMatchFields = 53
	PXMT_IPV6_DST        OXMatchFields = 54
	PXMT_IPV6_DST_MASKED OXMatchFields = 55
	PXMT_IPV6_FLABEL     OXMatchFields = 56
	PXMT_ICMPV6_TYPE     OXMatchFields = 58
	PXMT_ICMPV6_CODE     OXMatchFields = 60
	PXMT_IPV6_ND_TARGET  OXMatchFields = 62
	PXMT_IPV6_ND_SLL     OXMatchFields = 64
	PXMT_IPV6_ND_TLL     OXMatchFields = 66
	PXMT_MPLS_LABEL      OXMatchFields = 68
	PXMT_MPLS_TC         OXMatchFields = 70
)

type MatchType int

const (
	PMT_STANDARD MatchType = 0
	PMT_OXM      MatchType = 1
)

type PacketInReason int

const (
	PR_NO_MATCH PacketInReason = 0
	PR_ACTION   PacketInReason = 1
)

type FlowModFlags int

const (
	PFF_SEND_FLOW_REM FlowModFlags = 1
	PFF_CHECK_OVERLAP FlowModFlags = 2
	PFF_EMERG         FlowModFlags = 4
)

type FlowRemovedReason int

const (
	PRR_IDLE_TIMEOUT FlowRemovedReason = 0
	PRR_HARD_TIMEOUT FlowRemovedReason = 1
	PRR_DELETE       FlowRemovedReason = 2
)

type ErrorType int

const (
	PET_HELLO_FAILED    ErrorType = 0
	PET_BAD_REQUEST     ErrorType = 1
	PET_BAD_ACTION      ErrorType = 2
	PET_FLOW_MOD_FAILED ErrorType = 3
	PET_PORT_MOD_FAILED ErrorType = 4
	PET_QUEUE_OP_FAILED ErrorType = 5
)

type HelloFailedCode int

const (
	PHFC_INCOMPATIBLE HelloFailedCode = 0
	PHFC_EPERM        HelloFailedCode = 1
)

type BadRequestCode int

const (
	PBRC_BAD_VERSION    BadRequestCode = 0
	PBRC_BAD_TYPE       BadRequestCode = 1
	PBRC_BAD_STAT       BadRequestCode = 2
	PBRC_BAD_VENDOR     BadRequestCode = 3
	PBRC_BAD_SUBTYPE    BadRequestCode = 4
	PBRC_EPERM          BadRequestCode = 5
	PBRC_BAD_LEN        BadRequestCode = 6
	PBRC_BUFFER_EMPTY   BadRequestCode = 7
	PBRC_BUFFER_UNKNOWN BadRequestCode = 8
)

type BadActionCode int

const (
	PBAC_BAD_TYPE        BadActionCode = 0
	PBAC_BAD_LEN         BadActionCode = 1
	PBAC_BAD_VENDOR      BadActionCode = 2
	PBAC_BAD_VENDOR_TYPE BadActionCode = 3
	PBAC_BAD_OUT_PORT    BadActionCode = 4
	PBAC_BAD_ARGUMENT    BadActionCode = 5
	PBAC_EPERM           BadActionCode = 6
	PBAC_TOO_MANY        BadActionCode = 7
	PBAC_BAD_QUEUE       BadActionCode = 8
)

type Flow_modFailedCode int

const (
	PFMFC_ALL_TABLES_FULL   Flow_modFailedCode = 0
	PFMFC_OVERLAP           Flow_modFailedCode = 1
	PFMFC_EPERM             Flow_modFailedCode = 2
	PFMFC_BAD_EMERG_TIMEOUT Flow_modFailedCode = 3
	PFMFC_BAD_COMMAND       Flow_modFailedCode = 4
	PFMFC_UNSUPPORTED       Flow_modFailedCode = 5
)

type Port_modFailedCode int

const (
	PPMFC_BAD_PORT    Port_modFailedCode = 0
	PPMFC_BAD_HW_ADDR Port_modFailedCode = 1
)

type QueueOpFailedCode int

const (
	PQC_BAD_PORT  QueueOpFailedCode = 0
	PQC_BAD_QUEUE QueueOpFailedCode = 1
	PQC_EPERM     QueueOpFailedCode = 2
)

type StatsTypes int

const (
	PST_DESC         StatsTypes = 0
	PST_FLOW         StatsTypes = 1
	PST_AGGREGATE    StatsTypes = 2
	PST_TABLE        StatsTypes = 3
	PST_PORT         StatsTypes = 4
	PST_QUEUE        StatsTypes = 5
	OFPST_GROUP      StatsTypes = 6
	OFPST_GROUP_DESC StatsTypes = 7
	PST_EXPERIMENTER StatsTypes = 65535
)

type StatsReplyFlags int

const (
	PSF_REPLY_MORE StatsReplyFlags = 1
)

type DescStatsConstants int

const (
	SERIAL_NUM_LEN DescStatsConstants = 32
	DESC_STR_LEN   DescStatsConstants = 256
)

type QueueProperties int

const (
	PQT_NONE     QueueProperties = 0
	PQT_MIN_RATE QueueProperties = 1
)

type ControllerRole int

const (
	ROLE_NOCHANGE ControllerRole = 0
	ROLE_EQUAL    ControllerRole = 1
	ROLE_MASTER   ControllerRole = 2
	ROLE_SLAVE    ControllerRole = 3
)

func NewHeader12WithBuf(b []byte) Header12 {
	return Header12{of.Header{packet.Packet{Buf: b}}}
}

func NewHeader12() Header12 {
	s := 8
	b := make([]byte, s)
	p := Header12{of.Header{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type Header12 struct {
	of.Header
}

func (this Header12) minSize() int {
	return 8
}

func (this Header12) Clone() (Header12, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewHeader12(), err
	}

	return NewHeader12WithBuf(newBuf.Bytes()), nil
}

type Header12Conn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewHeader12Conn(c net.Conn) Header12Conn {
	return Header12Conn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *Header12Conn) WriteHeader12(pkt Header12) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *Header12Conn) WriteHeader12s(pkts []Header12) error {
	for _, p := range pkts {
		if err := c.WriteHeader12(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *Header12Conn) Flush() error {
	return c.w.Flush()
}

func (c *Header12Conn) ReadHeader12() (Header12, error) {
	pkts := make([]Header12, 1)
	_, err := c.ReadHeader12s(pkts)
	if err != nil {
		return NewHeader12(), err
	}

	return pkts[0], nil
}

func (c *Header12Conn) ReadHeader12s(pkts []Header12) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewHeader12WithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Header12) Init() {
	this.Header.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetVersion(uint8(3)) // version
}

func (this Header12) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToHeader12(p of.Header) (Header12, error) {
	if !IsHeader12(p) {
		return NewHeader12WithBuf(nil), errors.New("Cannot convert to of12.Header12")
	}

	return NewHeader12WithBuf(p.Buf), nil
}

func IsHeader12(p of.Header) bool {
	return p.Version() == 3 && true
}

func NewHelloWithBuf(b []byte) Hello {
	return Hello{of.Hello{of.Header{packet.Packet{Buf: b}}}}
}

func NewHello() Hello {
	s := 8
	b := make([]byte, s)
	p := Hello{of.Hello{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type Hello struct {
	of.Hello
}

func (this Hello) minSize() int {
	return 8
}

func (this Hello) Clone() (Hello, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewHello(), err
	}

	return NewHelloWithBuf(newBuf.Bytes()), nil
}

type HelloConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewHelloConn(c net.Conn) HelloConn {
	return HelloConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *HelloConn) WriteHello(pkt Hello) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *HelloConn) WriteHellos(pkts []Hello) error {
	for _, p := range pkts {
		if err := c.WriteHello(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *HelloConn) Flush() error {
	return c.w.Flush()
}

func (c *HelloConn) ReadHello() (Hello, error) {
	pkts := make([]Hello, 1)
	_, err := c.ReadHellos(pkts)
	if err != nil {
		return NewHello(), err
	}

	return pkts[0], nil
}

func (c *HelloConn) ReadHellos(pkts []Hello) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewHelloWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Hello) Init() {
	this.Hello.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetVersion(uint8(3)) // version
	this.SetType(uint8(0))    // type
}

func (this Hello) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToHello(p of.Hello) (Hello, error) {
	if !IsHello(p) {
		return NewHelloWithBuf(nil), errors.New("Cannot convert to of12.Hello")
	}

	return NewHelloWithBuf(p.Buf), nil
}

func IsHello(p of.Hello) bool {
	return p.Version() == 3 && true
}

func NewEchoRequestWithBuf(b []byte) EchoRequest {
	return EchoRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewEchoRequest() EchoRequest {
	s := 8
	b := make([]byte, s)
	p := EchoRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type EchoRequest struct {
	Header12
}

func (this EchoRequest) minSize() int {
	return 8
}

func (this EchoRequest) Clone() (EchoRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEchoRequest(), err
	}

	return NewEchoRequestWithBuf(newBuf.Bytes()), nil
}

type EchoRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewEchoRequestConn(c net.Conn) EchoRequestConn {
	return EchoRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EchoRequestConn) WriteEchoRequest(pkt EchoRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *EchoRequestConn) WriteEchoRequests(pkts []EchoRequest) error {
	for _, p := range pkts {
		if err := c.WriteEchoRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *EchoRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *EchoRequestConn) ReadEchoRequest() (EchoRequest, error) {
	pkts := make([]EchoRequest, 1)
	_, err := c.ReadEchoRequests(pkts)
	if err != nil {
		return NewEchoRequest(), err
	}

	return pkts[0], nil
}

func (c *EchoRequestConn) ReadEchoRequests(pkts []EchoRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEchoRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *EchoRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(2))    // type
	this.SetVersion(uint8(3)) // version
}

func (this EchoRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToEchoRequest(p Header12) (EchoRequest, error) {
	if !IsEchoRequest(p) {
		return NewEchoRequestWithBuf(nil), errors.New("Cannot convert to of12.EchoRequest")
	}

	return NewEchoRequestWithBuf(p.Buf), nil
}

func IsEchoRequest(p Header12) bool {
	return p.Type() == 2 && true
}

func NewEchoReplyWithBuf(b []byte) EchoReply {
	return EchoReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewEchoReply() EchoReply {
	s := 8
	b := make([]byte, s)
	p := EchoReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type EchoReply struct {
	Header12
}

func (this EchoReply) minSize() int {
	return 8
}

func (this EchoReply) Clone() (EchoReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEchoReply(), err
	}

	return NewEchoReplyWithBuf(newBuf.Bytes()), nil
}

type EchoReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewEchoReplyConn(c net.Conn) EchoReplyConn {
	return EchoReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EchoReplyConn) WriteEchoReply(pkt EchoReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *EchoReplyConn) WriteEchoReplys(pkts []EchoReply) error {
	for _, p := range pkts {
		if err := c.WriteEchoReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *EchoReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *EchoReplyConn) ReadEchoReply() (EchoReply, error) {
	pkts := make([]EchoReply, 1)
	_, err := c.ReadEchoReplys(pkts)
	if err != nil {
		return NewEchoReply(), err
	}

	return pkts[0], nil
}

func (c *EchoReplyConn) ReadEchoReplys(pkts []EchoReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEchoReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *EchoReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(3))    // type
	this.SetVersion(uint8(3)) // version
}

func (this EchoReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToEchoReply(p Header12) (EchoReply, error) {
	if !IsEchoReply(p) {
		return NewEchoReplyWithBuf(nil), errors.New("Cannot convert to of12.EchoReply")
	}

	return NewEchoReplyWithBuf(p.Buf), nil
}

func IsEchoReply(p Header12) bool {
	return p.Type() == 3 && true
}

func NewFeaturesRequestWithBuf(b []byte) FeaturesRequest {
	return FeaturesRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFeaturesRequest() FeaturesRequest {
	s := 8
	b := make([]byte, s)
	p := FeaturesRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FeaturesRequest struct {
	Header12
}

func (this FeaturesRequest) minSize() int {
	return 8
}

func (this FeaturesRequest) Clone() (FeaturesRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFeaturesRequest(), err
	}

	return NewFeaturesRequestWithBuf(newBuf.Bytes()), nil
}

type FeaturesRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFeaturesRequestConn(c net.Conn) FeaturesRequestConn {
	return FeaturesRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FeaturesRequestConn) WriteFeaturesRequest(pkt FeaturesRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FeaturesRequestConn) WriteFeaturesRequests(pkts []FeaturesRequest) error {
	for _, p := range pkts {
		if err := c.WriteFeaturesRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FeaturesRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *FeaturesRequestConn) ReadFeaturesRequest() (FeaturesRequest, error) {
	pkts := make([]FeaturesRequest, 1)
	_, err := c.ReadFeaturesRequests(pkts)
	if err != nil {
		return NewFeaturesRequest(), err
	}

	return pkts[0], nil
}

func (c *FeaturesRequestConn) ReadFeaturesRequests(pkts []FeaturesRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFeaturesRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FeaturesRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(5))    // type
	this.SetVersion(uint8(3)) // version
}

func (this FeaturesRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFeaturesRequest(p Header12) (FeaturesRequest, error) {
	if !IsFeaturesRequest(p) {
		return NewFeaturesRequestWithBuf(nil), errors.New("Cannot convert to of12.FeaturesRequest")
	}

	return NewFeaturesRequestWithBuf(p.Buf), nil
}

func IsFeaturesRequest(p Header12) bool {
	return p.Type() == 5 && true
}

func NewGetConfigRequestWithBuf(b []byte) GetConfigRequest {
	return GetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewGetConfigRequest() GetConfigRequest {
	s := 8
	b := make([]byte, s)
	p := GetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type GetConfigRequest struct {
	Header12
}

func (this GetConfigRequest) minSize() int {
	return 8
}

func (this GetConfigRequest) Clone() (GetConfigRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewGetConfigRequest(), err
	}

	return NewGetConfigRequestWithBuf(newBuf.Bytes()), nil
}

type GetConfigRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewGetConfigRequestConn(c net.Conn) GetConfigRequestConn {
	return GetConfigRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *GetConfigRequestConn) WriteGetConfigRequest(pkt GetConfigRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *GetConfigRequestConn) WriteGetConfigRequests(pkts []GetConfigRequest) error {
	for _, p := range pkts {
		if err := c.WriteGetConfigRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *GetConfigRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *GetConfigRequestConn) ReadGetConfigRequest() (GetConfigRequest, error) {
	pkts := make([]GetConfigRequest, 1)
	_, err := c.ReadGetConfigRequests(pkts)
	if err != nil {
		return NewGetConfigRequest(), err
	}

	return pkts[0], nil
}

func (c *GetConfigRequestConn) ReadGetConfigRequests(pkts []GetConfigRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewGetConfigRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *GetConfigRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(7))    // type
	this.SetVersion(uint8(3)) // version
}

func (this GetConfigRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToGetConfigRequest(p Header12) (GetConfigRequest, error) {
	if !IsGetConfigRequest(p) {
		return NewGetConfigRequestWithBuf(nil), errors.New("Cannot convert to of12.GetConfigRequest")
	}

	return NewGetConfigRequestWithBuf(p.Buf), nil
}

func IsGetConfigRequest(p Header12) bool {
	return p.Type() == 7 && true
}

func NewSwitchGetConfigReplyWithBuf(b []byte) SwitchGetConfigReply {
	return SwitchGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewSwitchGetConfigReply() SwitchGetConfigReply {
	s := 12
	b := make([]byte, s)
	p := SwitchGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type SwitchGetConfigReply struct {
	Header12
}

func (this SwitchGetConfigReply) minSize() int {
	return 12
}

func (this SwitchGetConfigReply) Clone() (SwitchGetConfigReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewSwitchGetConfigReply(), err
	}

	return NewSwitchGetConfigReplyWithBuf(newBuf.Bytes()), nil
}

type SwitchGetConfigReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewSwitchGetConfigReplyConn(c net.Conn) SwitchGetConfigReplyConn {
	return SwitchGetConfigReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *SwitchGetConfigReplyConn) WriteSwitchGetConfigReply(pkt SwitchGetConfigReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *SwitchGetConfigReplyConn) WriteSwitchGetConfigReplys(pkts []SwitchGetConfigReply) error {
	for _, p := range pkts {
		if err := c.WriteSwitchGetConfigReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *SwitchGetConfigReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *SwitchGetConfigReplyConn) ReadSwitchGetConfigReply() (SwitchGetConfigReply, error) {
	pkts := make([]SwitchGetConfigReply, 1)
	_, err := c.ReadSwitchGetConfigReplys(pkts)
	if err != nil {
		return NewSwitchGetConfigReply(), err
	}

	return pkts[0], nil
}

func (c *SwitchGetConfigReplyConn) ReadSwitchGetConfigReplys(pkts []SwitchGetConfigReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewSwitchGetConfigReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *SwitchGetConfigReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(8))    // type
	this.SetVersion(uint8(3)) // version
}

func (this SwitchGetConfigReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToSwitchGetConfigReply(p Header12) (SwitchGetConfigReply, error) {
	if !IsSwitchGetConfigReply(p) {
		return NewSwitchGetConfigReplyWithBuf(nil), errors.New("Cannot convert to of12.SwitchGetConfigReply")
	}

	return NewSwitchGetConfigReplyWithBuf(p.Buf), nil
}

func IsSwitchGetConfigReply(p Header12) bool {
	return p.Type() == 8 && true
}

func (this SwitchGetConfigReply) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchGetConfigReply) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this SwitchGetConfigReply) FlagsOffset() int {
	offset := 8
	return offset
}

func (this SwitchGetConfigReply) MissSendLen() uint16 {
	offset := this.MissSendLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchGetConfigReply) SetMissSendLen(m uint16) {
	offset := this.MissSendLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this SwitchGetConfigReply) MissSendLenOffset() int {
	offset := 10
	return offset
}

func NewSwitchSetConfigWithBuf(b []byte) SwitchSetConfig {
	return SwitchSetConfig{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewSwitchSetConfig() SwitchSetConfig {
	s := 12
	b := make([]byte, s)
	p := SwitchSetConfig{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type SwitchSetConfig struct {
	Header12
}

func (this SwitchSetConfig) minSize() int {
	return 12
}

func (this SwitchSetConfig) Clone() (SwitchSetConfig, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewSwitchSetConfig(), err
	}

	return NewSwitchSetConfigWithBuf(newBuf.Bytes()), nil
}

type SwitchSetConfigConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewSwitchSetConfigConn(c net.Conn) SwitchSetConfigConn {
	return SwitchSetConfigConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *SwitchSetConfigConn) WriteSwitchSetConfig(pkt SwitchSetConfig) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *SwitchSetConfigConn) WriteSwitchSetConfigs(pkts []SwitchSetConfig) error {
	for _, p := range pkts {
		if err := c.WriteSwitchSetConfig(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *SwitchSetConfigConn) Flush() error {
	return c.w.Flush()
}

func (c *SwitchSetConfigConn) ReadSwitchSetConfig() (SwitchSetConfig, error) {
	pkts := make([]SwitchSetConfig, 1)
	_, err := c.ReadSwitchSetConfigs(pkts)
	if err != nil {
		return NewSwitchSetConfig(), err
	}

	return pkts[0], nil
}

func (c *SwitchSetConfigConn) ReadSwitchSetConfigs(pkts []SwitchSetConfig) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewSwitchSetConfigWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *SwitchSetConfig) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(9))    // type
	this.SetVersion(uint8(3)) // version
}

func (this SwitchSetConfig) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToSwitchSetConfig(p Header12) (SwitchSetConfig, error) {
	if !IsSwitchSetConfig(p) {
		return NewSwitchSetConfigWithBuf(nil), errors.New("Cannot convert to of12.SwitchSetConfig")
	}

	return NewSwitchSetConfigWithBuf(p.Buf), nil
}

func IsSwitchSetConfig(p Header12) bool {
	return p.Type() == 9 && true
}

func (this SwitchSetConfig) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchSetConfig) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this SwitchSetConfig) FlagsOffset() int {
	offset := 8
	return offset
}

func (this SwitchSetConfig) MissSendLen() uint16 {
	offset := this.MissSendLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchSetConfig) SetMissSendLen(m uint16) {
	offset := this.MissSendLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this SwitchSetConfig) MissSendLenOffset() int {
	offset := 10
	return offset
}

func NewPortWithBuf(b []byte) Port {
	return Port{packet.Packet{Buf: b}}
}

func NewPort() Port {
	s := 64
	b := make([]byte, s)
	p := Port{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Port struct {
	packet.Packet
}

func (this Port) minSize() int {
	return 64
}

func (this Port) Clone() (Port, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPort(), err
	}

	return NewPortWithBuf(newBuf.Bytes()), nil
}

type PortConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPortConn(c net.Conn) PortConn {
	return PortConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortConn) WritePort(pkt Port) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortConn) WritePorts(pkts []Port) error {
	for _, p := range pkts {
		if err := c.WritePort(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortConn) Flush() error {
	return c.w.Flush()
}

func (c *PortConn) ReadPort() (Port, error) {
	pkts := make([]Port, 1)
	_, err := c.ReadPorts(pkts)
	if err != nil {
		return NewPort(), err
	}

	return pkts[0], nil
}

func (c *PortConn) ReadPorts(pkts []Port) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Port) Init() {
	// Invariants.
}

func (this Port) Size() int {
	return 64
}

func ToPort(p packet.Packet) (Port, error) {
	if !IsPort(p) {
		return NewPortWithBuf(nil), errors.New("Cannot convert to of12.Port")
	}

	return NewPortWithBuf(p.Buf), nil
}

func IsPort(p packet.Packet) bool {
	return true
}

func (this Port) PortNo() uint32 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetPortNo(p uint32) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this Port) PortNoOffset() int {
	offset := 0
	return offset
}

func (this Port) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this Port) PadOffset() int {
	offset := 4
	return offset
}

func (this Port) HwAddr() [6]uint8 {
	offset := this.HwAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetHwAddr(h [6]uint8) {
	offset := this.HwAddrOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this Port) HwAddrOffset() int {
	offset := 8
	return offset
}

func (this Port) Pad2() [2]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetPad2(p [2]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this Port) Pad2Offset() int {
	offset := 14
	return offset
}

func (this Port) Name() [16]byte {
	offset := this.NameOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetName(n [16]byte) {
	offset := this.NameOffset()
	for _, e := range n {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this Port) NameOffset() int {
	offset := 16
	return offset
}

func (this Port) Config() uint32 {
	offset := this.ConfigOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetConfig(c uint32) {
	offset := this.ConfigOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this Port) ConfigOffset() int {
	offset := 32
	return offset
}

func (this Port) State() uint32 {
	offset := this.StateOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetState(s uint32) {
	offset := this.StateOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], s)
	offset += 4
}

func (this Port) StateOffset() int {
	offset := 36
	return offset
}

func (this Port) Curr() uint32 {
	offset := this.CurrOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetCurr(c uint32) {
	offset := this.CurrOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this Port) CurrOffset() int {
	offset := 40
	return offset
}

func (this Port) Advertised() uint32 {
	offset := this.AdvertisedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetAdvertised(a uint32) {
	offset := this.AdvertisedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this Port) AdvertisedOffset() int {
	offset := 44
	return offset
}

func (this Port) Supported() uint32 {
	offset := this.SupportedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetSupported(s uint32) {
	offset := this.SupportedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], s)
	offset += 4
}

func (this Port) SupportedOffset() int {
	offset := 48
	return offset
}

func (this Port) Peer() uint32 {
	offset := this.PeerOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetPeer(p uint32) {
	offset := this.PeerOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this Port) PeerOffset() int {
	offset := 52
	return offset
}

func (this Port) CurrSpeed() uint32 {
	offset := this.CurrSpeedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetCurrSpeed(c uint32) {
	offset := this.CurrSpeedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this Port) CurrSpeedOffset() int {
	offset := 56
	return offset
}

func (this Port) MaxSpeed() uint32 {
	offset := this.MaxSpeedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetMaxSpeed(m uint32) {
	offset := this.MaxSpeedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this Port) MaxSpeedOffset() int {
	offset := 60
	return offset
}

func NewFeaturesReplyWithBuf(b []byte) FeaturesReply {
	return FeaturesReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFeaturesReply() FeaturesReply {
	s := 32
	b := make([]byte, s)
	p := FeaturesReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FeaturesReply struct {
	Header12
}

func (this FeaturesReply) minSize() int {
	return 32
}

func (this FeaturesReply) Clone() (FeaturesReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFeaturesReply(), err
	}

	return NewFeaturesReplyWithBuf(newBuf.Bytes()), nil
}

type FeaturesReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFeaturesReplyConn(c net.Conn) FeaturesReplyConn {
	return FeaturesReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FeaturesReplyConn) WriteFeaturesReply(pkt FeaturesReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FeaturesReplyConn) WriteFeaturesReplys(pkts []FeaturesReply) error {
	for _, p := range pkts {
		if err := c.WriteFeaturesReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FeaturesReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *FeaturesReplyConn) ReadFeaturesReply() (FeaturesReply, error) {
	pkts := make([]FeaturesReply, 1)
	_, err := c.ReadFeaturesReplys(pkts)
	if err != nil {
		return NewFeaturesReply(), err
	}

	return pkts[0], nil
}

func (c *FeaturesReplyConn) ReadFeaturesReplys(pkts []FeaturesReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFeaturesReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FeaturesReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(6))    // type
	this.SetVersion(uint8(3)) // version
}

func (this FeaturesReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFeaturesReply(p Header12) (FeaturesReply, error) {
	if !IsFeaturesReply(p) {
		return NewFeaturesReplyWithBuf(nil), errors.New("Cannot convert to of12.FeaturesReply")
	}

	return NewFeaturesReplyWithBuf(p.Buf), nil
}

func IsFeaturesReply(p Header12) bool {
	return p.Type() == 6 && true
}

func (this FeaturesReply) DatapathId() uint64 {
	offset := this.DatapathIdOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetDatapathId(d uint64) {
	offset := this.DatapathIdOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], d)
	offset += 8
}

func (this FeaturesReply) DatapathIdOffset() int {
	offset := 8
	return offset
}

func (this FeaturesReply) NBuffers() uint32 {
	offset := this.NBuffersOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetNBuffers(n uint32) {
	offset := this.NBuffersOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this FeaturesReply) NBuffersOffset() int {
	offset := 16
	return offset
}

func (this FeaturesReply) NTables() uint8 {
	offset := this.NTablesOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FeaturesReply) SetNTables(n uint8) {
	offset := this.NTablesOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this FeaturesReply) NTablesOffset() int {
	offset := 20
	return offset
}

func (this FeaturesReply) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FeaturesReply) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FeaturesReply) PadOffset() int {
	offset := 21
	return offset
}

func (this FeaturesReply) Capabilities() uint32 {
	offset := this.CapabilitiesOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetCapabilities(c uint32) {
	offset := this.CapabilitiesOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this FeaturesReply) CapabilitiesOffset() int {
	offset := 24
	return offset
}

func (this FeaturesReply) Actions() uint32 {
	offset := this.ActionsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetActions(a uint32) {
	offset := this.ActionsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this FeaturesReply) ActionsOffset() int {
	offset := 28
	return offset
}

func (this FeaturesReply) Ports() []Port {
	offset := this.PortsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Port
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewPortWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FeaturesReply) AddPorts(p Port) {
	offset := this.PortsOffset()
	offset += this.PortsSize()
	size := p.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], p.Buf[:size])
	offset += size
}

func (this FeaturesReply) PortsOffset() int {
	offset := 32
	return offset
}

func (this FeaturesReply) PortsSize() int {
	offset := this.PortsOffset()
	size := this.Size()
	return size - offset
}

func NewPortStatusWithBuf(b []byte) PortStatus {
	return PortStatus{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPortStatus() PortStatus {
	s := 80
	b := make([]byte, s)
	p := PortStatus{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PortStatus struct {
	Header12
}

func (this PortStatus) minSize() int {
	return 80
}

func (this PortStatus) Clone() (PortStatus, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStatus(), err
	}

	return NewPortStatusWithBuf(newBuf.Bytes()), nil
}

type PortStatusConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPortStatusConn(c net.Conn) PortStatusConn {
	return PortStatusConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatusConn) WritePortStatus(pkt PortStatus) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortStatusConn) WritePortStatuss(pkts []PortStatus) error {
	for _, p := range pkts {
		if err := c.WritePortStatus(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortStatusConn) Flush() error {
	return c.w.Flush()
}

func (c *PortStatusConn) ReadPortStatus() (PortStatus, error) {
	pkts := make([]PortStatus, 1)
	_, err := c.ReadPortStatuss(pkts)
	if err != nil {
		return NewPortStatus(), err
	}

	return pkts[0], nil
}

func (c *PortStatusConn) ReadPortStatuss(pkts []PortStatus) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatusWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortStatus) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(12))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PortStatus) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStatus(p Header12) (PortStatus, error) {
	if !IsPortStatus(p) {
		return NewPortStatusWithBuf(nil), errors.New("Cannot convert to of12.PortStatus")
	}

	return NewPortStatusWithBuf(p.Buf), nil
}

func IsPortStatus(p Header12) bool {
	return p.Type() == 12 && true
}

func (this PortStatus) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PortStatus) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this PortStatus) ReasonOffset() int {
	offset := 8
	return offset
}

func (this PortStatus) Pad() [7]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 7
	i := 0
	var res [7]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStatus) SetPad(p [7]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PortStatus) PadOffset() int {
	offset := 9
	return offset
}

func (this PortStatus) Desc() Port {
	offset := this.DescOffset()
	res := NewPortWithBuf(this.Buf[offset:])
	return res
}

func (this *PortStatus) SetDesc(d Port) {
	offset := this.DescOffset()
	copy(this.Buf[offset:], d.Buf[:d.Size()])
	offset += d.Size()
}

func (this PortStatus) DescOffset() int {
	offset := 16
	return offset
}

func NewPortModWithBuf(b []byte) PortMod {
	return PortMod{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPortMod() PortMod {
	s := 32
	b := make([]byte, s)
	p := PortMod{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PortMod struct {
	Header12
}

func (this PortMod) minSize() int {
	return 32
}

func (this PortMod) Clone() (PortMod, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortMod(), err
	}

	return NewPortModWithBuf(newBuf.Bytes()), nil
}

type PortModConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPortModConn(c net.Conn) PortModConn {
	return PortModConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortModConn) WritePortMod(pkt PortMod) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortModConn) WritePortMods(pkts []PortMod) error {
	for _, p := range pkts {
		if err := c.WritePortMod(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortModConn) Flush() error {
	return c.w.Flush()
}

func (c *PortModConn) ReadPortMod() (PortMod, error) {
	pkts := make([]PortMod, 1)
	_, err := c.ReadPortMods(pkts)
	if err != nil {
		return NewPortMod(), err
	}

	return pkts[0], nil
}

func (c *PortModConn) ReadPortMods(pkts []PortMod) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortModWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortMod) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(16))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PortMod) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortMod(p Header12) (PortMod, error) {
	if !IsPortMod(p) {
		return NewPortModWithBuf(nil), errors.New("Cannot convert to of12.PortMod")
	}

	return NewPortModWithBuf(p.Buf), nil
}

func IsPortMod(p Header12) bool {
	return p.Type() == 16 && true
}

func (this PortMod) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortMod) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this PortMod) PortNoOffset() int {
	offset := 8
	return offset
}

func (this PortMod) HwAddr() [6]uint8 {
	offset := this.HwAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortMod) SetHwAddr(h [6]uint8) {
	offset := this.HwAddrOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PortMod) HwAddrOffset() int {
	offset := 10
	return offset
}

func (this PortMod) Config() uint32 {
	offset := this.ConfigOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetConfig(c uint32) {
	offset := this.ConfigOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this PortMod) ConfigOffset() int {
	offset := 16
	return offset
}

func (this PortMod) Mask() uint32 {
	offset := this.MaskOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetMask(m uint32) {
	offset := this.MaskOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this PortMod) MaskOffset() int {
	offset := 20
	return offset
}

func (this PortMod) Advertise() uint32 {
	offset := this.AdvertiseOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetAdvertise(a uint32) {
	offset := this.AdvertiseOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this PortMod) AdvertiseOffset() int {
	offset := 24
	return offset
}

func (this PortMod) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortMod) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PortMod) PadOffset() int {
	offset := 28
	return offset
}

func NewActionWithBuf(b []byte) Action {
	return Action{packet.Packet{Buf: b}}
}

func NewAction() Action {
	s := 4
	b := make([]byte, s)
	p := Action{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Action struct {
	packet.Packet
}

func (this Action) minSize() int {
	return 4
}

func (this Action) Clone() (Action, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAction(), err
	}

	return NewActionWithBuf(newBuf.Bytes()), nil
}

type ActionConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewActionConn(c net.Conn) ActionConn {
	return ActionConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionConn) WriteAction(pkt Action) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ActionConn) WriteActions(pkts []Action) error {
	for _, p := range pkts {
		if err := c.WriteAction(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ActionConn) Flush() error {
	return c.w.Flush()
}

func (c *ActionConn) ReadAction() (Action, error) {
	pkts := make([]Action, 1)
	_, err := c.ReadActions(pkts)
	if err != nil {
		return NewAction(), err
	}

	return pkts[0], nil
}

func (c *ActionConn) ReadActions(pkts []Action) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Action) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this Action) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToAction(p packet.Packet) (Action, error) {
	if !IsAction(p) {
		return NewActionWithBuf(nil), errors.New("Cannot convert to of12.Action")
	}

	return NewActionWithBuf(p.Buf), nil
}

func IsAction(p packet.Packet) bool {
	return true
}

func (this Action) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Action) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this Action) TypeOffset() int {
	offset := 0
	return offset
}

func (this Action) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Action) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this Action) LenOffset() int {
	offset := 2
	return offset
}

func NewActionOutputWithBuf(b []byte) ActionOutput {
	return ActionOutput{Action{packet.Packet{Buf: b}}}
}

func NewActionOutput() ActionOutput {
	s := 16
	b := make([]byte, s)
	p := ActionOutput{Action{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionOutput struct {
	Action
}

func (this ActionOutput) minSize() int {
	return 16
}

func (this ActionOutput) Clone() (ActionOutput, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionOutput(), err
	}

	return NewActionOutputWithBuf(newBuf.Bytes()), nil
}

type ActionOutputConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewActionOutputConn(c net.Conn) ActionOutputConn {
	return ActionOutputConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionOutputConn) WriteActionOutput(pkt ActionOutput) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ActionOutputConn) WriteActionOutputs(pkts []ActionOutput) error {
	for _, p := range pkts {
		if err := c.WriteActionOutput(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ActionOutputConn) Flush() error {
	return c.w.Flush()
}

func (c *ActionOutputConn) ReadActionOutput() (ActionOutput, error) {
	pkts := make([]ActionOutput, 1)
	_, err := c.ReadActionOutputs(pkts)
	if err != nil {
		return NewActionOutput(), err
	}

	return pkts[0], nil
}

func (c *ActionOutputConn) ReadActionOutputs(pkts []ActionOutput) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionOutputWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ActionOutput) Init() {
	this.Action.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(0)) // type
}

func (this ActionOutput) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionOutput(p Action) (ActionOutput, error) {
	if !IsActionOutput(p) {
		return NewActionOutputWithBuf(nil), errors.New("Cannot convert to of12.ActionOutput")
	}

	return NewActionOutputWithBuf(p.Buf), nil
}

func IsActionOutput(p Action) bool {
	return p.Type() == 0 && true
}

func (this ActionOutput) Port() uint32 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *ActionOutput) SetPort(p uint32) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this ActionOutput) PortOffset() int {
	offset := 4
	return offset
}

func (this ActionOutput) MaxLen() uint16 {
	offset := this.MaxLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionOutput) SetMaxLen(m uint16) {
	offset := this.MaxLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this ActionOutput) MaxLenOffset() int {
	offset := 8
	return offset
}

func (this ActionOutput) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionOutput) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this ActionOutput) PadOffset() int {
	offset := 10
	return offset
}

func NewInstructionWithBuf(b []byte) Instruction {
	return Instruction{packet.Packet{Buf: b}}
}

func NewInstruction() Instruction {
	s := 4
	b := make([]byte, s)
	p := Instruction{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Instruction struct {
	packet.Packet
}

func (this Instruction) minSize() int {
	return 4
}

func (this Instruction) Clone() (Instruction, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewInstruction(), err
	}

	return NewInstructionWithBuf(newBuf.Bytes()), nil
}

type InstructionConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewInstructionConn(c net.Conn) InstructionConn {
	return InstructionConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *InstructionConn) WriteInstruction(pkt Instruction) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *InstructionConn) WriteInstructions(pkts []Instruction) error {
	for _, p := range pkts {
		if err := c.WriteInstruction(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *InstructionConn) Flush() error {
	return c.w.Flush()
}

func (c *InstructionConn) ReadInstruction() (Instruction, error) {
	pkts := make([]Instruction, 1)
	_, err := c.ReadInstructions(pkts)
	if err != nil {
		return NewInstruction(), err
	}

	return pkts[0], nil
}

func (c *InstructionConn) ReadInstructions(pkts []Instruction) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewInstructionWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Instruction) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this Instruction) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToInstruction(p packet.Packet) (Instruction, error) {
	if !IsInstruction(p) {
		return NewInstructionWithBuf(nil), errors.New("Cannot convert to of12.Instruction")
	}

	return NewInstructionWithBuf(p.Buf), nil
}

func IsInstruction(p packet.Packet) bool {
	return true
}

func (this Instruction) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Instruction) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this Instruction) TypeOffset() int {
	offset := 0
	return offset
}

func (this Instruction) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Instruction) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this Instruction) LenOffset() int {
	offset := 2
	return offset
}

func NewApplyActionsWithBuf(b []byte) ApplyActions {
	return ApplyActions{Instruction{packet.Packet{Buf: b}}}
}

func NewApplyActions() ApplyActions {
	s := 8
	b := make([]byte, s)
	p := ApplyActions{Instruction{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ApplyActions struct {
	Instruction
}

func (this ApplyActions) minSize() int {
	return 8
}

func (this ApplyActions) Clone() (ApplyActions, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewApplyActions(), err
	}

	return NewApplyActionsWithBuf(newBuf.Bytes()), nil
}

type ApplyActionsConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewApplyActionsConn(c net.Conn) ApplyActionsConn {
	return ApplyActionsConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ApplyActionsConn) WriteApplyActions(pkt ApplyActions) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ApplyActionsConn) WriteApplyActionss(pkts []ApplyActions) error {
	for _, p := range pkts {
		if err := c.WriteApplyActions(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ApplyActionsConn) Flush() error {
	return c.w.Flush()
}

func (c *ApplyActionsConn) ReadApplyActions() (ApplyActions, error) {
	pkts := make([]ApplyActions, 1)
	_, err := c.ReadApplyActionss(pkts)
	if err != nil {
		return NewApplyActions(), err
	}

	return pkts[0], nil
}

func (c *ApplyActionsConn) ReadApplyActionss(pkts []ApplyActions) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewApplyActionsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ApplyActions) Init() {
	this.Instruction.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(4)) // type
}

func (this ApplyActions) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToApplyActions(p Instruction) (ApplyActions, error) {
	if !IsApplyActions(p) {
		return NewApplyActionsWithBuf(nil), errors.New("Cannot convert to of12.ApplyActions")
	}

	return NewApplyActionsWithBuf(p.Buf), nil
}

func IsApplyActions(p Instruction) bool {
	return p.Type() == 4 && true
}

func (this ApplyActions) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ApplyActions) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this ApplyActions) PadOffset() int {
	offset := 4
	return offset
}

func (this ApplyActions) Actions() []Action {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Action
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *ApplyActions) AddActions(a Action) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLen(uint16(pSize + size))
	copy(this.Buf[offset:], a.Buf[:size])
	offset += size
}

func (this ApplyActions) ActionsOffset() int {
	offset := 8
	return offset
}

func (this ApplyActions) ActionsSize() int {
	offset := this.ActionsOffset()
	size := this.Size()
	return size - offset
}

func NewPacketOutWithBuf(b []byte) PacketOut {
	return PacketOut{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPacketOut() PacketOut {
	s := 24
	b := make([]byte, s)
	p := PacketOut{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PacketOut struct {
	Header12
}

func (this PacketOut) minSize() int {
	return 24
}

func (this PacketOut) Clone() (PacketOut, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketOut(), err
	}

	return NewPacketOutWithBuf(newBuf.Bytes()), nil
}

type PacketOutConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPacketOutConn(c net.Conn) PacketOutConn {
	return PacketOutConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketOutConn) WritePacketOut(pkt PacketOut) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PacketOutConn) WritePacketOuts(pkts []PacketOut) error {
	for _, p := range pkts {
		if err := c.WritePacketOut(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PacketOutConn) Flush() error {
	return c.w.Flush()
}

func (c *PacketOutConn) ReadPacketOut() (PacketOut, error) {
	pkts := make([]PacketOut, 1)
	_, err := c.ReadPacketOuts(pkts)
	if err != nil {
		return NewPacketOut(), err
	}

	return pkts[0], nil
}

func (c *PacketOutConn) ReadPacketOuts(pkts []PacketOut) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketOutWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PacketOut) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(13))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PacketOut) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPacketOut(p Header12) (PacketOut, error) {
	if !IsPacketOut(p) {
		return NewPacketOutWithBuf(nil), errors.New("Cannot convert to of12.PacketOut")
	}

	return NewPacketOutWithBuf(p.Buf), nil
}

func IsPacketOut(p Header12) bool {
	return p.Type() == 13 && true
}

func (this PacketOut) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this PacketOut) BufferIdOffset() int {
	offset := 8
	return offset
}

func (this PacketOut) InPort() uint32 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetInPort(i uint32) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], i)
	offset += 4
}

func (this PacketOut) InPortOffset() int {
	offset := 12
	return offset
}

func (this PacketOut) ActionsLen() uint16 {
	offset := this.ActionsLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetActionsLen(a uint16) {
	offset := this.ActionsLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], a)
	offset += 2
}

func (this PacketOut) ActionsLenOffset() int {
	offset := 16
	return offset
}

func (this PacketOut) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PacketOut) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PacketOut) PadOffset() int {
	offset := 18
	return offset
}

func (this PacketOut) Actions() []Action {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := int(this.ActionsLen())
	count := this.Size() - offset
	var res []Action
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketOut) AddActions(a Action) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], a.Buf[:size])
	offset += size
	this.SetActionsLen(this.ActionsLen() + uint16(size))
}

func (this PacketOut) ActionsOffset() int {
	offset := 24
	return offset
}

func (this PacketOut) ActionsSize() int {
	return int(this.ActionsLen())
}

func (this PacketOut) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	return []uint8(this.Buf[offset : offset+size])
}

func (this *PacketOut) AddData(d uint8) {
	offset := this.DataOffset()
	offset += this.DataSize()
	size := 1
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this PacketOut) DataOffset() int {
	offset := 24
	offset += this.ActionsSize()
	return offset
}

func (this PacketOut) DataSize() int {
	offset := this.DataOffset()
	size := this.Size()
	return size - offset
}

func NewOxmFieldWithBuf(b []byte) OxmField {
	return OxmField{packet.Packet{Buf: b}}
}

func NewOxmField() OxmField {
	s := packet.PaddedSize(4, 1, 4)
	b := make([]byte, s)
	p := OxmField{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type OxmField struct {
	packet.Packet
}

func (this OxmField) minSize() int {
	return 4
}

func (this OxmField) Clone() (OxmField, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmField(), err
	}

	return NewOxmFieldWithBuf(newBuf.Bytes()), nil
}

type OxmFieldConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmFieldConn(c net.Conn) OxmFieldConn {
	return OxmFieldConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmFieldConn) WriteOxmField(pkt OxmField) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmFieldConn) WriteOxmFields(pkts []OxmField) error {
	for _, p := range pkts {
		if err := c.WriteOxmField(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmFieldConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmFieldConn) ReadOxmField() (OxmField, error) {
	pkts := make([]OxmField, 1)
	_, err := c.ReadOxmFields(pkts)
	if err != nil {
		return NewOxmField(), err
	}

	return pkts[0], nil
}

func (c *OxmFieldConn) ReadOxmFields(pkts []OxmField) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmFieldWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmField) Init() {
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
}

func (this OxmField) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmField(p packet.Packet) (OxmField, error) {
	if !IsOxmField(p) {
		return NewOxmFieldWithBuf(nil), errors.New("Cannot convert to of12.OxmField")
	}

	return NewOxmFieldWithBuf(p.Buf), nil
}

func IsOxmField(p packet.Packet) bool {
	return true
}

func (this OxmField) OxmClass() uint16 {
	offset := this.OxmClassOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *OxmField) SetOxmClass(o uint16) {
	offset := this.OxmClassOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this OxmField) OxmClassOffset() int {
	offset := 0
	return offset
}

func (this OxmField) OxmField() uint8 {
	offset := this.OxmFieldOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *OxmField) SetOxmField(o uint8) {
	offset := this.OxmFieldOffset()
	this.Buf[offset] = byte(o)
	offset++
}

func (this OxmField) OxmFieldOffset() int {
	offset := 2
	return offset
}

func (this OxmField) OxmLength() uint8 {
	offset := this.OxmLengthOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *OxmField) SetOxmLength(o uint8) {
	offset := this.OxmLengthOffset()
	this.Buf[offset] = byte(o)
	offset++
}

func (this OxmField) OxmLengthOffset() int {
	offset := 3
	return offset
}

func NewOxmInPortWithBuf(b []byte) OxmInPort {
	return OxmInPort{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmInPort() OxmInPort {
	s := packet.PaddedSize(8, 1, 4)
	b := make([]byte, s)
	p := OxmInPort{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmInPort struct {
	OxmField
}

func (this OxmInPort) minSize() int {
	return 8
}

func (this OxmInPort) Clone() (OxmInPort, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmInPort(), err
	}

	return NewOxmInPortWithBuf(newBuf.Bytes()), nil
}

type OxmInPortConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmInPortConn(c net.Conn) OxmInPortConn {
	return OxmInPortConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmInPortConn) WriteOxmInPort(pkt OxmInPort) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmInPortConn) WriteOxmInPorts(pkts []OxmInPort) error {
	for _, p := range pkts {
		if err := c.WriteOxmInPort(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmInPortConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmInPortConn) ReadOxmInPort() (OxmInPort, error) {
	pkts := make([]OxmInPort, 1)
	_, err := c.ReadOxmInPorts(pkts)
	if err != nil {
		return NewOxmInPort(), err
	}

	return pkts[0], nil
}

func (c *OxmInPortConn) ReadOxmInPorts(pkts []OxmInPort) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmInPortWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmInPort) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(0))      // oxm_field
	this.SetOxmLength(uint8(4))     // oxm_length
}

func (this OxmInPort) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmInPort(p OxmField) (OxmInPort, error) {
	if !IsOxmInPort(p) {
		return NewOxmInPortWithBuf(nil), errors.New("Cannot convert to of12.OxmInPort")
	}

	return NewOxmInPortWithBuf(p.Buf), nil
}

func IsOxmInPort(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 0 && p.OxmLength() == 4 && true
}

func (this OxmInPort) InPort() uint32 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *OxmInPort) SetInPort(i uint32) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], i)
	offset += 4
}

func (this OxmInPort) InPortOffset() int {
	offset := 4
	return offset
}

func NewOxmEthDstWithBuf(b []byte) OxmEthDst {
	return OxmEthDst{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthDst() OxmEthDst {
	s := packet.PaddedSize(10, 1, 4)
	b := make([]byte, s)
	p := OxmEthDst{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthDst struct {
	OxmField
}

func (this OxmEthDst) minSize() int {
	return 10
}

func (this OxmEthDst) Clone() (OxmEthDst, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthDst(), err
	}

	return NewOxmEthDstWithBuf(newBuf.Bytes()), nil
}

type OxmEthDstConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmEthDstConn(c net.Conn) OxmEthDstConn {
	return OxmEthDstConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthDstConn) WriteOxmEthDst(pkt OxmEthDst) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthDstConn) WriteOxmEthDsts(pkts []OxmEthDst) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthDst(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthDstConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmEthDstConn) ReadOxmEthDst() (OxmEthDst, error) {
	pkts := make([]OxmEthDst, 1)
	_, err := c.ReadOxmEthDsts(pkts)
	if err != nil {
		return NewOxmEthDst(), err
	}

	return pkts[0], nil
}

func (c *OxmEthDstConn) ReadOxmEthDsts(pkts []OxmEthDst) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthDstWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthDst) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(6))      // oxm_field
	this.SetOxmLength(uint8(6))     // oxm_length
}

func (this OxmEthDst) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmEthDst(p OxmField) (OxmEthDst, error) {
	if !IsOxmEthDst(p) {
		return NewOxmEthDstWithBuf(nil), errors.New("Cannot convert to of12.OxmEthDst")
	}

	return NewOxmEthDstWithBuf(p.Buf), nil
}

func IsOxmEthDst(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 6 && p.OxmLength() == 6 && true
}

func (this OxmEthDst) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthDst) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmEthDst) MacAddrOffset() int {
	offset := 4
	return offset
}

func NewOxmEthDstMaskedWithBuf(b []byte) OxmEthDstMasked {
	return OxmEthDstMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthDstMasked() OxmEthDstMasked {
	s := packet.PaddedSize(16, 1, 4)
	b := make([]byte, s)
	p := OxmEthDstMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthDstMasked struct {
	OxmField
}

func (this OxmEthDstMasked) minSize() int {
	return 16
}

func (this OxmEthDstMasked) Clone() (OxmEthDstMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthDstMasked(), err
	}

	return NewOxmEthDstMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmEthDstMaskedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmEthDstMaskedConn(c net.Conn) OxmEthDstMaskedConn {
	return OxmEthDstMaskedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthDstMaskedConn) WriteOxmEthDstMasked(pkt OxmEthDstMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthDstMaskedConn) WriteOxmEthDstMaskeds(pkts []OxmEthDstMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthDstMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthDstMaskedConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmEthDstMaskedConn) ReadOxmEthDstMasked() (OxmEthDstMasked, error) {
	pkts := make([]OxmEthDstMasked, 1)
	_, err := c.ReadOxmEthDstMaskeds(pkts)
	if err != nil {
		return NewOxmEthDstMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmEthDstMaskedConn) ReadOxmEthDstMaskeds(pkts []OxmEthDstMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthDstMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthDstMasked) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(7))      // oxm_field
	this.SetOxmLength(uint8(12))    // oxm_length
}

func (this OxmEthDstMasked) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmEthDstMasked(p OxmField) (OxmEthDstMasked, error) {
	if !IsOxmEthDstMasked(p) {
		return NewOxmEthDstMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmEthDstMasked")
	}

	return NewOxmEthDstMaskedWithBuf(p.Buf), nil
}

func IsOxmEthDstMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 7 && p.OxmLength() == 12 && true
}

func (this OxmEthDstMasked) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthDstMasked) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmEthDstMasked) MacAddrOffset() int {
	offset := 4
	return offset
}

func (this OxmEthDstMasked) Mask() [6]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthDstMasked) SetMask(m [6]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmEthDstMasked) MaskOffset() int {
	offset := 10
	return offset
}

func NewOxmEthSrcWithBuf(b []byte) OxmEthSrc {
	return OxmEthSrc{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthSrc() OxmEthSrc {
	s := packet.PaddedSize(10, 1, 4)
	b := make([]byte, s)
	p := OxmEthSrc{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthSrc struct {
	OxmField
}

func (this OxmEthSrc) minSize() int {
	return 10
}

func (this OxmEthSrc) Clone() (OxmEthSrc, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthSrc(), err
	}

	return NewOxmEthSrcWithBuf(newBuf.Bytes()), nil
}

type OxmEthSrcConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmEthSrcConn(c net.Conn) OxmEthSrcConn {
	return OxmEthSrcConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthSrcConn) WriteOxmEthSrc(pkt OxmEthSrc) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthSrcConn) WriteOxmEthSrcs(pkts []OxmEthSrc) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthSrc(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthSrcConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmEthSrcConn) ReadOxmEthSrc() (OxmEthSrc, error) {
	pkts := make([]OxmEthSrc, 1)
	_, err := c.ReadOxmEthSrcs(pkts)
	if err != nil {
		return NewOxmEthSrc(), err
	}

	return pkts[0], nil
}

func (c *OxmEthSrcConn) ReadOxmEthSrcs(pkts []OxmEthSrc) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthSrcWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthSrc) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(8))      // oxm_field
	this.SetOxmLength(uint8(6))     // oxm_length
}

func (this OxmEthSrc) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmEthSrc(p OxmField) (OxmEthSrc, error) {
	if !IsOxmEthSrc(p) {
		return NewOxmEthSrcWithBuf(nil), errors.New("Cannot convert to of12.OxmEthSrc")
	}

	return NewOxmEthSrcWithBuf(p.Buf), nil
}

func IsOxmEthSrc(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 8 && p.OxmLength() == 6 && true
}

func (this OxmEthSrc) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthSrc) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmEthSrc) MacAddrOffset() int {
	offset := 4
	return offset
}

func NewOxmEthSrcMaskedWithBuf(b []byte) OxmEthSrcMasked {
	return OxmEthSrcMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthSrcMasked() OxmEthSrcMasked {
	s := packet.PaddedSize(16, 1, 4)
	b := make([]byte, s)
	p := OxmEthSrcMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthSrcMasked struct {
	OxmField
}

func (this OxmEthSrcMasked) minSize() int {
	return 16
}

func (this OxmEthSrcMasked) Clone() (OxmEthSrcMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthSrcMasked(), err
	}

	return NewOxmEthSrcMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmEthSrcMaskedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmEthSrcMaskedConn(c net.Conn) OxmEthSrcMaskedConn {
	return OxmEthSrcMaskedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthSrcMaskedConn) WriteOxmEthSrcMasked(pkt OxmEthSrcMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthSrcMaskedConn) WriteOxmEthSrcMaskeds(pkts []OxmEthSrcMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthSrcMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthSrcMaskedConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmEthSrcMaskedConn) ReadOxmEthSrcMasked() (OxmEthSrcMasked, error) {
	pkts := make([]OxmEthSrcMasked, 1)
	_, err := c.ReadOxmEthSrcMaskeds(pkts)
	if err != nil {
		return NewOxmEthSrcMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmEthSrcMaskedConn) ReadOxmEthSrcMaskeds(pkts []OxmEthSrcMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthSrcMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthSrcMasked) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(9))      // oxm_field
	this.SetOxmLength(uint8(12))    // oxm_length
}

func (this OxmEthSrcMasked) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmEthSrcMasked(p OxmField) (OxmEthSrcMasked, error) {
	if !IsOxmEthSrcMasked(p) {
		return NewOxmEthSrcMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmEthSrcMasked")
	}

	return NewOxmEthSrcMaskedWithBuf(p.Buf), nil
}

func IsOxmEthSrcMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 9 && p.OxmLength() == 12 && true
}

func (this OxmEthSrcMasked) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthSrcMasked) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmEthSrcMasked) MacAddrOffset() int {
	offset := 4
	return offset
}

func (this OxmEthSrcMasked) Mask() [6]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthSrcMasked) SetMask(m [6]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmEthSrcMasked) MaskOffset() int {
	offset := 10
	return offset
}

func NewOxmEthTypeWithBuf(b []byte) OxmEthType {
	return OxmEthType{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthType() OxmEthType {
	s := packet.PaddedSize(6, 1, 4)
	b := make([]byte, s)
	p := OxmEthType{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthType struct {
	OxmField
}

func (this OxmEthType) minSize() int {
	return 6
}

func (this OxmEthType) Clone() (OxmEthType, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthType(), err
	}

	return NewOxmEthTypeWithBuf(newBuf.Bytes()), nil
}

type OxmEthTypeConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmEthTypeConn(c net.Conn) OxmEthTypeConn {
	return OxmEthTypeConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthTypeConn) WriteOxmEthType(pkt OxmEthType) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthTypeConn) WriteOxmEthTypes(pkts []OxmEthType) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthType(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthTypeConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmEthTypeConn) ReadOxmEthType() (OxmEthType, error) {
	pkts := make([]OxmEthType, 1)
	_, err := c.ReadOxmEthTypes(pkts)
	if err != nil {
		return NewOxmEthType(), err
	}

	return pkts[0], nil
}

func (c *OxmEthTypeConn) ReadOxmEthTypes(pkts []OxmEthType) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthTypeWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthType) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(10))     // oxm_field
	this.SetOxmLength(uint8(2))     // oxm_length
}

func (this OxmEthType) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmEthType(p OxmField) (OxmEthType, error) {
	if !IsOxmEthType(p) {
		return NewOxmEthTypeWithBuf(nil), errors.New("Cannot convert to of12.OxmEthType")
	}

	return NewOxmEthTypeWithBuf(p.Buf), nil
}

func IsOxmEthType(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 10 && p.OxmLength() == 2 && true
}

func (this OxmEthType) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *OxmEthType) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this OxmEthType) TypeOffset() int {
	offset := 4
	return offset
}

func NewOxmIpProtoWithBuf(b []byte) OxmIpProto {
	return OxmIpProto{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpProto() OxmIpProto {
	s := packet.PaddedSize(5, 1, 4)
	b := make([]byte, s)
	p := OxmIpProto{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpProto struct {
	OxmField
}

func (this OxmIpProto) minSize() int {
	return 5
}

func (this OxmIpProto) Clone() (OxmIpProto, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpProto(), err
	}

	return NewOxmIpProtoWithBuf(newBuf.Bytes()), nil
}

type OxmIpProtoConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpProtoConn(c net.Conn) OxmIpProtoConn {
	return OxmIpProtoConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpProtoConn) WriteOxmIpProto(pkt OxmIpProto) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpProtoConn) WriteOxmIpProtos(pkts []OxmIpProto) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpProto(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpProtoConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpProtoConn) ReadOxmIpProto() (OxmIpProto, error) {
	pkts := make([]OxmIpProto, 1)
	_, err := c.ReadOxmIpProtos(pkts)
	if err != nil {
		return NewOxmIpProto(), err
	}

	return pkts[0], nil
}

func (c *OxmIpProtoConn) ReadOxmIpProtos(pkts []OxmIpProto) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpProtoWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpProto) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(20))     // oxm_field
	this.SetOxmLength(uint8(1))     // oxm_length
}

func (this OxmIpProto) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpProto(p OxmField) (OxmIpProto, error) {
	if !IsOxmIpProto(p) {
		return NewOxmIpProtoWithBuf(nil), errors.New("Cannot convert to of12.OxmIpProto")
	}

	return NewOxmIpProtoWithBuf(p.Buf), nil
}

func IsOxmIpProto(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 20 && p.OxmLength() == 1 && true
}

func (this OxmIpProto) Proto() uint8 {
	offset := this.ProtoOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *OxmIpProto) SetProto(p uint8) {
	offset := this.ProtoOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this OxmIpProto) ProtoOffset() int {
	offset := 4
	return offset
}

func NewOxmIpV4SrcWithBuf(b []byte) OxmIpV4Src {
	return OxmIpV4Src{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV4Src() OxmIpV4Src {
	s := packet.PaddedSize(12, 1, 4)
	b := make([]byte, s)
	p := OxmIpV4Src{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV4Src struct {
	OxmField
}

func (this OxmIpV4Src) minSize() int {
	return 12
}

func (this OxmIpV4Src) Clone() (OxmIpV4Src, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV4Src(), err
	}

	return NewOxmIpV4SrcWithBuf(newBuf.Bytes()), nil
}

type OxmIpV4SrcConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV4SrcConn(c net.Conn) OxmIpV4SrcConn {
	return OxmIpV4SrcConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV4SrcConn) WriteOxmIpV4Src(pkt OxmIpV4Src) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV4SrcConn) WriteOxmIpV4Srcs(pkts []OxmIpV4Src) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV4Src(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV4SrcConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV4SrcConn) ReadOxmIpV4Src() (OxmIpV4Src, error) {
	pkts := make([]OxmIpV4Src, 1)
	_, err := c.ReadOxmIpV4Srcs(pkts)
	if err != nil {
		return NewOxmIpV4Src(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV4SrcConn) ReadOxmIpV4Srcs(pkts []OxmIpV4Src) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV4SrcWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV4Src) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(22))     // oxm_field
	this.SetOxmLength(uint8(4))     // oxm_length
}

func (this OxmIpV4Src) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV4Src(p OxmField) (OxmIpV4Src, error) {
	if !IsOxmIpV4Src(p) {
		return NewOxmIpV4SrcWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV4Src")
	}

	return NewOxmIpV4SrcWithBuf(p.Buf), nil
}

func IsOxmIpV4Src(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 22 && p.OxmLength() == 4 && true
}

func (this OxmIpV4Src) Addr() [4]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4Src) SetAddr(a [4]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4Src) AddrOffset() int {
	offset := 4
	return offset
}

func (this OxmIpV4Src) Mask() [4]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4Src) SetMask(m [4]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4Src) MaskOffset() int {
	offset := 8
	return offset
}

func NewOxmIpV4SrcMaskedWithBuf(b []byte) OxmIpV4SrcMasked {
	return OxmIpV4SrcMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV4SrcMasked() OxmIpV4SrcMasked {
	s := packet.PaddedSize(12, 1, 4)
	b := make([]byte, s)
	p := OxmIpV4SrcMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV4SrcMasked struct {
	OxmField
}

func (this OxmIpV4SrcMasked) minSize() int {
	return 12
}

func (this OxmIpV4SrcMasked) Clone() (OxmIpV4SrcMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV4SrcMasked(), err
	}

	return NewOxmIpV4SrcMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmIpV4SrcMaskedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV4SrcMaskedConn(c net.Conn) OxmIpV4SrcMaskedConn {
	return OxmIpV4SrcMaskedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV4SrcMaskedConn) WriteOxmIpV4SrcMasked(pkt OxmIpV4SrcMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV4SrcMaskedConn) WriteOxmIpV4SrcMaskeds(pkts []OxmIpV4SrcMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV4SrcMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV4SrcMaskedConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV4SrcMaskedConn) ReadOxmIpV4SrcMasked() (OxmIpV4SrcMasked, error) {
	pkts := make([]OxmIpV4SrcMasked, 1)
	_, err := c.ReadOxmIpV4SrcMaskeds(pkts)
	if err != nil {
		return NewOxmIpV4SrcMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV4SrcMaskedConn) ReadOxmIpV4SrcMaskeds(pkts []OxmIpV4SrcMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV4SrcMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV4SrcMasked) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(23))     // oxm_field
	this.SetOxmLength(uint8(8))     // oxm_length
}

func (this OxmIpV4SrcMasked) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV4SrcMasked(p OxmField) (OxmIpV4SrcMasked, error) {
	if !IsOxmIpV4SrcMasked(p) {
		return NewOxmIpV4SrcMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV4SrcMasked")
	}

	return NewOxmIpV4SrcMaskedWithBuf(p.Buf), nil
}

func IsOxmIpV4SrcMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 23 && p.OxmLength() == 8 && true
}

func (this OxmIpV4SrcMasked) Addr() [4]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4SrcMasked) SetAddr(a [4]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4SrcMasked) AddrOffset() int {
	offset := 4
	return offset
}

func (this OxmIpV4SrcMasked) Mask() [4]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4SrcMasked) SetMask(m [4]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4SrcMasked) MaskOffset() int {
	offset := 8
	return offset
}

func NewOxmIpV4DstWithBuf(b []byte) OxmIpV4Dst {
	return OxmIpV4Dst{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV4Dst() OxmIpV4Dst {
	s := packet.PaddedSize(8, 1, 4)
	b := make([]byte, s)
	p := OxmIpV4Dst{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV4Dst struct {
	OxmField
}

func (this OxmIpV4Dst) minSize() int {
	return 8
}

func (this OxmIpV4Dst) Clone() (OxmIpV4Dst, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV4Dst(), err
	}

	return NewOxmIpV4DstWithBuf(newBuf.Bytes()), nil
}

type OxmIpV4DstConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV4DstConn(c net.Conn) OxmIpV4DstConn {
	return OxmIpV4DstConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV4DstConn) WriteOxmIpV4Dst(pkt OxmIpV4Dst) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV4DstConn) WriteOxmIpV4Dsts(pkts []OxmIpV4Dst) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV4Dst(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV4DstConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV4DstConn) ReadOxmIpV4Dst() (OxmIpV4Dst, error) {
	pkts := make([]OxmIpV4Dst, 1)
	_, err := c.ReadOxmIpV4Dsts(pkts)
	if err != nil {
		return NewOxmIpV4Dst(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV4DstConn) ReadOxmIpV4Dsts(pkts []OxmIpV4Dst) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV4DstWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV4Dst) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(24))     // oxm_field
	this.SetOxmLength(uint8(4))     // oxm_length
}

func (this OxmIpV4Dst) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV4Dst(p OxmField) (OxmIpV4Dst, error) {
	if !IsOxmIpV4Dst(p) {
		return NewOxmIpV4DstWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV4Dst")
	}

	return NewOxmIpV4DstWithBuf(p.Buf), nil
}

func IsOxmIpV4Dst(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 24 && p.OxmLength() == 4 && true
}

func (this OxmIpV4Dst) Addr() [4]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4Dst) SetAddr(a [4]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4Dst) AddrOffset() int {
	offset := 4
	return offset
}

func NewOxmIpV4DstMaskedWithBuf(b []byte) OxmIpV4DstMasked {
	return OxmIpV4DstMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV4DstMasked() OxmIpV4DstMasked {
	s := packet.PaddedSize(12, 1, 4)
	b := make([]byte, s)
	p := OxmIpV4DstMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV4DstMasked struct {
	OxmField
}

func (this OxmIpV4DstMasked) minSize() int {
	return 12
}

func (this OxmIpV4DstMasked) Clone() (OxmIpV4DstMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV4DstMasked(), err
	}

	return NewOxmIpV4DstMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmIpV4DstMaskedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV4DstMaskedConn(c net.Conn) OxmIpV4DstMaskedConn {
	return OxmIpV4DstMaskedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV4DstMaskedConn) WriteOxmIpV4DstMasked(pkt OxmIpV4DstMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV4DstMaskedConn) WriteOxmIpV4DstMaskeds(pkts []OxmIpV4DstMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV4DstMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV4DstMaskedConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV4DstMaskedConn) ReadOxmIpV4DstMasked() (OxmIpV4DstMasked, error) {
	pkts := make([]OxmIpV4DstMasked, 1)
	_, err := c.ReadOxmIpV4DstMaskeds(pkts)
	if err != nil {
		return NewOxmIpV4DstMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV4DstMaskedConn) ReadOxmIpV4DstMaskeds(pkts []OxmIpV4DstMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV4DstMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV4DstMasked) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(25))     // oxm_field
	this.SetOxmLength(uint8(8))     // oxm_length
}

func (this OxmIpV4DstMasked) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV4DstMasked(p OxmField) (OxmIpV4DstMasked, error) {
	if !IsOxmIpV4DstMasked(p) {
		return NewOxmIpV4DstMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV4DstMasked")
	}

	return NewOxmIpV4DstMaskedWithBuf(p.Buf), nil
}

func IsOxmIpV4DstMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 25 && p.OxmLength() == 8 && true
}

func (this OxmIpV4DstMasked) Addr() [4]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4DstMasked) SetAddr(a [4]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4DstMasked) AddrOffset() int {
	offset := 4
	return offset
}

func (this OxmIpV4DstMasked) Mask() [4]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV4DstMasked) SetMask(m [4]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV4DstMasked) MaskOffset() int {
	offset := 8
	return offset
}

func NewOxmIpV6SrcWithBuf(b []byte) OxmIpV6Src {
	return OxmIpV6Src{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV6Src() OxmIpV6Src {
	s := packet.PaddedSize(20, 1, 4)
	b := make([]byte, s)
	p := OxmIpV6Src{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV6Src struct {
	OxmField
}

func (this OxmIpV6Src) minSize() int {
	return 20
}

func (this OxmIpV6Src) Clone() (OxmIpV6Src, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV6Src(), err
	}

	return NewOxmIpV6SrcWithBuf(newBuf.Bytes()), nil
}

type OxmIpV6SrcConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV6SrcConn(c net.Conn) OxmIpV6SrcConn {
	return OxmIpV6SrcConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV6SrcConn) WriteOxmIpV6Src(pkt OxmIpV6Src) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV6SrcConn) WriteOxmIpV6Srcs(pkts []OxmIpV6Src) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV6Src(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV6SrcConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV6SrcConn) ReadOxmIpV6Src() (OxmIpV6Src, error) {
	pkts := make([]OxmIpV6Src, 1)
	_, err := c.ReadOxmIpV6Srcs(pkts)
	if err != nil {
		return NewOxmIpV6Src(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV6SrcConn) ReadOxmIpV6Srcs(pkts []OxmIpV6Src) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV6SrcWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV6Src) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(52))     // oxm_field
	this.SetOxmLength(uint8(16))    // oxm_length
}

func (this OxmIpV6Src) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV6Src(p OxmField) (OxmIpV6Src, error) {
	if !IsOxmIpV6Src(p) {
		return NewOxmIpV6SrcWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV6Src")
	}

	return NewOxmIpV6SrcWithBuf(p.Buf), nil
}

func IsOxmIpV6Src(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 52 && p.OxmLength() == 16 && true
}

func (this OxmIpV6Src) Addr() [16]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV6Src) SetAddr(a [16]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV6Src) AddrOffset() int {
	offset := 4
	return offset
}

func NewOxmIpV6SrcMaskedWithBuf(b []byte) OxmIpV6SrcMasked {
	return OxmIpV6SrcMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV6SrcMasked() OxmIpV6SrcMasked {
	s := packet.PaddedSize(36, 1, 4)
	b := make([]byte, s)
	p := OxmIpV6SrcMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV6SrcMasked struct {
	OxmField
}

func (this OxmIpV6SrcMasked) minSize() int {
	return 36
}

func (this OxmIpV6SrcMasked) Clone() (OxmIpV6SrcMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV6SrcMasked(), err
	}

	return NewOxmIpV6SrcMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmIpV6SrcMaskedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV6SrcMaskedConn(c net.Conn) OxmIpV6SrcMaskedConn {
	return OxmIpV6SrcMaskedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV6SrcMaskedConn) WriteOxmIpV6SrcMasked(pkt OxmIpV6SrcMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV6SrcMaskedConn) WriteOxmIpV6SrcMaskeds(pkts []OxmIpV6SrcMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV6SrcMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV6SrcMaskedConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV6SrcMaskedConn) ReadOxmIpV6SrcMasked() (OxmIpV6SrcMasked, error) {
	pkts := make([]OxmIpV6SrcMasked, 1)
	_, err := c.ReadOxmIpV6SrcMaskeds(pkts)
	if err != nil {
		return NewOxmIpV6SrcMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV6SrcMaskedConn) ReadOxmIpV6SrcMaskeds(pkts []OxmIpV6SrcMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV6SrcMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV6SrcMasked) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(53))     // oxm_field
	this.SetOxmLength(uint8(32))    // oxm_length
}

func (this OxmIpV6SrcMasked) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV6SrcMasked(p OxmField) (OxmIpV6SrcMasked, error) {
	if !IsOxmIpV6SrcMasked(p) {
		return NewOxmIpV6SrcMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV6SrcMasked")
	}

	return NewOxmIpV6SrcMaskedWithBuf(p.Buf), nil
}

func IsOxmIpV6SrcMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 53 && p.OxmLength() == 32 && true
}

func (this OxmIpV6SrcMasked) Addr() [16]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV6SrcMasked) SetAddr(a [16]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV6SrcMasked) AddrOffset() int {
	offset := 4
	return offset
}

func (this OxmIpV6SrcMasked) Mask() [16]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV6SrcMasked) SetMask(m [16]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV6SrcMasked) MaskOffset() int {
	offset := 20
	return offset
}

func NewOxmIpV6DstWithBuf(b []byte) OxmIpV6Dst {
	return OxmIpV6Dst{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV6Dst() OxmIpV6Dst {
	s := packet.PaddedSize(20, 1, 4)
	b := make([]byte, s)
	p := OxmIpV6Dst{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV6Dst struct {
	OxmField
}

func (this OxmIpV6Dst) minSize() int {
	return 20
}

func (this OxmIpV6Dst) Clone() (OxmIpV6Dst, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV6Dst(), err
	}

	return NewOxmIpV6DstWithBuf(newBuf.Bytes()), nil
}

type OxmIpV6DstConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV6DstConn(c net.Conn) OxmIpV6DstConn {
	return OxmIpV6DstConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV6DstConn) WriteOxmIpV6Dst(pkt OxmIpV6Dst) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV6DstConn) WriteOxmIpV6Dsts(pkts []OxmIpV6Dst) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV6Dst(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV6DstConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV6DstConn) ReadOxmIpV6Dst() (OxmIpV6Dst, error) {
	pkts := make([]OxmIpV6Dst, 1)
	_, err := c.ReadOxmIpV6Dsts(pkts)
	if err != nil {
		return NewOxmIpV6Dst(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV6DstConn) ReadOxmIpV6Dsts(pkts []OxmIpV6Dst) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV6DstWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV6Dst) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(54))     // oxm_field
	this.SetOxmLength(uint8(16))    // oxm_length
}

func (this OxmIpV6Dst) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV6Dst(p OxmField) (OxmIpV6Dst, error) {
	if !IsOxmIpV6Dst(p) {
		return NewOxmIpV6DstWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV6Dst")
	}

	return NewOxmIpV6DstWithBuf(p.Buf), nil
}

func IsOxmIpV6Dst(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 54 && p.OxmLength() == 16 && true
}

func (this OxmIpV6Dst) Addr() [16]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV6Dst) SetAddr(a [16]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV6Dst) AddrOffset() int {
	offset := 4
	return offset
}

func NewOxmIpV6DstMaskedWithBuf(b []byte) OxmIpV6DstMasked {
	return OxmIpV6DstMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmIpV6DstMasked() OxmIpV6DstMasked {
	s := packet.PaddedSize(36, 1, 4)
	b := make([]byte, s)
	p := OxmIpV6DstMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmIpV6DstMasked struct {
	OxmField
}

func (this OxmIpV6DstMasked) minSize() int {
	return 36
}

func (this OxmIpV6DstMasked) Clone() (OxmIpV6DstMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmIpV6DstMasked(), err
	}

	return NewOxmIpV6DstMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmIpV6DstMaskedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmIpV6DstMaskedConn(c net.Conn) OxmIpV6DstMaskedConn {
	return OxmIpV6DstMaskedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmIpV6DstMaskedConn) WriteOxmIpV6DstMasked(pkt OxmIpV6DstMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmIpV6DstMaskedConn) WriteOxmIpV6DstMaskeds(pkts []OxmIpV6DstMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmIpV6DstMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmIpV6DstMaskedConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmIpV6DstMaskedConn) ReadOxmIpV6DstMasked() (OxmIpV6DstMasked, error) {
	pkts := make([]OxmIpV6DstMasked, 1)
	_, err := c.ReadOxmIpV6DstMaskeds(pkts)
	if err != nil {
		return NewOxmIpV6DstMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmIpV6DstMaskedConn) ReadOxmIpV6DstMaskeds(pkts []OxmIpV6DstMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmIpV6DstMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmIpV6DstMasked) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(55))     // oxm_field
	this.SetOxmLength(uint8(32))    // oxm_length
}

func (this OxmIpV6DstMasked) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmIpV6DstMasked(p OxmField) (OxmIpV6DstMasked, error) {
	if !IsOxmIpV6DstMasked(p) {
		return NewOxmIpV6DstMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmIpV6DstMasked")
	}

	return NewOxmIpV6DstMaskedWithBuf(p.Buf), nil
}

func IsOxmIpV6DstMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 55 && p.OxmLength() == 32 && true
}

func (this OxmIpV6DstMasked) Addr() [16]uint8 {
	offset := this.AddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV6DstMasked) SetAddr(a [16]uint8) {
	offset := this.AddrOffset()
	for _, e := range a {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV6DstMasked) AddrOffset() int {
	offset := 4
	return offset
}

func (this OxmIpV6DstMasked) Mask() [16]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmIpV6DstMasked) SetMask(m [16]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this OxmIpV6DstMasked) MaskOffset() int {
	offset := 20
	return offset
}

func NewOxmTcpSrcWithBuf(b []byte) OxmTcpSrc {
	return OxmTcpSrc{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmTcpSrc() OxmTcpSrc {
	s := packet.PaddedSize(6, 1, 4)
	b := make([]byte, s)
	p := OxmTcpSrc{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmTcpSrc struct {
	OxmField
}

func (this OxmTcpSrc) minSize() int {
	return 6
}

func (this OxmTcpSrc) Clone() (OxmTcpSrc, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmTcpSrc(), err
	}

	return NewOxmTcpSrcWithBuf(newBuf.Bytes()), nil
}

type OxmTcpSrcConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmTcpSrcConn(c net.Conn) OxmTcpSrcConn {
	return OxmTcpSrcConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmTcpSrcConn) WriteOxmTcpSrc(pkt OxmTcpSrc) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmTcpSrcConn) WriteOxmTcpSrcs(pkts []OxmTcpSrc) error {
	for _, p := range pkts {
		if err := c.WriteOxmTcpSrc(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmTcpSrcConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmTcpSrcConn) ReadOxmTcpSrc() (OxmTcpSrc, error) {
	pkts := make([]OxmTcpSrc, 1)
	_, err := c.ReadOxmTcpSrcs(pkts)
	if err != nil {
		return NewOxmTcpSrc(), err
	}

	return pkts[0], nil
}

func (c *OxmTcpSrcConn) ReadOxmTcpSrcs(pkts []OxmTcpSrc) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmTcpSrcWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmTcpSrc) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(26))     // oxm_field
	this.SetOxmLength(uint8(2))     // oxm_length
}

func (this OxmTcpSrc) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmTcpSrc(p OxmField) (OxmTcpSrc, error) {
	if !IsOxmTcpSrc(p) {
		return NewOxmTcpSrcWithBuf(nil), errors.New("Cannot convert to of12.OxmTcpSrc")
	}

	return NewOxmTcpSrcWithBuf(p.Buf), nil
}

func IsOxmTcpSrc(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 26 && p.OxmLength() == 2 && true
}

func (this OxmTcpSrc) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *OxmTcpSrc) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this OxmTcpSrc) PortOffset() int {
	offset := 4
	return offset
}

func NewOxmTcpDstWithBuf(b []byte) OxmTcpDst {
	return OxmTcpDst{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmTcpDst() OxmTcpDst {
	s := packet.PaddedSize(6, 1, 4)
	b := make([]byte, s)
	p := OxmTcpDst{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmTcpDst struct {
	OxmField
}

func (this OxmTcpDst) minSize() int {
	return 6
}

func (this OxmTcpDst) Clone() (OxmTcpDst, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmTcpDst(), err
	}

	return NewOxmTcpDstWithBuf(newBuf.Bytes()), nil
}

type OxmTcpDstConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOxmTcpDstConn(c net.Conn) OxmTcpDstConn {
	return OxmTcpDstConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmTcpDstConn) WriteOxmTcpDst(pkt OxmTcpDst) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmTcpDstConn) WriteOxmTcpDsts(pkts []OxmTcpDst) error {
	for _, p := range pkts {
		if err := c.WriteOxmTcpDst(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmTcpDstConn) Flush() error {
	return c.w.Flush()
}

func (c *OxmTcpDstConn) ReadOxmTcpDst() (OxmTcpDst, error) {
	pkts := make([]OxmTcpDst, 1)
	_, err := c.ReadOxmTcpDsts(pkts)
	if err != nil {
		return NewOxmTcpDst(), err
	}

	return pkts[0], nil
}

func (c *OxmTcpDstConn) ReadOxmTcpDsts(pkts []OxmTcpDst) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmTcpDstWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmTcpDst) Init() {
	this.OxmField.Init()
	this.SetOxmLength(uint8(this.minSize()))
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(28))     // oxm_field
	this.SetOxmLength(uint8(2))     // oxm_length
}

func (this OxmTcpDst) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.OxmLength())
	return packet.PaddedSize(size, 1, 4)
}

func ToOxmTcpDst(p OxmField) (OxmTcpDst, error) {
	if !IsOxmTcpDst(p) {
		return NewOxmTcpDstWithBuf(nil), errors.New("Cannot convert to of12.OxmTcpDst")
	}

	return NewOxmTcpDstWithBuf(p.Buf), nil
}

func IsOxmTcpDst(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 28 && p.OxmLength() == 2 && true
}

func (this OxmTcpDst) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *OxmTcpDst) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this OxmTcpDst) PortOffset() int {
	offset := 4
	return offset
}

func NewMatchWithBuf(b []byte) Match {
	return Match{packet.Packet{Buf: b}}
}

func NewMatch() Match {
	s := packet.PaddedSize(4, 8, 0)
	b := make([]byte, s)
	p := Match{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Match struct {
	packet.Packet
}

func (this Match) minSize() int {
	return 4
}

func (this Match) Clone() (Match, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewMatch(), err
	}

	return NewMatchWithBuf(newBuf.Bytes()), nil
}

type MatchConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewMatchConn(c net.Conn) MatchConn {
	return MatchConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *MatchConn) WriteMatch(pkt Match) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *MatchConn) WriteMatchs(pkts []Match) error {
	for _, p := range pkts {
		if err := c.WriteMatch(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *MatchConn) Flush() error {
	return c.w.Flush()
}

func (c *MatchConn) ReadMatch() (Match, error) {
	pkts := make([]Match, 1)
	_, err := c.ReadMatchs(pkts)
	if err != nil {
		return NewMatch(), err
	}

	return pkts[0], nil
}

func (c *MatchConn) ReadMatchs(pkts []Match) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewMatchWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Match) Init() {
	this.SetLength(uint16(this.minSize()))
	// Invariants.
}

func (this Match) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return packet.PaddedSize(size, 8, 0)
}

func ToMatch(p packet.Packet) (Match, error) {
	if !IsMatch(p) {
		return NewMatchWithBuf(nil), errors.New("Cannot convert to of12.Match")
	}

	return NewMatchWithBuf(p.Buf), nil
}

func IsMatch(p packet.Packet) bool {
	return true
}

func (this Match) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this Match) TypeOffset() int {
	offset := 0
	return offset
}

func (this Match) Length() uint16 {
	offset := this.LengthOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetLength(l uint16) {
	offset := this.LengthOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this Match) LengthOffset() int {
	offset := 2
	return offset
}

func NewStdMatchWithBuf(b []byte) StdMatch {
	return StdMatch{Match{packet.Packet{Buf: b}}}
}

func NewStdMatch() StdMatch {
	s := packet.PaddedSize(88, 8, 0)
	b := make([]byte, s)
	p := StdMatch{Match{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type StdMatch struct {
	Match
}

func (this StdMatch) minSize() int {
	return 88
}

func (this StdMatch) Clone() (StdMatch, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStdMatch(), err
	}

	return NewStdMatchWithBuf(newBuf.Bytes()), nil
}

type StdMatchConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewStdMatchConn(c net.Conn) StdMatchConn {
	return StdMatchConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StdMatchConn) WriteStdMatch(pkt StdMatch) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *StdMatchConn) WriteStdMatchs(pkts []StdMatch) error {
	for _, p := range pkts {
		if err := c.WriteStdMatch(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *StdMatchConn) Flush() error {
	return c.w.Flush()
}

func (c *StdMatchConn) ReadStdMatch() (StdMatch, error) {
	pkts := make([]StdMatch, 1)
	_, err := c.ReadStdMatchs(pkts)
	if err != nil {
		return NewStdMatch(), err
	}

	return pkts[0], nil
}

func (c *StdMatchConn) ReadStdMatchs(pkts []StdMatch) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStdMatchWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *StdMatch) Init() {
	this.Match.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(0)) // type
}

func (this StdMatch) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return packet.PaddedSize(size, 8, 0)
}

func ToStdMatch(p Match) (StdMatch, error) {
	if !IsStdMatch(p) {
		return NewStdMatchWithBuf(nil), errors.New("Cannot convert to of12.StdMatch")
	}

	return NewStdMatchWithBuf(p.Buf), nil
}

func IsStdMatch(p Match) bool {
	return p.Type() == 0 && true
}

func (this StdMatch) InPort() uint32 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetInPort(i uint32) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], i)
	offset += 4
}

func (this StdMatch) InPortOffset() int {
	offset := 4
	return offset
}

func (this StdMatch) Wildcards() uint32 {
	offset := this.WildcardsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetWildcards(w uint32) {
	offset := this.WildcardsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], w)
	offset += 4
}

func (this StdMatch) WildcardsOffset() int {
	offset := 8
	return offset
}

func (this StdMatch) DlSrc() [6]uint8 {
	offset := this.DlSrcOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StdMatch) SetDlSrc(d [6]uint8) {
	offset := this.DlSrcOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StdMatch) DlSrcOffset() int {
	offset := 12
	return offset
}

func (this StdMatch) DlSrcMask() [6]uint8 {
	offset := this.DlSrcMaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StdMatch) SetDlSrcMask(d [6]uint8) {
	offset := this.DlSrcMaskOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StdMatch) DlSrcMaskOffset() int {
	offset := 18
	return offset
}

func (this StdMatch) DlDst() [6]uint8 {
	offset := this.DlDstOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StdMatch) SetDlDst(d [6]uint8) {
	offset := this.DlDstOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StdMatch) DlDstOffset() int {
	offset := 24
	return offset
}

func (this StdMatch) DlDstMask() [6]uint8 {
	offset := this.DlDstMaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StdMatch) SetDlDstMask(d [6]uint8) {
	offset := this.DlDstMaskOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StdMatch) DlDstMaskOffset() int {
	offset := 30
	return offset
}

func (this StdMatch) DlVlan() uint16 {
	offset := this.DlVlanOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetDlVlan(d uint16) {
	offset := this.DlVlanOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], d)
	offset += 2
}

func (this StdMatch) DlVlanOffset() int {
	offset := 36
	return offset
}

func (this StdMatch) DlVlanPcp() uint8 {
	offset := this.DlVlanPcpOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *StdMatch) SetDlVlanPcp(d uint8) {
	offset := this.DlVlanPcpOffset()
	this.Buf[offset] = byte(d)
	offset++
}

func (this StdMatch) DlVlanPcpOffset() int {
	offset := 38
	return offset
}

func (this StdMatch) Pad1() uint8 {
	offset := this.Pad1Offset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *StdMatch) SetPad1(p uint8) {
	offset := this.Pad1Offset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this StdMatch) Pad1Offset() int {
	offset := 39
	return offset
}

func (this StdMatch) DlType() uint16 {
	offset := this.DlTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetDlType(d uint16) {
	offset := this.DlTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], d)
	offset += 2
}

func (this StdMatch) DlTypeOffset() int {
	offset := 40
	return offset
}

func (this StdMatch) NwTos() uint8 {
	offset := this.NwTosOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *StdMatch) SetNwTos(n uint8) {
	offset := this.NwTosOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this StdMatch) NwTosOffset() int {
	offset := 42
	return offset
}

func (this StdMatch) NwProto() uint8 {
	offset := this.NwProtoOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *StdMatch) SetNwProto(n uint8) {
	offset := this.NwProtoOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this StdMatch) NwProtoOffset() int {
	offset := 43
	return offset
}

func (this StdMatch) NwSrc() uint32 {
	offset := this.NwSrcOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetNwSrc(n uint32) {
	offset := this.NwSrcOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this StdMatch) NwSrcOffset() int {
	offset := 44
	return offset
}

func (this StdMatch) NwSrcMask() uint32 {
	offset := this.NwSrcMaskOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetNwSrcMask(n uint32) {
	offset := this.NwSrcMaskOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this StdMatch) NwSrcMaskOffset() int {
	offset := 48
	return offset
}

func (this StdMatch) NwDst() uint32 {
	offset := this.NwDstOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetNwDst(n uint32) {
	offset := this.NwDstOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this StdMatch) NwDstOffset() int {
	offset := 52
	return offset
}

func (this StdMatch) NwDstMask() uint32 {
	offset := this.NwDstMaskOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetNwDstMask(n uint32) {
	offset := this.NwDstMaskOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this StdMatch) NwDstMaskOffset() int {
	offset := 56
	return offset
}

func (this StdMatch) TpSrc() uint16 {
	offset := this.TpSrcOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetTpSrc(t uint16) {
	offset := this.TpSrcOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this StdMatch) TpSrcOffset() int {
	offset := 60
	return offset
}

func (this StdMatch) TpDst() uint16 {
	offset := this.TpDstOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetTpDst(t uint16) {
	offset := this.TpDstOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this StdMatch) TpDstOffset() int {
	offset := 62
	return offset
}

func (this StdMatch) MplsLabel() uint32 {
	offset := this.MplsLabelOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetMplsLabel(m uint32) {
	offset := this.MplsLabelOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this StdMatch) MplsLabelOffset() int {
	offset := 64
	return offset
}

func (this StdMatch) MplsTc() uint8 {
	offset := this.MplsTcOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *StdMatch) SetMplsTc(m uint8) {
	offset := this.MplsTcOffset()
	this.Buf[offset] = byte(m)
	offset++
}

func (this StdMatch) MplsTcOffset() int {
	offset := 68
	return offset
}

func (this StdMatch) Pad2() [3]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StdMatch) SetPad2(p [3]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StdMatch) Pad2Offset() int {
	offset := 69
	return offset
}

func (this StdMatch) Metadata() uint64 {
	offset := this.MetadataOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetMetadata(m uint64) {
	offset := this.MetadataOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], m)
	offset += 8
}

func (this StdMatch) MetadataOffset() int {
	offset := 72
	return offset
}

func (this StdMatch) MetadataMask() uint64 {
	offset := this.MetadataMaskOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *StdMatch) SetMetadataMask(m uint64) {
	offset := this.MetadataMaskOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], m)
	offset += 8
}

func (this StdMatch) MetadataMaskOffset() int {
	offset := 80
	return offset
}

func NewOXMatchWithBuf(b []byte) OXMatch {
	return OXMatch{Match{packet.Packet{Buf: b}}}
}

func NewOXMatch() OXMatch {
	s := packet.PaddedSize(4, 8, 0)
	b := make([]byte, s)
	p := OXMatch{Match{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OXMatch struct {
	Match
}

func (this OXMatch) minSize() int {
	return 4
}

func (this OXMatch) Clone() (OXMatch, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOXMatch(), err
	}

	return NewOXMatchWithBuf(newBuf.Bytes()), nil
}

type OXMatchConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewOXMatchConn(c net.Conn) OXMatchConn {
	return OXMatchConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OXMatchConn) WriteOXMatch(pkt OXMatch) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OXMatchConn) WriteOXMatchs(pkts []OXMatch) error {
	for _, p := range pkts {
		if err := c.WriteOXMatch(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OXMatchConn) Flush() error {
	return c.w.Flush()
}

func (c *OXMatchConn) ReadOXMatch() (OXMatch, error) {
	pkts := make([]OXMatch, 1)
	_, err := c.ReadOXMatchs(pkts)
	if err != nil {
		return NewOXMatch(), err
	}

	return pkts[0], nil
}

func (c *OXMatchConn) ReadOXMatchs(pkts []OXMatch) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOXMatchWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OXMatch) Init() {
	this.Match.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(1)) // type
}

func (this OXMatch) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return packet.PaddedSize(size, 8, 0)
}

func ToOXMatch(p Match) (OXMatch, error) {
	if !IsOXMatch(p) {
		return NewOXMatchWithBuf(nil), errors.New("Cannot convert to of12.OXMatch")
	}

	return NewOXMatchWithBuf(p.Buf), nil
}

func IsOXMatch(p Match) bool {
	return p.Type() == 1 && true
}

func (this OXMatch) Fields() []OxmField {
	offset := this.FieldsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []OxmField
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewOxmFieldWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *OXMatch) AddFields(f OxmField) {
	offset := this.FieldsOffset()
	offset += this.FieldsSize()
	size := f.Size()
	pSize := int(this.Length())
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	this.OpenGap(size+pSize, this.Size()-pSize, size+pSize)
	copy(this.Buf[offset:], f.Buf[:size])
	offset += size
}

func (this OXMatch) FieldsOffset() int {
	offset := 4
	return offset
}

func (this OXMatch) FieldsSize() int {
	offset := this.FieldsOffset()
	size := int(this.Length())
	return size - offset
}

func NewPacketInWithBuf(b []byte) PacketIn {
	return PacketIn{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPacketIn() PacketIn {
	s := 18
	b := make([]byte, s)
	p := PacketIn{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PacketIn struct {
	Header12
}

func (this PacketIn) minSize() int {
	return 18
}

func (this PacketIn) Clone() (PacketIn, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketIn(), err
	}

	return NewPacketInWithBuf(newBuf.Bytes()), nil
}

type PacketInConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPacketInConn(c net.Conn) PacketInConn {
	return PacketInConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketInConn) WritePacketIn(pkt PacketIn) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PacketInConn) WritePacketIns(pkts []PacketIn) error {
	for _, p := range pkts {
		if err := c.WritePacketIn(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PacketInConn) Flush() error {
	return c.w.Flush()
}

func (c *PacketInConn) ReadPacketIn() (PacketIn, error) {
	pkts := make([]PacketIn, 1)
	_, err := c.ReadPacketIns(pkts)
	if err != nil {
		return NewPacketIn(), err
	}

	return pkts[0], nil
}

func (c *PacketInConn) ReadPacketIns(pkts []PacketIn) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketInWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PacketIn) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(10))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PacketIn) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPacketIn(p Header12) (PacketIn, error) {
	if !IsPacketIn(p) {
		return NewPacketInWithBuf(nil), errors.New("Cannot convert to of12.PacketIn")
	}

	return NewPacketInWithBuf(p.Buf), nil
}

func IsPacketIn(p Header12) bool {
	return p.Type() == 10 && true
}

func (this PacketIn) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this PacketIn) BufferIdOffset() int {
	offset := 8
	return offset
}

func (this PacketIn) TotalLen() uint16 {
	offset := this.TotalLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetTotalLen(t uint16) {
	offset := this.TotalLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this PacketIn) TotalLenOffset() int {
	offset := 12
	return offset
}

func (this PacketIn) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PacketIn) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this PacketIn) ReasonOffset() int {
	offset := 14
	return offset
}

func (this PacketIn) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PacketIn) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this PacketIn) TableIdOffset() int {
	offset := 15
	return offset
}

func (this PacketIn) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this PacketIn) MatchOffset() int {
	offset := 16
	return offset
}

func (this PacketIn) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this PacketIn) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PacketIn) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PacketIn) PadOffset() int {
	offset := 16
	offset += this.MatchSize()
	return offset
}

func (this PacketIn) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	return []uint8(this.Buf[offset : offset+size])
}

func (this *PacketIn) AddData(d uint8) {
	offset := this.DataOffset()
	offset += this.DataSize()
	size := 1
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this PacketIn) DataOffset() int {
	offset := 18
	offset += this.MatchSize()
	return offset
}

func (this PacketIn) DataSize() int {
	offset := this.DataOffset()
	size := this.Size()
	return size - offset
}

func NewFlowModWithBuf(b []byte) FlowMod {
	return FlowMod{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFlowMod() FlowMod {
	s := 48
	b := make([]byte, s)
	p := FlowMod{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FlowMod struct {
	Header12
}

func (this FlowMod) minSize() int {
	return 48
}

func (this FlowMod) Clone() (FlowMod, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowMod(), err
	}

	return NewFlowModWithBuf(newBuf.Bytes()), nil
}

type FlowModConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFlowModConn(c net.Conn) FlowModConn {
	return FlowModConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowModConn) WriteFlowMod(pkt FlowMod) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowModConn) WriteFlowMods(pkts []FlowMod) error {
	for _, p := range pkts {
		if err := c.WriteFlowMod(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowModConn) Flush() error {
	return c.w.Flush()
}

func (c *FlowModConn) ReadFlowMod() (FlowMod, error) {
	pkts := make([]FlowMod, 1)
	_, err := c.ReadFlowMods(pkts)
	if err != nil {
		return NewFlowMod(), err
	}

	return pkts[0], nil
}

func (c *FlowModConn) ReadFlowMods(pkts []FlowMod) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowModWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowMod) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(14))   // type
	this.SetVersion(uint8(3)) // version
}

func (this FlowMod) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowMod(p Header12) (FlowMod, error) {
	if !IsFlowMod(p) {
		return NewFlowModWithBuf(nil), errors.New("Cannot convert to of12.FlowMod")
	}

	return NewFlowModWithBuf(p.Buf), nil
}

func IsFlowMod(p Header12) bool {
	return p.Type() == 14 && true
}

func (this FlowMod) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this FlowMod) CookieOffset() int {
	offset := 8
	return offset
}

func (this FlowMod) CookieMask() uint64 {
	offset := this.CookieMaskOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetCookieMask(c uint64) {
	offset := this.CookieMaskOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this FlowMod) CookieMaskOffset() int {
	offset := 16
	return offset
}

func (this FlowMod) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowMod) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this FlowMod) TableIdOffset() int {
	offset := 24
	return offset
}

func (this FlowMod) Command() uint8 {
	offset := this.CommandOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowMod) SetCommand(c uint8) {
	offset := this.CommandOffset()
	this.Buf[offset] = byte(c)
	offset++
}

func (this FlowMod) CommandOffset() int {
	offset := 25
	return offset
}

func (this FlowMod) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this FlowMod) IdleTimeoutOffset() int {
	offset := 26
	return offset
}

func (this FlowMod) HardTimeout() uint16 {
	offset := this.HardTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetHardTimeout(h uint16) {
	offset := this.HardTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], h)
	offset += 2
}

func (this FlowMod) HardTimeoutOffset() int {
	offset := 28
	return offset
}

func (this FlowMod) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this FlowMod) PriorityOffset() int {
	offset := 30
	return offset
}

func (this FlowMod) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this FlowMod) BufferIdOffset() int {
	offset := 32
	return offset
}

func (this FlowMod) OutPort() uint32 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetOutPort(o uint32) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], o)
	offset += 4
}

func (this FlowMod) OutPortOffset() int {
	offset := 36
	return offset
}

func (this FlowMod) OutGroup() uint32 {
	offset := this.OutGroupOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetOutGroup(o uint32) {
	offset := this.OutGroupOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], o)
	offset += 4
}

func (this FlowMod) OutGroupOffset() int {
	offset := 40
	return offset
}

func (this FlowMod) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this FlowMod) FlagsOffset() int {
	offset := 44
	return offset
}

func (this FlowMod) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowMod) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FlowMod) PadOffset() int {
	offset := 46
	return offset
}

func (this FlowMod) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this FlowMod) MatchOffset() int {
	offset := 48
	return offset
}

func (this FlowMod) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this FlowMod) Instructions() []Instruction {
	offset := this.InstructionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Instruction
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewInstructionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowMod) AddInstructions(i Instruction) {
	offset := this.InstructionsOffset()
	offset += this.InstructionsSize()
	size := i.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], i.Buf[:size])
	offset += size
}

func (this FlowMod) InstructionsOffset() int {
	offset := 48
	offset += this.MatchSize()
	return offset
}

func (this FlowMod) InstructionsSize() int {
	offset := this.InstructionsOffset()
	size := this.Size()
	return size - offset
}

func NewFlowRemovedWithBuf(b []byte) FlowRemoved {
	return FlowRemoved{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFlowRemoved() FlowRemoved {
	s := 48
	b := make([]byte, s)
	p := FlowRemoved{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FlowRemoved struct {
	Header12
}

func (this FlowRemoved) minSize() int {
	return 48
}

func (this FlowRemoved) Clone() (FlowRemoved, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowRemoved(), err
	}

	return NewFlowRemovedWithBuf(newBuf.Bytes()), nil
}

type FlowRemovedConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFlowRemovedConn(c net.Conn) FlowRemovedConn {
	return FlowRemovedConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowRemovedConn) WriteFlowRemoved(pkt FlowRemoved) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowRemovedConn) WriteFlowRemoveds(pkts []FlowRemoved) error {
	for _, p := range pkts {
		if err := c.WriteFlowRemoved(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowRemovedConn) Flush() error {
	return c.w.Flush()
}

func (c *FlowRemovedConn) ReadFlowRemoved() (FlowRemoved, error) {
	pkts := make([]FlowRemoved, 1)
	_, err := c.ReadFlowRemoveds(pkts)
	if err != nil {
		return NewFlowRemoved(), err
	}

	return pkts[0], nil
}

func (c *FlowRemovedConn) ReadFlowRemoveds(pkts []FlowRemoved) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowRemovedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowRemoved) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(11))   // type
	this.SetVersion(uint8(3)) // version
}

func (this FlowRemoved) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowRemoved(p Header12) (FlowRemoved, error) {
	if !IsFlowRemoved(p) {
		return NewFlowRemovedWithBuf(nil), errors.New("Cannot convert to of12.FlowRemoved")
	}

	return NewFlowRemovedWithBuf(p.Buf), nil
}

func IsFlowRemoved(p Header12) bool {
	return p.Type() == 11 && true
}

func (this FlowRemoved) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this FlowRemoved) MatchOffset() int {
	offset := 8
	return offset
}

func (this FlowRemoved) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this FlowRemoved) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this FlowRemoved) CookieOffset() int {
	offset := 8
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this FlowRemoved) PriorityOffset() int {
	offset := 16
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowRemoved) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this FlowRemoved) ReasonOffset() int {
	offset := 18
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) Pad() [1]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 1
	i := 0
	var res [1]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowRemoved) SetPad(p [1]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FlowRemoved) PadOffset() int {
	offset := 19
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) DurationSec() uint32 {
	offset := this.DurationSecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetDurationSec(d uint32) {
	offset := this.DurationSecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this FlowRemoved) DurationSecOffset() int {
	offset := 20
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) DurationNsec() uint32 {
	offset := this.DurationNsecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetDurationNsec(d uint32) {
	offset := this.DurationNsecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this FlowRemoved) DurationNsecOffset() int {
	offset := 24
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this FlowRemoved) IdleTimeoutOffset() int {
	offset := 28
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) Pad2() [2]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowRemoved) SetPad2(p [2]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FlowRemoved) Pad2Offset() int {
	offset := 30
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this FlowRemoved) PacketCountOffset() int {
	offset := 32
	offset += this.MatchSize()
	return offset
}

func (this FlowRemoved) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this FlowRemoved) ByteCountOffset() int {
	offset := 40
	offset += this.MatchSize()
	return offset
}

func NewErrorMsgWithBuf(b []byte) ErrorMsg {
	return ErrorMsg{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewErrorMsg() ErrorMsg {
	s := 12
	b := make([]byte, s)
	p := ErrorMsg{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type ErrorMsg struct {
	Header12
}

func (this ErrorMsg) minSize() int {
	return 12
}

func (this ErrorMsg) Clone() (ErrorMsg, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewErrorMsg(), err
	}

	return NewErrorMsgWithBuf(newBuf.Bytes()), nil
}

type ErrorMsgConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewErrorMsgConn(c net.Conn) ErrorMsgConn {
	return ErrorMsgConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ErrorMsgConn) WriteErrorMsg(pkt ErrorMsg) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ErrorMsgConn) WriteErrorMsgs(pkts []ErrorMsg) error {
	for _, p := range pkts {
		if err := c.WriteErrorMsg(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ErrorMsgConn) Flush() error {
	return c.w.Flush()
}

func (c *ErrorMsgConn) ReadErrorMsg() (ErrorMsg, error) {
	pkts := make([]ErrorMsg, 1)
	_, err := c.ReadErrorMsgs(pkts)
	if err != nil {
		return NewErrorMsg(), err
	}

	return pkts[0], nil
}

func (c *ErrorMsgConn) ReadErrorMsgs(pkts []ErrorMsg) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewErrorMsgWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ErrorMsg) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(1))    // type
	this.SetVersion(uint8(3)) // version
}

func (this ErrorMsg) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToErrorMsg(p Header12) (ErrorMsg, error) {
	if !IsErrorMsg(p) {
		return NewErrorMsgWithBuf(nil), errors.New("Cannot convert to of12.ErrorMsg")
	}

	return NewErrorMsgWithBuf(p.Buf), nil
}

func IsErrorMsg(p Header12) bool {
	return p.Type() == 1 && true
}

func (this ErrorMsg) ErrType() uint16 {
	offset := this.ErrTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ErrorMsg) SetErrType(e uint16) {
	offset := this.ErrTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], e)
	offset += 2
}

func (this ErrorMsg) ErrTypeOffset() int {
	offset := 8
	return offset
}

func (this ErrorMsg) Code() uint16 {
	offset := this.CodeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ErrorMsg) SetCode(c uint16) {
	offset := this.CodeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], c)
	offset += 2
}

func (this ErrorMsg) CodeOffset() int {
	offset := 10
	return offset
}

func (this ErrorMsg) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	return []uint8(this.Buf[offset : offset+size])
}

func (this *ErrorMsg) AddData(d uint8) {
	offset := this.DataOffset()
	offset += this.DataSize()
	size := 1
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this ErrorMsg) DataOffset() int {
	offset := 12
	return offset
}

func (this ErrorMsg) DataSize() int {
	offset := this.DataOffset()
	size := this.Size()
	return size - offset
}

func NewStatsRequestWithBuf(b []byte) StatsRequest {
	return StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewStatsRequest() StatsRequest {
	s := 16
	b := make([]byte, s)
	p := StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type StatsRequest struct {
	Header12
}

func (this StatsRequest) minSize() int {
	return 16
}

func (this StatsRequest) Clone() (StatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStatsRequest(), err
	}

	return NewStatsRequestWithBuf(newBuf.Bytes()), nil
}

type StatsRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewStatsRequestConn(c net.Conn) StatsRequestConn {
	return StatsRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StatsRequestConn) WriteStatsRequest(pkt StatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *StatsRequestConn) WriteStatsRequests(pkts []StatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *StatsRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *StatsRequestConn) ReadStatsRequest() (StatsRequest, error) {
	pkts := make([]StatsRequest, 1)
	_, err := c.ReadStatsRequests(pkts)
	if err != nil {
		return NewStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *StatsRequestConn) ReadStatsRequests(pkts []StatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *StatsRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(18))   // type
	this.SetVersion(uint8(3)) // version
}

func (this StatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToStatsRequest(p Header12) (StatsRequest, error) {
	if !IsStatsRequest(p) {
		return NewStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.StatsRequest")
	}

	return NewStatsRequestWithBuf(p.Buf), nil
}

func IsStatsRequest(p Header12) bool {
	return p.Type() == 18 && true
}

func (this StatsRequest) StatsType() uint16 {
	offset := this.StatsTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsRequest) SetStatsType(s uint16) {
	offset := this.StatsTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], s)
	offset += 2
}

func (this StatsRequest) StatsTypeOffset() int {
	offset := 8
	return offset
}

func (this StatsRequest) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsRequest) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this StatsRequest) FlagsOffset() int {
	offset := 10
	return offset
}

func (this StatsRequest) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StatsRequest) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StatsRequest) PadOffset() int {
	offset := 12
	return offset
}

func NewStatsReplyWithBuf(b []byte) StatsReply {
	return StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewStatsReply() StatsReply {
	s := 16
	b := make([]byte, s)
	p := StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type StatsReply struct {
	Header12
}

func (this StatsReply) minSize() int {
	return 16
}

func (this StatsReply) Clone() (StatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStatsReply(), err
	}

	return NewStatsReplyWithBuf(newBuf.Bytes()), nil
}

type StatsReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewStatsReplyConn(c net.Conn) StatsReplyConn {
	return StatsReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StatsReplyConn) WriteStatsReply(pkt StatsReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *StatsReplyConn) WriteStatsReplys(pkts []StatsReply) error {
	for _, p := range pkts {
		if err := c.WriteStatsReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *StatsReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *StatsReplyConn) ReadStatsReply() (StatsReply, error) {
	pkts := make([]StatsReply, 1)
	_, err := c.ReadStatsReplys(pkts)
	if err != nil {
		return NewStatsReply(), err
	}

	return pkts[0], nil
}

func (c *StatsReplyConn) ReadStatsReplys(pkts []StatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStatsReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *StatsReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(19))   // type
	this.SetVersion(uint8(3)) // version
}

func (this StatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToStatsReply(p Header12) (StatsReply, error) {
	if !IsStatsReply(p) {
		return NewStatsReplyWithBuf(nil), errors.New("Cannot convert to of12.StatsReply")
	}

	return NewStatsReplyWithBuf(p.Buf), nil
}

func IsStatsReply(p Header12) bool {
	return p.Type() == 19 && true
}

func (this StatsReply) StatsType() uint16 {
	offset := this.StatsTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsReply) SetStatsType(s uint16) {
	offset := this.StatsTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], s)
	offset += 2
}

func (this StatsReply) StatsTypeOffset() int {
	offset := 8
	return offset
}

func (this StatsReply) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsReply) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this StatsReply) FlagsOffset() int {
	offset := 10
	return offset
}

func (this StatsReply) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *StatsReply) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this StatsReply) PadOffset() int {
	offset := 12
	return offset
}

func NewDescStatsWithBuf(b []byte) DescStats {
	return DescStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewDescStats() DescStats {
	s := 1072
	b := make([]byte, s)
	p := DescStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type DescStats struct {
	StatsReply
}

func (this DescStats) minSize() int {
	return 1072
}

func (this DescStats) Clone() (DescStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewDescStats(), err
	}

	return NewDescStatsWithBuf(newBuf.Bytes()), nil
}

type DescStatsConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewDescStatsConn(c net.Conn) DescStatsConn {
	return DescStatsConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *DescStatsConn) WriteDescStats(pkt DescStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *DescStatsConn) WriteDescStatss(pkts []DescStats) error {
	for _, p := range pkts {
		if err := c.WriteDescStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *DescStatsConn) Flush() error {
	return c.w.Flush()
}

func (c *DescStatsConn) ReadDescStats() (DescStats, error) {
	pkts := make([]DescStats, 1)
	_, err := c.ReadDescStatss(pkts)
	if err != nil {
		return NewDescStats(), err
	}

	return pkts[0], nil
}

func (c *DescStatsConn) ReadDescStatss(pkts []DescStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewDescStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *DescStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(0)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this DescStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToDescStats(p StatsReply) (DescStats, error) {
	if !IsDescStats(p) {
		return NewDescStatsWithBuf(nil), errors.New("Cannot convert to of12.DescStats")
	}

	return NewDescStatsWithBuf(p.Buf), nil
}

func IsDescStats(p StatsReply) bool {
	return p.StatsType() == 0 && true
}

func (this DescStats) MfrDesc() [256]byte {
	offset := this.MfrDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetMfrDesc(m [256]byte) {
	offset := this.MfrDescOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this DescStats) MfrDescOffset() int {
	offset := 16
	return offset
}

func (this DescStats) HwDesc() [256]byte {
	offset := this.HwDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetHwDesc(h [256]byte) {
	offset := this.HwDescOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this DescStats) HwDescOffset() int {
	offset := 272
	return offset
}

func (this DescStats) SwDesc() [256]byte {
	offset := this.SwDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetSwDesc(s [256]byte) {
	offset := this.SwDescOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this DescStats) SwDescOffset() int {
	offset := 528
	return offset
}

func (this DescStats) SerialNum() [32]byte {
	offset := this.SerialNumOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 32
	i := 0
	var res [32]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetSerialNum(s [32]byte) {
	offset := this.SerialNumOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this DescStats) SerialNumOffset() int {
	offset := 784
	return offset
}

func (this DescStats) DpDesc() [256]byte {
	offset := this.DpDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetDpDesc(d [256]byte) {
	offset := this.DpDescOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this DescStats) DpDescOffset() int {
	offset := 816
	return offset
}

func NewFlowStatsRequestWithBuf(b []byte) FlowStatsRequest {
	return FlowStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewFlowStatsRequest() FlowStatsRequest {
	s := 48
	b := make([]byte, s)
	p := FlowStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type FlowStatsRequest struct {
	StatsRequest
}

func (this FlowStatsRequest) minSize() int {
	return 48
}

func (this FlowStatsRequest) Clone() (FlowStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStatsRequest(), err
	}

	return NewFlowStatsRequestWithBuf(newBuf.Bytes()), nil
}

type FlowStatsRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFlowStatsRequestConn(c net.Conn) FlowStatsRequestConn {
	return FlowStatsRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsRequestConn) WriteFlowStatsRequest(pkt FlowStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowStatsRequestConn) WriteFlowStatsRequests(pkts []FlowStatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteFlowStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowStatsRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *FlowStatsRequestConn) ReadFlowStatsRequest() (FlowStatsRequest, error) {
	pkts := make([]FlowStatsRequest, 1)
	_, err := c.ReadFlowStatsRequests(pkts)
	if err != nil {
		return NewFlowStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *FlowStatsRequestConn) ReadFlowStatsRequests(pkts []FlowStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(1)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this FlowStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStatsRequest(p StatsRequest) (FlowStatsRequest, error) {
	if !IsFlowStatsRequest(p) {
		return NewFlowStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.FlowStatsRequest")
	}

	return NewFlowStatsRequestWithBuf(p.Buf), nil
}

func IsFlowStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 1 && true
}

func (this FlowStatsRequest) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStatsRequest) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this FlowStatsRequest) TableIdOffset() int {
	offset := 16
	return offset
}

func (this FlowStatsRequest) Pad1() [3]uint8 {
	offset := this.Pad1Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowStatsRequest) SetPad1(p [3]uint8) {
	offset := this.Pad1Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FlowStatsRequest) Pad1Offset() int {
	offset := 17
	return offset
}

func (this FlowStatsRequest) OutPort() uint32 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetOutPort(o uint32) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], o)
	offset += 4
}

func (this FlowStatsRequest) OutPortOffset() int {
	offset := 20
	return offset
}

func (this FlowStatsRequest) OutGroup() uint32 {
	offset := this.OutGroupOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetOutGroup(o uint32) {
	offset := this.OutGroupOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], o)
	offset += 4
}

func (this FlowStatsRequest) OutGroupOffset() int {
	offset := 24
	return offset
}

func (this FlowStatsRequest) Pad2() [4]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowStatsRequest) SetPad2(p [4]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FlowStatsRequest) Pad2Offset() int {
	offset := 28
	return offset
}

func (this FlowStatsRequest) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this FlowStatsRequest) CookieOffset() int {
	offset := 32
	return offset
}

func (this FlowStatsRequest) CookieMask() uint64 {
	offset := this.CookieMaskOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetCookieMask(c uint64) {
	offset := this.CookieMaskOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this FlowStatsRequest) CookieMaskOffset() int {
	offset := 40
	return offset
}

func (this FlowStatsRequest) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this FlowStatsRequest) MatchOffset() int {
	offset := 48
	return offset
}

func (this FlowStatsRequest) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func NewFlowStatsWithBuf(b []byte) FlowStats {
	return FlowStats{packet.Packet{Buf: b}}
}

func NewFlowStats() FlowStats {
	s := 48
	b := make([]byte, s)
	p := FlowStats{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type FlowStats struct {
	packet.Packet
}

func (this FlowStats) minSize() int {
	return 48
}

func (this FlowStats) Clone() (FlowStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStats(), err
	}

	return NewFlowStatsWithBuf(newBuf.Bytes()), nil
}

type FlowStatsConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFlowStatsConn(c net.Conn) FlowStatsConn {
	return FlowStatsConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsConn) WriteFlowStats(pkt FlowStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowStatsConn) WriteFlowStatss(pkts []FlowStats) error {
	for _, p := range pkts {
		if err := c.WriteFlowStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowStatsConn) Flush() error {
	return c.w.Flush()
}

func (c *FlowStatsConn) ReadFlowStats() (FlowStats, error) {
	pkts := make([]FlowStats, 1)
	_, err := c.ReadFlowStatss(pkts)
	if err != nil {
		return NewFlowStats(), err
	}

	return pkts[0], nil
}

func (c *FlowStatsConn) ReadFlowStatss(pkts []FlowStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowStats) Init() {
	this.SetLength(uint16(this.minSize()))
	// Invariants.
}

func (this FlowStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStats(p packet.Packet) (FlowStats, error) {
	if !IsFlowStats(p) {
		return NewFlowStatsWithBuf(nil), errors.New("Cannot convert to of12.FlowStats")
	}

	return NewFlowStatsWithBuf(p.Buf), nil
}

func IsFlowStats(p packet.Packet) bool {
	return true
}

func (this FlowStats) Length() uint16 {
	offset := this.LengthOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetLength(l uint16) {
	offset := this.LengthOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this FlowStats) LengthOffset() int {
	offset := 0
	return offset
}

func (this FlowStats) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStats) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this FlowStats) TableIdOffset() int {
	offset := 2
	return offset
}

func (this FlowStats) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStats) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this FlowStats) PadOffset() int {
	offset := 3
	return offset
}

func (this FlowStats) DurationSec() uint32 {
	offset := this.DurationSecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetDurationSec(d uint32) {
	offset := this.DurationSecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this FlowStats) DurationSecOffset() int {
	offset := 4
	return offset
}

func (this FlowStats) DurationNsec() uint32 {
	offset := this.DurationNsecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetDurationNsec(d uint32) {
	offset := this.DurationNsecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this FlowStats) DurationNsecOffset() int {
	offset := 8
	return offset
}

func (this FlowStats) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this FlowStats) PriorityOffset() int {
	offset := 12
	return offset
}

func (this FlowStats) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this FlowStats) IdleTimeoutOffset() int {
	offset := 14
	return offset
}

func (this FlowStats) HardTimeout() uint16 {
	offset := this.HardTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetHardTimeout(h uint16) {
	offset := this.HardTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], h)
	offset += 2
}

func (this FlowStats) HardTimeoutOffset() int {
	offset := 16
	return offset
}

func (this FlowStats) Pad2() [6]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowStats) SetPad2(p [6]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this FlowStats) Pad2Offset() int {
	offset := 18
	return offset
}

func (this FlowStats) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this FlowStats) CookieOffset() int {
	offset := 24
	return offset
}

func (this FlowStats) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this FlowStats) PacketCountOffset() int {
	offset := 32
	return offset
}

func (this FlowStats) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this FlowStats) ByteCountOffset() int {
	offset := 40
	return offset
}

func (this FlowStats) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this FlowStats) MatchOffset() int {
	offset := 48
	return offset
}

func (this FlowStats) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this FlowStats) Instructions() []Instruction {
	offset := this.InstructionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Instruction
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewInstructionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowStats) AddInstructions(i Instruction) {
	offset := this.InstructionsOffset()
	offset += this.InstructionsSize()
	size := i.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], i.Buf[:size])
	offset += size
}

func (this FlowStats) InstructionsOffset() int {
	offset := 48
	offset += this.MatchSize()
	return offset
}

func (this FlowStats) InstructionsSize() int {
	offset := this.InstructionsOffset()
	size := this.Size()
	return size - offset
}

func NewFlowStatsReplyWithBuf(b []byte) FlowStatsReply {
	return FlowStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewFlowStatsReply() FlowStatsReply {
	s := 16
	b := make([]byte, s)
	p := FlowStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type FlowStatsReply struct {
	StatsReply
}

func (this FlowStatsReply) minSize() int {
	return 16
}

func (this FlowStatsReply) Clone() (FlowStatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStatsReply(), err
	}

	return NewFlowStatsReplyWithBuf(newBuf.Bytes()), nil
}

type FlowStatsReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewFlowStatsReplyConn(c net.Conn) FlowStatsReplyConn {
	return FlowStatsReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsReplyConn) WriteFlowStatsReply(pkt FlowStatsReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowStatsReplyConn) WriteFlowStatsReplys(pkts []FlowStatsReply) error {
	for _, p := range pkts {
		if err := c.WriteFlowStatsReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowStatsReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *FlowStatsReplyConn) ReadFlowStatsReply() (FlowStatsReply, error) {
	pkts := make([]FlowStatsReply, 1)
	_, err := c.ReadFlowStatsReplys(pkts)
	if err != nil {
		return NewFlowStatsReply(), err
	}

	return pkts[0], nil
}

func (c *FlowStatsReplyConn) ReadFlowStatsReplys(pkts []FlowStatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowStatsReply) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(1)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this FlowStatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStatsReply(p StatsReply) (FlowStatsReply, error) {
	if !IsFlowStatsReply(p) {
		return NewFlowStatsReplyWithBuf(nil), errors.New("Cannot convert to of12.FlowStatsReply")
	}

	return NewFlowStatsReplyWithBuf(p.Buf), nil
}

func IsFlowStatsReply(p StatsReply) bool {
	return p.StatsType() == 1 && true
}

func (this FlowStatsReply) FlowStats() []FlowStats {
	offset := this.FlowStatsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []FlowStats
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewFlowStatsWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowStatsReply) AddFlowStats(f FlowStats) {
	offset := this.FlowStatsOffset()
	offset += this.FlowStatsSize()
	size := f.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], f.Buf[:size])
	offset += size
}

func (this FlowStatsReply) FlowStatsOffset() int {
	offset := 16
	return offset
}

func (this FlowStatsReply) FlowStatsSize() int {
	offset := this.FlowStatsOffset()
	size := this.Size()
	return size - offset
}

func NewAggregateStatsRequestWithBuf(b []byte) AggregateStatsRequest {
	return AggregateStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewAggregateStatsRequest() AggregateStatsRequest {
	s := 20
	b := make([]byte, s)
	p := AggregateStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type AggregateStatsRequest struct {
	StatsRequest
}

func (this AggregateStatsRequest) minSize() int {
	return 20
}

func (this AggregateStatsRequest) Clone() (AggregateStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAggregateStatsRequest(), err
	}

	return NewAggregateStatsRequestWithBuf(newBuf.Bytes()), nil
}

type AggregateStatsRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewAggregateStatsRequestConn(c net.Conn) AggregateStatsRequestConn {
	return AggregateStatsRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *AggregateStatsRequestConn) WriteAggregateStatsRequest(pkt AggregateStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *AggregateStatsRequestConn) WriteAggregateStatsRequests(pkts []AggregateStatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteAggregateStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *AggregateStatsRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *AggregateStatsRequestConn) ReadAggregateStatsRequest() (AggregateStatsRequest, error) {
	pkts := make([]AggregateStatsRequest, 1)
	_, err := c.ReadAggregateStatsRequests(pkts)
	if err != nil {
		return NewAggregateStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *AggregateStatsRequestConn) ReadAggregateStatsRequests(pkts []AggregateStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewAggregateStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *AggregateStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(2)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this AggregateStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToAggregateStatsRequest(p StatsRequest) (AggregateStatsRequest, error) {
	if !IsAggregateStatsRequest(p) {
		return NewAggregateStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.AggregateStatsRequest")
	}

	return NewAggregateStatsRequestWithBuf(p.Buf), nil
}

func IsAggregateStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 2 && true
}

func (this AggregateStatsRequest) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *AggregateStatsRequest) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this AggregateStatsRequest) MatchOffset() int {
	offset := 16
	return offset
}

func (this AggregateStatsRequest) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this AggregateStatsRequest) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *AggregateStatsRequest) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this AggregateStatsRequest) TableIdOffset() int {
	offset := 16
	offset += this.MatchSize()
	return offset
}

func (this AggregateStatsRequest) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *AggregateStatsRequest) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this AggregateStatsRequest) PadOffset() int {
	offset := 17
	offset += this.MatchSize()
	return offset
}

func (this AggregateStatsRequest) OutPort() uint16 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *AggregateStatsRequest) SetOutPort(o uint16) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this AggregateStatsRequest) OutPortOffset() int {
	offset := 18
	offset += this.MatchSize()
	return offset
}

func NewAggregateStatsReplyWithBuf(b []byte) AggregateStatsReply {
	return AggregateStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewAggregateStatsReply() AggregateStatsReply {
	s := 40
	b := make([]byte, s)
	p := AggregateStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type AggregateStatsReply struct {
	StatsReply
}

func (this AggregateStatsReply) minSize() int {
	return 40
}

func (this AggregateStatsReply) Clone() (AggregateStatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAggregateStatsReply(), err
	}

	return NewAggregateStatsReplyWithBuf(newBuf.Bytes()), nil
}

type AggregateStatsReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewAggregateStatsReplyConn(c net.Conn) AggregateStatsReplyConn {
	return AggregateStatsReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *AggregateStatsReplyConn) WriteAggregateStatsReply(pkt AggregateStatsReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *AggregateStatsReplyConn) WriteAggregateStatsReplys(pkts []AggregateStatsReply) error {
	for _, p := range pkts {
		if err := c.WriteAggregateStatsReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *AggregateStatsReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *AggregateStatsReplyConn) ReadAggregateStatsReply() (AggregateStatsReply, error) {
	pkts := make([]AggregateStatsReply, 1)
	_, err := c.ReadAggregateStatsReplys(pkts)
	if err != nil {
		return NewAggregateStatsReply(), err
	}

	return pkts[0], nil
}

func (c *AggregateStatsReplyConn) ReadAggregateStatsReplys(pkts []AggregateStatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewAggregateStatsReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *AggregateStatsReply) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(2)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this AggregateStatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToAggregateStatsReply(p StatsReply) (AggregateStatsReply, error) {
	if !IsAggregateStatsReply(p) {
		return NewAggregateStatsReplyWithBuf(nil), errors.New("Cannot convert to of12.AggregateStatsReply")
	}

	return NewAggregateStatsReplyWithBuf(p.Buf), nil
}

func IsAggregateStatsReply(p StatsReply) bool {
	return p.StatsType() == 2 && true
}

func (this AggregateStatsReply) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this AggregateStatsReply) PacketCountOffset() int {
	offset := 16
	return offset
}

func (this AggregateStatsReply) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this AggregateStatsReply) ByteCountOffset() int {
	offset := 24
	return offset
}

func (this AggregateStatsReply) FlowCount() uint32 {
	offset := this.FlowCountOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetFlowCount(f uint32) {
	offset := this.FlowCountOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], f)
	offset += 4
}

func (this AggregateStatsReply) FlowCountOffset() int {
	offset := 32
	return offset
}

func (this AggregateStatsReply) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *AggregateStatsReply) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this AggregateStatsReply) PadOffset() int {
	offset := 36
	return offset
}

func NewTableStatsWithBuf(b []byte) TableStats {
	return TableStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewTableStats() TableStats {
	s := 80
	b := make([]byte, s)
	p := TableStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type TableStats struct {
	StatsReply
}

func (this TableStats) minSize() int {
	return 80
}

func (this TableStats) Clone() (TableStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewTableStats(), err
	}

	return NewTableStatsWithBuf(newBuf.Bytes()), nil
}

type TableStatsConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewTableStatsConn(c net.Conn) TableStatsConn {
	return TableStatsConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *TableStatsConn) WriteTableStats(pkt TableStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *TableStatsConn) WriteTableStatss(pkts []TableStats) error {
	for _, p := range pkts {
		if err := c.WriteTableStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *TableStatsConn) Flush() error {
	return c.w.Flush()
}

func (c *TableStatsConn) ReadTableStats() (TableStats, error) {
	pkts := make([]TableStats, 1)
	_, err := c.ReadTableStatss(pkts)
	if err != nil {
		return NewTableStats(), err
	}

	return pkts[0], nil
}

func (c *TableStatsConn) ReadTableStatss(pkts []TableStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewTableStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *TableStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(3)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this TableStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToTableStats(p StatsReply) (TableStats, error) {
	if !IsTableStats(p) {
		return NewTableStatsWithBuf(nil), errors.New("Cannot convert to of12.TableStats")
	}

	return NewTableStatsWithBuf(p.Buf), nil
}

func IsTableStats(p StatsReply) bool {
	return p.StatsType() == 3 && true
}

func (this TableStats) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *TableStats) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this TableStats) TableIdOffset() int {
	offset := 16
	return offset
}

func (this TableStats) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *TableStats) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this TableStats) PadOffset() int {
	offset := 17
	return offset
}

func (this TableStats) Name() [32]byte {
	offset := this.NameOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 32
	i := 0
	var res [32]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *TableStats) SetName(n [32]byte) {
	offset := this.NameOffset()
	for _, e := range n {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this TableStats) NameOffset() int {
	offset := 20
	return offset
}

func (this TableStats) Wildcards() uint32 {
	offset := this.WildcardsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetWildcards(w uint32) {
	offset := this.WildcardsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], w)
	offset += 4
}

func (this TableStats) WildcardsOffset() int {
	offset := 52
	return offset
}

func (this TableStats) MaxEntries() uint32 {
	offset := this.MaxEntriesOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetMaxEntries(m uint32) {
	offset := this.MaxEntriesOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this TableStats) MaxEntriesOffset() int {
	offset := 56
	return offset
}

func (this TableStats) ActiveCount() uint32 {
	offset := this.ActiveCountOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetActiveCount(a uint32) {
	offset := this.ActiveCountOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this TableStats) ActiveCountOffset() int {
	offset := 60
	return offset
}

func (this TableStats) LookupCount() uint64 {
	offset := this.LookupCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *TableStats) SetLookupCount(l uint64) {
	offset := this.LookupCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], l)
	offset += 8
}

func (this TableStats) LookupCountOffset() int {
	offset := 64
	return offset
}

func (this TableStats) MatchedCount() uint64 {
	offset := this.MatchedCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *TableStats) SetMatchedCount(m uint64) {
	offset := this.MatchedCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], m)
	offset += 8
}

func (this TableStats) MatchedCountOffset() int {
	offset := 72
	return offset
}

func NewPortStatsRequestWithBuf(b []byte) PortStatsRequest {
	return PortStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewPortStatsRequest() PortStatsRequest {
	s := 24
	b := make([]byte, s)
	p := PortStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type PortStatsRequest struct {
	StatsRequest
}

func (this PortStatsRequest) minSize() int {
	return 24
}

func (this PortStatsRequest) Clone() (PortStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStatsRequest(), err
	}

	return NewPortStatsRequestWithBuf(newBuf.Bytes()), nil
}

type PortStatsRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPortStatsRequestConn(c net.Conn) PortStatsRequestConn {
	return PortStatsRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatsRequestConn) WritePortStatsRequest(pkt PortStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortStatsRequestConn) WritePortStatsRequests(pkts []PortStatsRequest) error {
	for _, p := range pkts {
		if err := c.WritePortStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortStatsRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *PortStatsRequestConn) ReadPortStatsRequest() (PortStatsRequest, error) {
	pkts := make([]PortStatsRequest, 1)
	_, err := c.ReadPortStatsRequests(pkts)
	if err != nil {
		return NewPortStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *PortStatsRequestConn) ReadPortStatsRequests(pkts []PortStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(4)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this PortStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStatsRequest(p StatsRequest) (PortStatsRequest, error) {
	if !IsPortStatsRequest(p) {
		return NewPortStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.PortStatsRequest")
	}

	return NewPortStatsRequestWithBuf(p.Buf), nil
}

func IsPortStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 4 && true
}

func (this PortStatsRequest) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortStatsRequest) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this PortStatsRequest) PortNoOffset() int {
	offset := 16
	return offset
}

func (this PortStatsRequest) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStatsRequest) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PortStatsRequest) PadOffset() int {
	offset := 18
	return offset
}

func NewPortStatsWithBuf(b []byte) PortStats {
	return PortStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewPortStats() PortStats {
	s := 120
	b := make([]byte, s)
	p := PortStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type PortStats struct {
	StatsReply
}

func (this PortStats) minSize() int {
	return 120
}

func (this PortStats) Clone() (PortStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStats(), err
	}

	return NewPortStatsWithBuf(newBuf.Bytes()), nil
}

type PortStatsConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPortStatsConn(c net.Conn) PortStatsConn {
	return PortStatsConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatsConn) WritePortStats(pkt PortStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortStatsConn) WritePortStatss(pkts []PortStats) error {
	for _, p := range pkts {
		if err := c.WritePortStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortStatsConn) Flush() error {
	return c.w.Flush()
}

func (c *PortStatsConn) ReadPortStats() (PortStats, error) {
	pkts := make([]PortStats, 1)
	_, err := c.ReadPortStatss(pkts)
	if err != nil {
		return NewPortStats(), err
	}

	return pkts[0], nil
}

func (c *PortStatsConn) ReadPortStatss(pkts []PortStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(4)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this PortStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStats(p StatsReply) (PortStats, error) {
	if !IsPortStats(p) {
		return NewPortStatsWithBuf(nil), errors.New("Cannot convert to of12.PortStats")
	}

	return NewPortStatsWithBuf(p.Buf), nil
}

func IsPortStats(p StatsReply) bool {
	return p.StatsType() == 4 && true
}

func (this PortStats) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortStats) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this PortStats) PortNoOffset() int {
	offset := 16
	return offset
}

func (this PortStats) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStats) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PortStats) PadOffset() int {
	offset := 18
	return offset
}

func (this PortStats) RxPackets() uint64 {
	offset := this.RxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxPackets(r uint64) {
	offset := this.RxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxPacketsOffset() int {
	offset := 24
	return offset
}

func (this PortStats) TxPackets() uint64 {
	offset := this.TxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxPackets(t uint64) {
	offset := this.TxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this PortStats) TxPacketsOffset() int {
	offset := 32
	return offset
}

func (this PortStats) RxBytes() uint64 {
	offset := this.RxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxBytes(r uint64) {
	offset := this.RxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxBytesOffset() int {
	offset := 40
	return offset
}

func (this PortStats) TxBytes() uint64 {
	offset := this.TxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxBytes(t uint64) {
	offset := this.TxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this PortStats) TxBytesOffset() int {
	offset := 48
	return offset
}

func (this PortStats) RxDropped() uint64 {
	offset := this.RxDroppedOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxDropped(r uint64) {
	offset := this.RxDroppedOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxDroppedOffset() int {
	offset := 56
	return offset
}

func (this PortStats) TxDropped() uint64 {
	offset := this.TxDroppedOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxDropped(t uint64) {
	offset := this.TxDroppedOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this PortStats) TxDroppedOffset() int {
	offset := 64
	return offset
}

func (this PortStats) RxErrors() uint64 {
	offset := this.RxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxErrors(r uint64) {
	offset := this.RxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxErrorsOffset() int {
	offset := 72
	return offset
}

func (this PortStats) TxErrors() uint64 {
	offset := this.TxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxErrors(t uint64) {
	offset := this.TxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this PortStats) TxErrorsOffset() int {
	offset := 80
	return offset
}

func (this PortStats) RxFrameErr() uint64 {
	offset := this.RxFrameErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxFrameErr(r uint64) {
	offset := this.RxFrameErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxFrameErrOffset() int {
	offset := 88
	return offset
}

func (this PortStats) RxOverErr() uint64 {
	offset := this.RxOverErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxOverErr(r uint64) {
	offset := this.RxOverErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxOverErrOffset() int {
	offset := 96
	return offset
}

func (this PortStats) RxCrcErr() uint64 {
	offset := this.RxCrcErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxCrcErr(r uint64) {
	offset := this.RxCrcErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this PortStats) RxCrcErrOffset() int {
	offset := 104
	return offset
}

func (this PortStats) Collisions() uint64 {
	offset := this.CollisionsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetCollisions(c uint64) {
	offset := this.CollisionsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this PortStats) CollisionsOffset() int {
	offset := 112
	return offset
}

func NewVendorHeaderWithBuf(b []byte) VendorHeader {
	return VendorHeader{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewVendorHeader() VendorHeader {
	s := 12
	b := make([]byte, s)
	p := VendorHeader{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type VendorHeader struct {
	Header12
}

func (this VendorHeader) minSize() int {
	return 12
}

func (this VendorHeader) Clone() (VendorHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewVendorHeader(), err
	}

	return NewVendorHeaderWithBuf(newBuf.Bytes()), nil
}

type VendorHeaderConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewVendorHeaderConn(c net.Conn) VendorHeaderConn {
	return VendorHeaderConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *VendorHeaderConn) WriteVendorHeader(pkt VendorHeader) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *VendorHeaderConn) WriteVendorHeaders(pkts []VendorHeader) error {
	for _, p := range pkts {
		if err := c.WriteVendorHeader(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *VendorHeaderConn) Flush() error {
	return c.w.Flush()
}

func (c *VendorHeaderConn) ReadVendorHeader() (VendorHeader, error) {
	pkts := make([]VendorHeader, 1)
	_, err := c.ReadVendorHeaders(pkts)
	if err != nil {
		return NewVendorHeader(), err
	}

	return pkts[0], nil
}

func (c *VendorHeaderConn) ReadVendorHeaders(pkts []VendorHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewVendorHeaderWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *VendorHeader) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(4))    // type
	this.SetVersion(uint8(3)) // version
}

func (this VendorHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToVendorHeader(p Header12) (VendorHeader, error) {
	if !IsVendorHeader(p) {
		return NewVendorHeaderWithBuf(nil), errors.New("Cannot convert to of12.VendorHeader")
	}

	return NewVendorHeaderWithBuf(p.Buf), nil
}

func IsVendorHeader(p Header12) bool {
	return p.Type() == 4 && true
}

func (this VendorHeader) Vendor() uint32 {
	offset := this.VendorOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *VendorHeader) SetVendor(v uint32) {
	offset := this.VendorOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], v)
	offset += 4
}

func (this VendorHeader) VendorOffset() int {
	offset := 8
	return offset
}

func NewQueuePropHeaderWithBuf(b []byte) QueuePropHeader {
	return QueuePropHeader{packet.Packet{Buf: b}}
}

func NewQueuePropHeader() QueuePropHeader {
	s := 8
	b := make([]byte, s)
	p := QueuePropHeader{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type QueuePropHeader struct {
	packet.Packet
}

func (this QueuePropHeader) minSize() int {
	return 8
}

func (this QueuePropHeader) Clone() (QueuePropHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueuePropHeader(), err
	}

	return NewQueuePropHeaderWithBuf(newBuf.Bytes()), nil
}

type QueuePropHeaderConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewQueuePropHeaderConn(c net.Conn) QueuePropHeaderConn {
	return QueuePropHeaderConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueuePropHeaderConn) WriteQueuePropHeader(pkt QueuePropHeader) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueuePropHeaderConn) WriteQueuePropHeaders(pkts []QueuePropHeader) error {
	for _, p := range pkts {
		if err := c.WriteQueuePropHeader(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueuePropHeaderConn) Flush() error {
	return c.w.Flush()
}

func (c *QueuePropHeaderConn) ReadQueuePropHeader() (QueuePropHeader, error) {
	pkts := make([]QueuePropHeader, 1)
	_, err := c.ReadQueuePropHeaders(pkts)
	if err != nil {
		return NewQueuePropHeader(), err
	}

	return pkts[0], nil
}

func (c *QueuePropHeaderConn) ReadQueuePropHeaders(pkts []QueuePropHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueuePropHeaderWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueuePropHeader) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this QueuePropHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToQueuePropHeader(p packet.Packet) (QueuePropHeader, error) {
	if !IsQueuePropHeader(p) {
		return NewQueuePropHeaderWithBuf(nil), errors.New("Cannot convert to of12.QueuePropHeader")
	}

	return NewQueuePropHeaderWithBuf(p.Buf), nil
}

func IsQueuePropHeader(p packet.Packet) bool {
	return true
}

func (this QueuePropHeader) Property() uint16 {
	offset := this.PropertyOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropHeader) SetProperty(p uint16) {
	offset := this.PropertyOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this QueuePropHeader) PropertyOffset() int {
	offset := 0
	return offset
}

func (this QueuePropHeader) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropHeader) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this QueuePropHeader) LenOffset() int {
	offset := 2
	return offset
}

func (this QueuePropHeader) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueuePropHeader) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this QueuePropHeader) PadOffset() int {
	offset := 4
	return offset
}

func NewQueuePropMinRateWithBuf(b []byte) QueuePropMinRate {
	return QueuePropMinRate{QueuePropHeader{packet.Packet{Buf: b}}}
}

func NewQueuePropMinRate() QueuePropMinRate {
	s := 16
	b := make([]byte, s)
	p := QueuePropMinRate{QueuePropHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type QueuePropMinRate struct {
	QueuePropHeader
}

func (this QueuePropMinRate) minSize() int {
	return 16
}

func (this QueuePropMinRate) Clone() (QueuePropMinRate, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueuePropMinRate(), err
	}

	return NewQueuePropMinRateWithBuf(newBuf.Bytes()), nil
}

type QueuePropMinRateConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewQueuePropMinRateConn(c net.Conn) QueuePropMinRateConn {
	return QueuePropMinRateConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueuePropMinRateConn) WriteQueuePropMinRate(pkt QueuePropMinRate) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueuePropMinRateConn) WriteQueuePropMinRates(pkts []QueuePropMinRate) error {
	for _, p := range pkts {
		if err := c.WriteQueuePropMinRate(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueuePropMinRateConn) Flush() error {
	return c.w.Flush()
}

func (c *QueuePropMinRateConn) ReadQueuePropMinRate() (QueuePropMinRate, error) {
	pkts := make([]QueuePropMinRate, 1)
	_, err := c.ReadQueuePropMinRates(pkts)
	if err != nil {
		return NewQueuePropMinRate(), err
	}

	return pkts[0], nil
}

func (c *QueuePropMinRateConn) ReadQueuePropMinRates(pkts []QueuePropMinRate) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueuePropMinRateWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueuePropMinRate) Init() {
	this.QueuePropHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetProperty(uint16(1)) // property
}

func (this QueuePropMinRate) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToQueuePropMinRate(p QueuePropHeader) (QueuePropMinRate, error) {
	if !IsQueuePropMinRate(p) {
		return NewQueuePropMinRateWithBuf(nil), errors.New("Cannot convert to of12.QueuePropMinRate")
	}

	return NewQueuePropMinRateWithBuf(p.Buf), nil
}

func IsQueuePropMinRate(p QueuePropHeader) bool {
	return p.Property() == 1 && true
}

func (this QueuePropMinRate) Rate() uint16 {
	offset := this.RateOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropMinRate) SetRate(r uint16) {
	offset := this.RateOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], r)
	offset += 2
}

func (this QueuePropMinRate) RateOffset() int {
	offset := 8
	return offset
}

func (this QueuePropMinRate) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueuePropMinRate) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this QueuePropMinRate) PadOffset() int {
	offset := 10
	return offset
}

func NewPacketQueueWithBuf(b []byte) PacketQueue {
	return PacketQueue{packet.Packet{Buf: b}}
}

func NewPacketQueue() PacketQueue {
	s := 8
	b := make([]byte, s)
	p := PacketQueue{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type PacketQueue struct {
	packet.Packet
}

func (this PacketQueue) minSize() int {
	return 8
}

func (this PacketQueue) Clone() (PacketQueue, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketQueue(), err
	}

	return NewPacketQueueWithBuf(newBuf.Bytes()), nil
}

type PacketQueueConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewPacketQueueConn(c net.Conn) PacketQueueConn {
	return PacketQueueConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketQueueConn) WritePacketQueue(pkt PacketQueue) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PacketQueueConn) WritePacketQueues(pkts []PacketQueue) error {
	for _, p := range pkts {
		if err := c.WritePacketQueue(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PacketQueueConn) Flush() error {
	return c.w.Flush()
}

func (c *PacketQueueConn) ReadPacketQueue() (PacketQueue, error) {
	pkts := make([]PacketQueue, 1)
	_, err := c.ReadPacketQueues(pkts)
	if err != nil {
		return NewPacketQueue(), err
	}

	return pkts[0], nil
}

func (c *PacketQueueConn) ReadPacketQueues(pkts []PacketQueue) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketQueueWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PacketQueue) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this PacketQueue) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToPacketQueue(p packet.Packet) (PacketQueue, error) {
	if !IsPacketQueue(p) {
		return NewPacketQueueWithBuf(nil), errors.New("Cannot convert to of12.PacketQueue")
	}

	return NewPacketQueueWithBuf(p.Buf), nil
}

func IsPacketQueue(p packet.Packet) bool {
	return true
}

func (this PacketQueue) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketQueue) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this PacketQueue) QueueIdOffset() int {
	offset := 0
	return offset
}

func (this PacketQueue) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketQueue) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this PacketQueue) LenOffset() int {
	offset := 4
	return offset
}

func (this PacketQueue) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PacketQueue) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this PacketQueue) PadOffset() int {
	offset := 6
	return offset
}

func (this PacketQueue) Properties() []QueuePropHeader {
	offset := this.PropertiesOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []QueuePropHeader
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewQueuePropHeaderWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketQueue) AddProperties(p QueuePropHeader) {
	offset := this.PropertiesOffset()
	offset += this.PropertiesSize()
	size := p.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLen(uint16(pSize + size))
	copy(this.Buf[offset:], p.Buf[:size])
	offset += size
}

func (this PacketQueue) PropertiesOffset() int {
	offset := 8
	return offset
}

func (this PacketQueue) PropertiesSize() int {
	offset := this.PropertiesOffset()
	size := this.Size()
	return size - offset
}

func NewQueueGetConfigRequestWithBuf(b []byte) QueueGetConfigRequest {
	return QueueGetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewQueueGetConfigRequest() QueueGetConfigRequest {
	s := 10
	b := make([]byte, s)
	p := QueueGetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type QueueGetConfigRequest struct {
	Header12
}

func (this QueueGetConfigRequest) minSize() int {
	return 10
}

func (this QueueGetConfigRequest) Clone() (QueueGetConfigRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueGetConfigRequest(), err
	}

	return NewQueueGetConfigRequestWithBuf(newBuf.Bytes()), nil
}

type QueueGetConfigRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewQueueGetConfigRequestConn(c net.Conn) QueueGetConfigRequestConn {
	return QueueGetConfigRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueGetConfigRequestConn) WriteQueueGetConfigRequest(pkt QueueGetConfigRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueGetConfigRequestConn) WriteQueueGetConfigRequests(pkts []QueueGetConfigRequest) error {
	for _, p := range pkts {
		if err := c.WriteQueueGetConfigRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueGetConfigRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *QueueGetConfigRequestConn) ReadQueueGetConfigRequest() (QueueGetConfigRequest, error) {
	pkts := make([]QueueGetConfigRequest, 1)
	_, err := c.ReadQueueGetConfigRequests(pkts)
	if err != nil {
		return NewQueueGetConfigRequest(), err
	}

	return pkts[0], nil
}

func (c *QueueGetConfigRequestConn) ReadQueueGetConfigRequests(pkts []QueueGetConfigRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueGetConfigRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueGetConfigRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(23))   // type
	this.SetVersion(uint8(3)) // version
}

func (this QueueGetConfigRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueGetConfigRequest(p Header12) (QueueGetConfigRequest, error) {
	if !IsQueueGetConfigRequest(p) {
		return NewQueueGetConfigRequestWithBuf(nil), errors.New("Cannot convert to of12.QueueGetConfigRequest")
	}

	return NewQueueGetConfigRequestWithBuf(p.Buf), nil
}

func IsQueueGetConfigRequest(p Header12) bool {
	return p.Type() == 23 && true
}

func (this QueueGetConfigRequest) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueGetConfigRequest) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this QueueGetConfigRequest) PortOffset() int {
	offset := 8
	return offset
}

func (this QueueGetConfigRequest) Pad() []uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	return []uint8(this.Buf[offset : offset+size])
}

func (this *QueueGetConfigRequest) AddPad(p uint8) {
	offset := this.PadOffset()
	offset += this.PadSize()
	size := 1
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	this.Buf[offset] = byte(p)
	offset++
}

func (this QueueGetConfigRequest) PadOffset() int {
	offset := 10
	return offset
}

func (this QueueGetConfigRequest) PadSize() int {
	offset := this.PadOffset()
	size := this.Size()
	return size - offset
}

func NewQueueGetConfigReplyWithBuf(b []byte) QueueGetConfigReply {
	return QueueGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewQueueGetConfigReply() QueueGetConfigReply {
	s := 16
	b := make([]byte, s)
	p := QueueGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type QueueGetConfigReply struct {
	Header12
}

func (this QueueGetConfigReply) minSize() int {
	return 16
}

func (this QueueGetConfigReply) Clone() (QueueGetConfigReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueGetConfigReply(), err
	}

	return NewQueueGetConfigReplyWithBuf(newBuf.Bytes()), nil
}

type QueueGetConfigReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewQueueGetConfigReplyConn(c net.Conn) QueueGetConfigReplyConn {
	return QueueGetConfigReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueGetConfigReplyConn) WriteQueueGetConfigReply(pkt QueueGetConfigReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueGetConfigReplyConn) WriteQueueGetConfigReplys(pkts []QueueGetConfigReply) error {
	for _, p := range pkts {
		if err := c.WriteQueueGetConfigReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueGetConfigReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *QueueGetConfigReplyConn) ReadQueueGetConfigReply() (QueueGetConfigReply, error) {
	pkts := make([]QueueGetConfigReply, 1)
	_, err := c.ReadQueueGetConfigReplys(pkts)
	if err != nil {
		return NewQueueGetConfigReply(), err
	}

	return pkts[0], nil
}

func (c *QueueGetConfigReplyConn) ReadQueueGetConfigReplys(pkts []QueueGetConfigReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueGetConfigReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueGetConfigReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(23))   // type
	this.SetVersion(uint8(3)) // version
}

func (this QueueGetConfigReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueGetConfigReply(p Header12) (QueueGetConfigReply, error) {
	if !IsQueueGetConfigReply(p) {
		return NewQueueGetConfigReplyWithBuf(nil), errors.New("Cannot convert to of12.QueueGetConfigReply")
	}

	return NewQueueGetConfigReplyWithBuf(p.Buf), nil
}

func IsQueueGetConfigReply(p Header12) bool {
	return p.Type() == 23 && true
}

func (this QueueGetConfigReply) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueGetConfigReply) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this QueueGetConfigReply) PortOffset() int {
	offset := 8
	return offset
}

func (this QueueGetConfigReply) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueGetConfigReply) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this QueueGetConfigReply) PadOffset() int {
	offset := 10
	return offset
}

func (this QueueGetConfigReply) Queues() []PacketQueue {
	offset := this.QueuesOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []PacketQueue
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewPacketQueueWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *QueueGetConfigReply) AddQueues(q PacketQueue) {
	offset := this.QueuesOffset()
	offset += this.QueuesSize()
	size := q.Size()
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetLength(uint16(pSize + size))
	copy(this.Buf[offset:], q.Buf[:size])
	offset += size
}

func (this QueueGetConfigReply) QueuesOffset() int {
	offset := 16
	return offset
}

func (this QueueGetConfigReply) QueuesSize() int {
	offset := this.QueuesOffset()
	size := this.Size()
	return size - offset
}

func NewQueueStatsRequestWithBuf(b []byte) QueueStatsRequest {
	return QueueStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewQueueStatsRequest() QueueStatsRequest {
	s := 24
	b := make([]byte, s)
	p := QueueStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type QueueStatsRequest struct {
	StatsRequest
}

func (this QueueStatsRequest) minSize() int {
	return 24
}

func (this QueueStatsRequest) Clone() (QueueStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueStatsRequest(), err
	}

	return NewQueueStatsRequestWithBuf(newBuf.Bytes()), nil
}

type QueueStatsRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewQueueStatsRequestConn(c net.Conn) QueueStatsRequestConn {
	return QueueStatsRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueStatsRequestConn) WriteQueueStatsRequest(pkt QueueStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueStatsRequestConn) WriteQueueStatsRequests(pkts []QueueStatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteQueueStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueStatsRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *QueueStatsRequestConn) ReadQueueStatsRequest() (QueueStatsRequest, error) {
	pkts := make([]QueueStatsRequest, 1)
	_, err := c.ReadQueueStatsRequests(pkts)
	if err != nil {
		return NewQueueStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *QueueStatsRequestConn) ReadQueueStatsRequests(pkts []QueueStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(5)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this QueueStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueStatsRequest(p StatsRequest) (QueueStatsRequest, error) {
	if !IsQueueStatsRequest(p) {
		return NewQueueStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.QueueStatsRequest")
	}

	return NewQueueStatsRequestWithBuf(p.Buf), nil
}

func IsQueueStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 5 && true
}

func (this QueueStatsRequest) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueStatsRequest) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this QueueStatsRequest) PortNoOffset() int {
	offset := 16
	return offset
}

func (this QueueStatsRequest) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueStatsRequest) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this QueueStatsRequest) PadOffset() int {
	offset := 18
	return offset
}

func (this QueueStatsRequest) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *QueueStatsRequest) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this QueueStatsRequest) QueueIdOffset() int {
	offset := 20
	return offset
}

func NewQueueStatsWithBuf(b []byte) QueueStats {
	return QueueStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewQueueStats() QueueStats {
	s := 48
	b := make([]byte, s)
	p := QueueStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type QueueStats struct {
	StatsReply
}

func (this QueueStats) minSize() int {
	return 48
}

func (this QueueStats) Clone() (QueueStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueStats(), err
	}

	return NewQueueStatsWithBuf(newBuf.Bytes()), nil
}

type QueueStatsConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewQueueStatsConn(c net.Conn) QueueStatsConn {
	return QueueStatsConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueStatsConn) WriteQueueStats(pkt QueueStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueStatsConn) WriteQueueStatss(pkts []QueueStats) error {
	for _, p := range pkts {
		if err := c.WriteQueueStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueStatsConn) Flush() error {
	return c.w.Flush()
}

func (c *QueueStatsConn) ReadQueueStats() (QueueStats, error) {
	pkts := make([]QueueStats, 1)
	_, err := c.ReadQueueStatss(pkts)
	if err != nil {
		return NewQueueStats(), err
	}

	return pkts[0], nil
}

func (c *QueueStatsConn) ReadQueueStatss(pkts []QueueStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(5)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this QueueStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueStats(p StatsReply) (QueueStats, error) {
	if !IsQueueStats(p) {
		return NewQueueStatsWithBuf(nil), errors.New("Cannot convert to of12.QueueStats")
	}

	return NewQueueStatsWithBuf(p.Buf), nil
}

func IsQueueStats(p StatsReply) bool {
	return p.StatsType() == 5 && true
}

func (this QueueStats) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this QueueStats) PortNoOffset() int {
	offset := 16
	return offset
}

func (this QueueStats) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueStats) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this QueueStats) PadOffset() int {
	offset := 18
	return offset
}

func (this QueueStats) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this QueueStats) QueueIdOffset() int {
	offset := 20
	return offset
}

func (this QueueStats) TxBytes() uint64 {
	offset := this.TxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxBytes(t uint64) {
	offset := this.TxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this QueueStats) TxBytesOffset() int {
	offset := 24
	return offset
}

func (this QueueStats) TxPackets() uint64 {
	offset := this.TxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxPackets(t uint64) {
	offset := this.TxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this QueueStats) TxPacketsOffset() int {
	offset := 32
	return offset
}

func (this QueueStats) TxErrors() uint64 {
	offset := this.TxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxErrors(t uint64) {
	offset := this.TxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this QueueStats) TxErrorsOffset() int {
	offset := 40
	return offset
}

func NewRoleRequestWithBuf(b []byte) RoleRequest {
	return RoleRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewRoleRequest() RoleRequest {
	s := 24
	b := make([]byte, s)
	p := RoleRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type RoleRequest struct {
	Header12
}

func (this RoleRequest) minSize() int {
	return 24
}

func (this RoleRequest) Clone() (RoleRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewRoleRequest(), err
	}

	return NewRoleRequestWithBuf(newBuf.Bytes()), nil
}

type RoleRequestConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewRoleRequestConn(c net.Conn) RoleRequestConn {
	return RoleRequestConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *RoleRequestConn) WriteRoleRequest(pkt RoleRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *RoleRequestConn) WriteRoleRequests(pkts []RoleRequest) error {
	for _, p := range pkts {
		if err := c.WriteRoleRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *RoleRequestConn) Flush() error {
	return c.w.Flush()
}

func (c *RoleRequestConn) ReadRoleRequest() (RoleRequest, error) {
	pkts := make([]RoleRequest, 1)
	_, err := c.ReadRoleRequests(pkts)
	if err != nil {
		return NewRoleRequest(), err
	}

	return pkts[0], nil
}

func (c *RoleRequestConn) ReadRoleRequests(pkts []RoleRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewRoleRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *RoleRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(24))   // type
	this.SetVersion(uint8(3)) // version
}

func (this RoleRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToRoleRequest(p Header12) (RoleRequest, error) {
	if !IsRoleRequest(p) {
		return NewRoleRequestWithBuf(nil), errors.New("Cannot convert to of12.RoleRequest")
	}

	return NewRoleRequestWithBuf(p.Buf), nil
}

func IsRoleRequest(p Header12) bool {
	return p.Type() == 24 && true
}

func (this RoleRequest) Role() uint32 {
	offset := this.RoleOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *RoleRequest) SetRole(r uint32) {
	offset := this.RoleOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], r)
	offset += 4
}

func (this RoleRequest) RoleOffset() int {
	offset := 8
	return offset
}

func (this RoleRequest) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *RoleRequest) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this RoleRequest) PadOffset() int {
	offset := 12
	return offset
}

func (this RoleRequest) GenerationId() uint64 {
	offset := this.GenerationIdOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *RoleRequest) SetGenerationId(g uint64) {
	offset := this.GenerationIdOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], g)
	offset += 8
}

func (this RoleRequest) GenerationIdOffset() int {
	offset := 16
	return offset
}

func NewRoleReplyWithBuf(b []byte) RoleReply {
	return RoleReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewRoleReply() RoleReply {
	s := 24
	b := make([]byte, s)
	p := RoleReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type RoleReply struct {
	Header12
}

func (this RoleReply) minSize() int {
	return 24
}

func (this RoleReply) Clone() (RoleReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewRoleReply(), err
	}

	return NewRoleReplyWithBuf(newBuf.Bytes()), nil
}

type RoleReplyConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewRoleReplyConn(c net.Conn) RoleReplyConn {
	return RoleReplyConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *RoleReplyConn) WriteRoleReply(pkt RoleReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *RoleReplyConn) WriteRoleReplys(pkts []RoleReply) error {
	for _, p := range pkts {
		if err := c.WriteRoleReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *RoleReplyConn) Flush() error {
	return c.w.Flush()
}

func (c *RoleReplyConn) ReadRoleReply() (RoleReply, error) {
	pkts := make([]RoleReply, 1)
	_, err := c.ReadRoleReplys(pkts)
	if err != nil {
		return NewRoleReply(), err
	}

	return pkts[0], nil
}

func (c *RoleReplyConn) ReadRoleReplys(pkts []RoleReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewRoleReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *RoleReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(25))   // type
	this.SetVersion(uint8(3)) // version
}

func (this RoleReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToRoleReply(p Header12) (RoleReply, error) {
	if !IsRoleReply(p) {
		return NewRoleReplyWithBuf(nil), errors.New("Cannot convert to of12.RoleReply")
	}

	return NewRoleReplyWithBuf(p.Buf), nil
}

func IsRoleReply(p Header12) bool {
	return p.Type() == 25 && true
}

func (this RoleReply) Role() uint32 {
	offset := this.RoleOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *RoleReply) SetRole(r uint32) {
	offset := this.RoleOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], r)
	offset += 4
}

func (this RoleReply) RoleOffset() int {
	offset := 8
	return offset
}

func (this RoleReply) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *RoleReply) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this RoleReply) PadOffset() int {
	offset := 12
	return offset
}

func (this RoleReply) GenerationId() uint64 {
	offset := this.GenerationIdOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *RoleReply) SetGenerationId(g uint64) {
	offset := this.GenerationIdOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], g)
	offset += 8
}

func (this RoleReply) GenerationIdOffset() int {
	offset := 16
	return offset
}
