// Automatically generated by Packet Go code generator.
package lldp

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"

	"github.com/packet/packet/src/go/packet"

	"github.com/kandoo/beehive-netctrl/net/ethernet"
)

type LinkDiscoveryTLVType int

const (
	TLV_CHASSIS_ID LinkDiscoveryTLVType = 1
	TLV_PORT_ID    LinkDiscoveryTLVType = 2
	TLV_TTL        LinkDiscoveryTLVType = 3
	TLV_CUSTOM     LinkDiscoveryTLVType = 127
)

type PortTLVSubtype int

const (
	PORT_TLV_IFACE_ALIAS      PortTLVSubtype = 1
	PORT_TLV_PORT_COMP        PortTLVSubtype = 2
	PORT_TLV_MAC_ADDR         PortTLVSubtype = 3
	PORT_TLV_NET_ADDR         PortTLVSubtype = 4
	PORT_TLV_IFACE_NAME       PortTLVSubtype = 5
	PORT_TLV_AGENT_CIRCUIT_ID PortTLVSubtype = 6
	PORT_TLV_LOCAL            PortTLVSubtype = 7
)

func NewLinkDiscoveryTLVWithBuf(b []byte) LinkDiscoveryTLV {
	return LinkDiscoveryTLV{packet.Packet{Buf: b}}
}

func NewLinkDiscoveryTLV() LinkDiscoveryTLV {
	s := 2
	b := make([]byte, s)
	p := LinkDiscoveryTLV{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type LinkDiscoveryTLV struct {
	packet.Packet
}

func (this LinkDiscoveryTLV) minSize() int {
	return 2
}

func (this LinkDiscoveryTLV) Clone() (LinkDiscoveryTLV, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewLinkDiscoveryTLV(), err
	}

	return NewLinkDiscoveryTLVWithBuf(newBuf.Bytes()), nil
}

type LinkDiscoveryTLVConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewLinkDiscoveryTLVConn(c net.Conn) LinkDiscoveryTLVConn {
	return LinkDiscoveryTLVConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *LinkDiscoveryTLVConn) WriteLinkDiscoveryTLV(pkt LinkDiscoveryTLV) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *LinkDiscoveryTLVConn) WriteLinkDiscoveryTLVs(pkts []LinkDiscoveryTLV) error {
	for _, p := range pkts {
		if err := c.WriteLinkDiscoveryTLV(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *LinkDiscoveryTLVConn) Flush() error {
	return c.w.Flush()
}

func (c *LinkDiscoveryTLVConn) ReadLinkDiscoveryTLV() (LinkDiscoveryTLV, error) {
	pkts := make([]LinkDiscoveryTLV, 1)
	_, err := c.ReadLinkDiscoveryTLVs(pkts)
	if err != nil {
		return NewLinkDiscoveryTLV(), err
	}

	return pkts[0], nil
}

func (c *LinkDiscoveryTLVConn) ReadLinkDiscoveryTLVs(pkts []LinkDiscoveryTLV) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewLinkDiscoveryTLVWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *LinkDiscoveryTLV) Init() {
	this.SetSize(this.minSize())
	// Invariants.
}

func ToLinkDiscoveryTLV(p packet.Packet) (LinkDiscoveryTLV, error) {
	if !IsLinkDiscoveryTLV(p) {
		return NewLinkDiscoveryTLVWithBuf(nil), errors.New("Cannot convert to lldp.LinkDiscoveryTLV")
	}

	return NewLinkDiscoveryTLVWithBuf(p.Buf), nil
}

func IsLinkDiscoveryTLV(p packet.Packet) bool {
	return true
}

func (this LinkDiscoveryTLV) TypeAndLen() uint16 {
	offset := this.TypeAndLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *LinkDiscoveryTLV) SetTypeAndLen(t uint16) {
	offset := this.TypeAndLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this LinkDiscoveryTLV) TypeAndLenOffset() int {
	offset := 0
	return offset
}

func (this LinkDiscoveryTLV) Value() []uint8 {
	offset := this.ValueOffset()
	packet_size := this.Size()
	size := packet_size - offset
	return []uint8(this.Buf[offset : offset+size])
}

func (this *LinkDiscoveryTLV) AddValue(v uint8) {
	offset := this.ValueOffset()
	offset += this.ValueSize()
	size := 1
	pSize := this.Size()
	this.OpenGap(offset, size, pSize)
	this.SetSize(pSize + size)
	this.Buf[offset] = byte(v)
	offset++
}

func (this LinkDiscoveryTLV) ValueOffset() int {
	offset := 2
	return offset
}

func (this LinkDiscoveryTLV) ValueSize() int {
	offset := this.ValueOffset()
	return this.Size() - offset
}

func NewLinkDiscoveryProtocolWithBuf(b []byte) LinkDiscoveryProtocol {
	return LinkDiscoveryProtocol{ethernet.Ethernet{packet.Packet{Buf: b}}}
}

func NewLinkDiscoveryProtocol() LinkDiscoveryProtocol {
	s := 14
	b := make([]byte, s)
	p := LinkDiscoveryProtocol{ethernet.Ethernet{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type LinkDiscoveryProtocol struct {
	ethernet.Ethernet
}

func (this LinkDiscoveryProtocol) minSize() int {
	return 14
}

func (this LinkDiscoveryProtocol) Clone() (LinkDiscoveryProtocol, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewLinkDiscoveryProtocol(), err
	}

	return NewLinkDiscoveryProtocolWithBuf(newBuf.Bytes()), nil
}

type LinkDiscoveryProtocolConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewLinkDiscoveryProtocolConn(c net.Conn) LinkDiscoveryProtocolConn {
	return LinkDiscoveryProtocolConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *LinkDiscoveryProtocolConn) WriteLinkDiscoveryProtocol(pkt LinkDiscoveryProtocol) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *LinkDiscoveryProtocolConn) WriteLinkDiscoveryProtocols(pkts []LinkDiscoveryProtocol) error {
	for _, p := range pkts {
		if err := c.WriteLinkDiscoveryProtocol(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *LinkDiscoveryProtocolConn) Flush() error {
	return c.w.Flush()
}

func (c *LinkDiscoveryProtocolConn) ReadLinkDiscoveryProtocol() (LinkDiscoveryProtocol, error) {
	pkts := make([]LinkDiscoveryProtocol, 1)
	_, err := c.ReadLinkDiscoveryProtocols(pkts)
	if err != nil {
		return NewLinkDiscoveryProtocol(), err
	}

	return pkts[0], nil
}

func (c *LinkDiscoveryProtocolConn) ReadLinkDiscoveryProtocols(pkts []LinkDiscoveryProtocol) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewLinkDiscoveryProtocolWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *LinkDiscoveryProtocol) Init() {
	this.Ethernet.Init()
	// Invariants.
	this.SetType(uint16(35020)) // type
}

func (this LinkDiscoveryProtocol) Size() int {
	return 14
}

func ToLinkDiscoveryProtocol(p ethernet.Ethernet) (LinkDiscoveryProtocol, error) {
	if !IsLinkDiscoveryProtocol(p) {
		return NewLinkDiscoveryProtocolWithBuf(nil), errors.New("Cannot convert to lldp.LinkDiscoveryProtocol")
	}

	return NewLinkDiscoveryProtocolWithBuf(p.Buf), nil
}

func IsLinkDiscoveryProtocol(p ethernet.Ethernet) bool {
	return p.Type() == 35020 && true
}

func NewChassisTLVWithBuf(b []byte) ChassisTLV {
	return ChassisTLV{packet.Packet{Buf: b}}
}

func NewChassisTLV() ChassisTLV {
	s := 3
	b := make([]byte, s)
	p := ChassisTLV{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type ChassisTLV struct {
	packet.Packet
}

func (this ChassisTLV) minSize() int {
	return 3
}

func (this ChassisTLV) Clone() (ChassisTLV, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewChassisTLV(), err
	}

	return NewChassisTLVWithBuf(newBuf.Bytes()), nil
}

type ChassisTLVConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewChassisTLVConn(c net.Conn) ChassisTLVConn {
	return ChassisTLVConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ChassisTLVConn) WriteChassisTLV(pkt ChassisTLV) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ChassisTLVConn) WriteChassisTLVs(pkts []ChassisTLV) error {
	for _, p := range pkts {
		if err := c.WriteChassisTLV(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ChassisTLVConn) Flush() error {
	return c.w.Flush()
}

func (c *ChassisTLVConn) ReadChassisTLV() (ChassisTLV, error) {
	pkts := make([]ChassisTLV, 1)
	_, err := c.ReadChassisTLVs(pkts)
	if err != nil {
		return NewChassisTLV(), err
	}

	return pkts[0], nil
}

func (c *ChassisTLVConn) ReadChassisTLVs(pkts []ChassisTLV) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewChassisTLVWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ChassisTLV) Init() {
	// Invariants.
}

func (this ChassisTLV) Size() int {
	return 3
}

func ToChassisTLV(p packet.Packet) (ChassisTLV, error) {
	if !IsChassisTLV(p) {
		return NewChassisTLVWithBuf(nil), errors.New("Cannot convert to lldp.ChassisTLV")
	}

	return NewChassisTLVWithBuf(p.Buf), nil
}

func IsChassisTLV(p packet.Packet) bool {
	return true
}

func (this ChassisTLV) TypeAndLen() uint16 {
	offset := this.TypeAndLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ChassisTLV) SetTypeAndLen(t uint16) {
	offset := this.TypeAndLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this ChassisTLV) TypeAndLenOffset() int {
	offset := 0
	return offset
}

func (this ChassisTLV) Subtype() uint8 {
	offset := this.SubtypeOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *ChassisTLV) SetSubtype(s uint8) {
	offset := this.SubtypeOffset()
	this.Buf[offset] = byte(s)
	offset++
}

func (this ChassisTLV) SubtypeOffset() int {
	offset := 2
	return offset
}

func NewChassisMacTLVWithBuf(b []byte) ChassisMacTLV {
	return ChassisMacTLV{ChassisTLV{packet.Packet{Buf: b}}}
}

func NewChassisMacTLV() ChassisMacTLV {
	s := 9
	b := make([]byte, s)
	p := ChassisMacTLV{ChassisTLV{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ChassisMacTLV struct {
	ChassisTLV
}

func (this ChassisMacTLV) minSize() int {
	return 9
}

func (this ChassisMacTLV) Clone() (ChassisMacTLV, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewChassisMacTLV(), err
	}

	return NewChassisMacTLVWithBuf(newBuf.Bytes()), nil
}

type ChassisMacTLVConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewChassisMacTLVConn(c net.Conn) ChassisMacTLVConn {
	return ChassisMacTLVConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ChassisMacTLVConn) WriteChassisMacTLV(pkt ChassisMacTLV) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ChassisMacTLVConn) WriteChassisMacTLVs(pkts []ChassisMacTLV) error {
	for _, p := range pkts {
		if err := c.WriteChassisMacTLV(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ChassisMacTLVConn) Flush() error {
	return c.w.Flush()
}

func (c *ChassisMacTLVConn) ReadChassisMacTLV() (ChassisMacTLV, error) {
	pkts := make([]ChassisMacTLV, 1)
	_, err := c.ReadChassisMacTLVs(pkts)
	if err != nil {
		return NewChassisMacTLV(), err
	}

	return pkts[0], nil
}

func (c *ChassisMacTLVConn) ReadChassisMacTLVs(pkts []ChassisMacTLV) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewChassisMacTLVWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ChassisMacTLV) Init() {
	this.ChassisTLV.Init()
	// Invariants.
	this.SetTypeAndLen(uint16(519)) // type_and_len
	this.SetSubtype(uint8(4))       // subtype
}

func (this ChassisMacTLV) Size() int {
	return 9
}

func ToChassisMacTLV(p ChassisTLV) (ChassisMacTLV, error) {
	if !IsChassisMacTLV(p) {
		return NewChassisMacTLVWithBuf(nil), errors.New("Cannot convert to lldp.ChassisMacTLV")
	}

	return NewChassisMacTLVWithBuf(p.Buf), nil
}

func IsChassisMacTLV(p ChassisTLV) bool {
	return p.TypeAndLen() == 519 && p.Subtype() == 4 && true
}

func (this ChassisMacTLV) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ChassisMacTLV) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this ChassisMacTLV) MacAddrOffset() int {
	offset := 3
	return offset
}
