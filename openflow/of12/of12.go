// Automatically generated by Packet Go code generator.
package of12

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"

	"github.com/packet/packet/src/go/packet"

	"github.com/soheilhy/beehive-netctrl/openflow/of"
)

type Ports int

const (
	PP_MAX        Ports = 4294967040
	PP_IN_PORT    Ports = 4294967288
	PP_TABLE      Ports = 4294967289
	PP_NORMAL     Ports = 4294967290
	PP_FLOOD      Ports = 4294967291
	PP_ALL        Ports = 4294967292
	PP_CONTROLLER Ports = 4294967293
	PP_LOCAL      Ports = 4294967294
	PP_ANY        Ports = 4294967295
)

type Type int

const (
	PT_PACKET_IN                Type = 10
	PT_FLOW_REMOVED             Type = 11
	PT_PORT_STATUS              Type = 12
	PT_PACKET_OUT               Type = 13
	PT_FLOW_MOD                 Type = 14
	PT_GROUP_MOD                Type = 15
	PT_PORT_MOD                 Type = 16
	PT_TABLE_MOD                Type = 17
	PT_STATS_REQUEST            Type = 18
	PT_STATS_REPLY              Type = 19
	PT_BARRIER_REQUEST          Type = 20
	PT_BARRIER_REPLY            Type = 21
	PT_QUEUE_GET_CONFIG_REQUEST Type = 22
	PT_QUEUE_GET_CONFIG_REPLY   Type = 23
	PT_ROLE_REQUEST             Type = 24
	PT_ROLE_REPLY               Type = 25
)

type ConfigFlags int

const (
	PC_FRAG_NORMAL               ConfigFlags = 0
	PC_FRAG_DROP                 ConfigFlags = 1
	PC_FRAG_REASM                ConfigFlags = 2
	PC_FRAG_MASK                 ConfigFlags = 3
	PC_INVALID_TTL_TO_CONTROLLER ConfigFlags = 4
)

type Capabilities int

const (
	PC_FLOW_STATS   Capabilities = 1
	PC_TABLE_STATS  Capabilities = 2
	PC_PORT_STATS   Capabilities = 4
	PC_STP          Capabilities = 8
	PC_RESERVED     Capabilities = 16
	PC_IP_REASM     Capabilities = 32
	PC_QUEUE_STATS  Capabilities = 64
	PC_ARP_MATCH_IP Capabilities = 128
)

type PortConfig int

const (
	PPC_PORT_DOWN    PortConfig = 1
	PPC_NO_RECV      PortConfig = 4
	PPC_NO_FWD       PortConfig = 32
	PPC_NO_PACKET_IN PortConfig = 64
)

type PortState int

const (
	PPS_LINK_DOWN PortState = 1
	PPS_BLOCKED   PortState = 2
	PPS_LIVE      PortState = 4
)

type PortFeatures int

const (
	PPF_10MB_HD    PortFeatures = 1
	PPF_10MB_FD    PortFeatures = 2
	PPF_100MB_HD   PortFeatures = 4
	PPF_100MB_FD   PortFeatures = 8
	PPF_1GB_HD     PortFeatures = 16
	PPF_1GB_FD     PortFeatures = 32
	PPF_10GB_FD    PortFeatures = 64
	PPF_40GB_FD    PortFeatures = 128
	PPF_100GB_FD   PortFeatures = 256
	PPF_1TB_FD     PortFeatures = 512
	PPF_OTHER      PortFeatures = 1024
	PPF_COPPER     PortFeatures = 2048
	PPF_FIBER      PortFeatures = 4096
	PPF_AUTONEG    PortFeatures = 8192
	PPF_PAUSE      PortFeatures = 16384
	PPF_PAUSE_ASYM PortFeatures = 32768
)

type PortReason int

const (
	PPR_ADD    PortReason = 0
	PPR_DELETE PortReason = 1
	PPR_MODIFY PortReason = 2
)

type PacketInReason int

const (
	PR_NO_MATCH PacketInReason = 0
	PR_ACTION   PacketInReason = 1
)

type ActionType int

const (
	PAT_OUTPUT       ActionType = 0
	PAT_COPY_TTL_OUT ActionType = 11
	PAT_COPY_TTL_IN  ActionType = 12
	PAT_SET_MPLS_TTL ActionType = 15
	PAT_DEC_MPLS_TTL ActionType = 16
	PAT_PUSH_VLAN    ActionType = 17
	PAT_POP_VLAN     ActionType = 18
	PAT_PUSH_MPLS    ActionType = 19
	PAT_POP_MPLS     ActionType = 20
	PAT_SET_QUEUE    ActionType = 21
	PAT_GROUP        ActionType = 22
	PAT_SET_NW_TTL   ActionType = 23
	PAT_DEC_NW_TTL   ActionType = 24
	PAT_SET_FIELD    ActionType = 25
	PAT_EXPERIMENTER ActionType = 65535
)

type InstructionType int

const (
	PIT_GOTO_TABLE     InstructionType = 1
	PIT_WRITE_METADATA InstructionType = 2
	PIT_WRITE_ACTIONS  InstructionType = 3
	PIT_APPLY_ACTIONS  InstructionType = 4
	PIT_CLEAR_ACTIONS  InstructionType = 5
	PIT_EXPERIMENTER   InstructionType = 65535
)

type Buffers int

const (
	P_NO_BUFFER Buffers = 4294967295
)

type FlowModCommand int

const (
	PFC_ADD           FlowModCommand = 0
	PFC_MODIFY        FlowModCommand = 1
	PFC_MODIFY_STRICT FlowModCommand = 2
	PFC_DELETE        FlowModCommand = 3
	PFC_DELETE_STRICT FlowModCommand = 4
)

type FlowWildcards int

const (
	PFW_IN_PORT      FlowWildcards = 1
	PFW_DL_VLAN      FlowWildcards = 2
	PFW_DL_SRC       FlowWildcards = 4
	PFW_DL_DST       FlowWildcards = 8
	PFW_DL_TYPE      FlowWildcards = 16
	PFW_NW_PROTO     FlowWildcards = 32
	PFW_TP_SRC       FlowWildcards = 64
	PFW_TP_DST       FlowWildcards = 128
	PFW_NW_SRC_SHIFT FlowWildcards = 8
	PFW_NW_SRC_BITS  FlowWildcards = 5
	PFW_NW_SRC_MASK  FlowWildcards = 8
	PFW_NW_SRC_ALL   FlowWildcards = 8
	PFW_NW_DST_SHIFT FlowWildcards = 14
	PFW_NW_DST_BITS  FlowWildcards = 6
	PFW_NW_DST_MASK  FlowWildcards = 14
	PFW_NW_DST_ALL   FlowWildcards = 14
	PFW_DL_VLAN_PCP  FlowWildcards = 1048576
	PFW_NW_TOS       FlowWildcards = 2097152
	PFW_ALL          FlowWildcards = 4194303
)

type MatchType int

const (
	PMT_STANDARD MatchType = 0
	PMT_OXM      MatchType = 1
)

type OxmClass int

const (
	PXMC_NXM_0          OxmClass = 0
	PXMC_NXM_1          OxmClass = 1
	PXMC_OPENFLOW_BASIC OxmClass = 32768
	PXMC_EXPERIMENTER   OxmClass = 65535
)

type OxmMatchFields int

const (
	PXMT_B_IN_PORT         OxmMatchFields = 0
	PXMT_B_IN_PHY_PORT     OxmMatchFields = 2
	PXMT_B_METADATA        OxmMatchFields = 4
	PXMT_B_ETH_DST         OxmMatchFields = 6
	PXMT_B_ETH_DST_MASKED  OxmMatchFields = 7
	PXMT_B_ETH_SRC         OxmMatchFields = 8
	PXMT_B_ETH_SRC_MASKED  OxmMatchFields = 9
	PXMT_B_ETH_TYPE        OxmMatchFields = 10
	PXMT_B_VLAN_VID        OxmMatchFields = 12
	PXMT_B_VLAN_PCP        OxmMatchFields = 14
	PXMT_B_IP_DSCP         OxmMatchFields = 16
	PXMT_B_IP_ECN          OxmMatchFields = 18
	PXMT_B_IP_PROTO        OxmMatchFields = 20
	PXMT_B_IPV4_SRC        OxmMatchFields = 22
	PXMT_B_IPV4_SRC_MASKED OxmMatchFields = 23
	PXMT_B_IPV4_DST        OxmMatchFields = 24
	PXMT_B_IPV4_DST_MASKED OxmMatchFields = 25
	PXMT_B_TCP_SRC         OxmMatchFields = 26
	PXMT_B_TCP_DST         OxmMatchFields = 28
	PXMT_B_UDP_SRC         OxmMatchFields = 30
	PXMT_B_UDP_DST         OxmMatchFields = 32
	PXMT_B_SCTP_SRC        OxmMatchFields = 34
	PXMT_B_SCTP_DST        OxmMatchFields = 36
	PXMT_B_ICMPV4_TYPE     OxmMatchFields = 38
	PXMT_B_ICMPV4_CODE     OxmMatchFields = 40
	PXMT_B_ARP_OP          OxmMatchFields = 42
	PXMT_B_ARP_SPA         OxmMatchFields = 44
	PXMT_B_ARP_TPA         OxmMatchFields = 46
	PXMT_B_ARP_SHA         OxmMatchFields = 48
	PXMT_B_ARP_THA         OxmMatchFields = 50
	PXMT_B_IPV6_SRC        OxmMatchFields = 52
	PXMT_B_IPV6_DST        OxmMatchFields = 54
	PXMT_B_IPV6_FLABEL     OxmMatchFields = 56
	PXMT_B_ICMPV6_TYPE     OxmMatchFields = 58
	PXMT_B_ICMPV6_CODE     OxmMatchFields = 60
	PXMT_B_IPV6_ND_TARGET  OxmMatchFields = 62
	PXMT_B_IPV6_ND_SLL     OxmMatchFields = 64
	PXMT_B_IPV6_ND_TLL     OxmMatchFields = 66
	PXMT_B_MPLS_LABEL      OxmMatchFields = 68
	PXMT_B_MPLS_TC         OxmMatchFields = 70
)

type FlowModFlags int

const (
	PFF_SEND_FLOW_REM FlowModFlags = 1
	PFF_CHECK_OVERLAP FlowModFlags = 2
	PFF_EMERG         FlowModFlags = 4
)

type FlowRemovedReason int

const (
	PRR_IDLE_TIMEOUT FlowRemovedReason = 0
	PRR_HARD_TIMEOUT FlowRemovedReason = 1
	PRR_DELETE       FlowRemovedReason = 2
)

type ErrorType int

const (
	PET_HELLO_FAILED    ErrorType = 0
	PET_BAD_REQUEST     ErrorType = 1
	PET_BAD_ACTION      ErrorType = 2
	PET_FLOW_MOD_FAILED ErrorType = 3
	PET_PORT_MOD_FAILED ErrorType = 4
	PET_QUEUE_OP_FAILED ErrorType = 5
)

type HelloFailedCode int

const (
	PHFC_INCOMPATIBLE HelloFailedCode = 0
	PHFC_EPERM        HelloFailedCode = 1
)

type BadRequestCode int

const (
	PBRC_BAD_VERSION    BadRequestCode = 0
	PBRC_BAD_TYPE       BadRequestCode = 1
	PBRC_BAD_STAT       BadRequestCode = 2
	PBRC_BAD_VENDOR     BadRequestCode = 3
	PBRC_BAD_SUBTYPE    BadRequestCode = 4
	PBRC_EPERM          BadRequestCode = 5
	PBRC_BAD_LEN        BadRequestCode = 6
	PBRC_BUFFER_EMPTY   BadRequestCode = 7
	PBRC_BUFFER_UNKNOWN BadRequestCode = 8
)

type BadActionCode int

const (
	PBAC_BAD_TYPE        BadActionCode = 0
	PBAC_BAD_LEN         BadActionCode = 1
	PBAC_BAD_VENDOR      BadActionCode = 2
	PBAC_BAD_VENDOR_TYPE BadActionCode = 3
	PBAC_BAD_OUT_PORT    BadActionCode = 4
	PBAC_BAD_ARGUMENT    BadActionCode = 5
	PBAC_EPERM           BadActionCode = 6
	PBAC_TOO_MANY        BadActionCode = 7
	PBAC_BAD_QUEUE       BadActionCode = 8
)

type Flow_modFailedCode int

const (
	PFMFC_ALL_TABLES_FULL   Flow_modFailedCode = 0
	PFMFC_OVERLAP           Flow_modFailedCode = 1
	PFMFC_EPERM             Flow_modFailedCode = 2
	PFMFC_BAD_EMERG_TIMEOUT Flow_modFailedCode = 3
	PFMFC_BAD_COMMAND       Flow_modFailedCode = 4
	PFMFC_UNSUPPORTED       Flow_modFailedCode = 5
)

type Port_modFailedCode int

const (
	PPMFC_BAD_PORT    Port_modFailedCode = 0
	PPMFC_BAD_HW_ADDR Port_modFailedCode = 1
)

type QueueOpFailedCode int

const (
	PQC_BAD_PORT  QueueOpFailedCode = 0
	PQC_BAD_QUEUE QueueOpFailedCode = 1
	PQC_EPERM     QueueOpFailedCode = 2
)

type StatsTypes int

const (
	PST_DESC      StatsTypes = 0
	PST_FLOW      StatsTypes = 1
	PST_AGGREGATE StatsTypes = 2
	PST_TABLE     StatsTypes = 3
	PST_PORT      StatsTypes = 4
	PST_QUEUE     StatsTypes = 5
	PST_VENDOR    StatsTypes = 65535
)

type StatsReplyFlags int

const (
	PSF_REPLY_MORE StatsReplyFlags = 1
)

type DescStatsConstants int

const (
	SERIAL_NUM_LEN DescStatsConstants = 32
	DESC_STR_LEN   DescStatsConstants = 256
)

type QueueProperties int

const (
	PQT_NONE     QueueProperties = 0
	PQT_MIN_RATE QueueProperties = 1
)

func NewHeader12WithBuf(b []byte) Header12 {
	return Header12{of.Header{packet.Packet{Buf: b}}}
}

func NewHeader12() Header12 {
	s := 8
	b := make([]byte, s)
	p := Header12{of.Header{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type Header12 struct {
	of.Header
}

func (this Header12) minSize() int {
	return 8
}

func (this Header12) Clone() (Header12, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewHeader12(), err
	}

	return NewHeader12WithBuf(newBuf.Bytes()), nil
}

type Header12Conn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewHeader12Conn(c net.Conn) Header12Conn {
	return Header12Conn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *Header12Conn) WriteHeader12(pkt Header12) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *Header12Conn) WriteHeader12s(pkts []Header12) error {
	for _, p := range pkts {
		if err := c.WriteHeader12(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *Header12Conn) ReadHeader12() (Header12, error) {
	pkts := make([]Header12, 1)
	_, err := c.ReadHeader12s(pkts)
	if err != nil {
		return NewHeader12(), err
	}

	return pkts[0], nil
}

func (c *Header12Conn) ReadHeader12s(pkts []Header12) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewHeader12WithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Header12) Init() {
	this.Header.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetVersion(uint8(3)) // version
}

func (this Header12) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToHeader12(p of.Header) (Header12, error) {
	if !IsHeader12(p) {
		return NewHeader12WithBuf(nil), errors.New("Cannot convert to of12.Header12")
	}

	return NewHeader12WithBuf(p.Buf), nil
}

func IsHeader12(p of.Header) bool {
	return p.Version() == 3 && true
}

func NewHelloWithBuf(b []byte) Hello {
	return Hello{of.Hello{of.Header{packet.Packet{Buf: b}}}}
}

func NewHello() Hello {
	s := 8
	b := make([]byte, s)
	p := Hello{of.Hello{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type Hello struct {
	of.Hello
}

func (this Hello) minSize() int {
	return 8
}

func (this Hello) Clone() (Hello, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewHello(), err
	}

	return NewHelloWithBuf(newBuf.Bytes()), nil
}

type HelloConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewHelloConn(c net.Conn) HelloConn {
	return HelloConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *HelloConn) WriteHello(pkt Hello) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *HelloConn) WriteHellos(pkts []Hello) error {
	for _, p := range pkts {
		if err := c.WriteHello(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *HelloConn) ReadHello() (Hello, error) {
	pkts := make([]Hello, 1)
	_, err := c.ReadHellos(pkts)
	if err != nil {
		return NewHello(), err
	}

	return pkts[0], nil
}

func (c *HelloConn) ReadHellos(pkts []Hello) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewHelloWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Hello) Init() {
	this.Hello.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetVersion(uint8(3)) // version
	this.SetType(uint8(0))    // type
}

func (this Hello) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToHello(p of.Hello) (Hello, error) {
	if !IsHello(p) {
		return NewHelloWithBuf(nil), errors.New("Cannot convert to of12.Hello")
	}

	return NewHelloWithBuf(p.Buf), nil
}

func IsHello(p of.Hello) bool {
	return p.Version() == 3 && true
}

func NewEchoRequestWithBuf(b []byte) EchoRequest {
	return EchoRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewEchoRequest() EchoRequest {
	s := 8
	b := make([]byte, s)
	p := EchoRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type EchoRequest struct {
	Header12
}

func (this EchoRequest) minSize() int {
	return 8
}

func (this EchoRequest) Clone() (EchoRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEchoRequest(), err
	}

	return NewEchoRequestWithBuf(newBuf.Bytes()), nil
}

type EchoRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewEchoRequestConn(c net.Conn) EchoRequestConn {
	return EchoRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EchoRequestConn) WriteEchoRequest(pkt EchoRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *EchoRequestConn) WriteEchoRequests(pkts []EchoRequest) error {
	for _, p := range pkts {
		if err := c.WriteEchoRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *EchoRequestConn) ReadEchoRequest() (EchoRequest, error) {
	pkts := make([]EchoRequest, 1)
	_, err := c.ReadEchoRequests(pkts)
	if err != nil {
		return NewEchoRequest(), err
	}

	return pkts[0], nil
}

func (c *EchoRequestConn) ReadEchoRequests(pkts []EchoRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEchoRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *EchoRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(2))    // type
	this.SetVersion(uint8(3)) // version
}

func (this EchoRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToEchoRequest(p Header12) (EchoRequest, error) {
	if !IsEchoRequest(p) {
		return NewEchoRequestWithBuf(nil), errors.New("Cannot convert to of12.EchoRequest")
	}

	return NewEchoRequestWithBuf(p.Buf), nil
}

func IsEchoRequest(p Header12) bool {
	return p.Type() == 2 && true
}

func NewEchoReplyWithBuf(b []byte) EchoReply {
	return EchoReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewEchoReply() EchoReply {
	s := 8
	b := make([]byte, s)
	p := EchoReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type EchoReply struct {
	Header12
}

func (this EchoReply) minSize() int {
	return 8
}

func (this EchoReply) Clone() (EchoReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEchoReply(), err
	}

	return NewEchoReplyWithBuf(newBuf.Bytes()), nil
}

type EchoReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewEchoReplyConn(c net.Conn) EchoReplyConn {
	return EchoReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EchoReplyConn) WriteEchoReply(pkt EchoReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *EchoReplyConn) WriteEchoReplys(pkts []EchoReply) error {
	for _, p := range pkts {
		if err := c.WriteEchoReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *EchoReplyConn) ReadEchoReply() (EchoReply, error) {
	pkts := make([]EchoReply, 1)
	_, err := c.ReadEchoReplys(pkts)
	if err != nil {
		return NewEchoReply(), err
	}

	return pkts[0], nil
}

func (c *EchoReplyConn) ReadEchoReplys(pkts []EchoReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEchoReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *EchoReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(3))    // type
	this.SetVersion(uint8(3)) // version
}

func (this EchoReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToEchoReply(p Header12) (EchoReply, error) {
	if !IsEchoReply(p) {
		return NewEchoReplyWithBuf(nil), errors.New("Cannot convert to of12.EchoReply")
	}

	return NewEchoReplyWithBuf(p.Buf), nil
}

func IsEchoReply(p Header12) bool {
	return p.Type() == 3 && true
}

func NewFeaturesRequestWithBuf(b []byte) FeaturesRequest {
	return FeaturesRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFeaturesRequest() FeaturesRequest {
	s := 8
	b := make([]byte, s)
	p := FeaturesRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FeaturesRequest struct {
	Header12
}

func (this FeaturesRequest) minSize() int {
	return 8
}

func (this FeaturesRequest) Clone() (FeaturesRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFeaturesRequest(), err
	}

	return NewFeaturesRequestWithBuf(newBuf.Bytes()), nil
}

type FeaturesRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFeaturesRequestConn(c net.Conn) FeaturesRequestConn {
	return FeaturesRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FeaturesRequestConn) WriteFeaturesRequest(pkt FeaturesRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FeaturesRequestConn) WriteFeaturesRequests(pkts []FeaturesRequest) error {
	for _, p := range pkts {
		if err := c.WriteFeaturesRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FeaturesRequestConn) ReadFeaturesRequest() (FeaturesRequest, error) {
	pkts := make([]FeaturesRequest, 1)
	_, err := c.ReadFeaturesRequests(pkts)
	if err != nil {
		return NewFeaturesRequest(), err
	}

	return pkts[0], nil
}

func (c *FeaturesRequestConn) ReadFeaturesRequests(pkts []FeaturesRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFeaturesRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FeaturesRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(5))    // type
	this.SetVersion(uint8(3)) // version
}

func (this FeaturesRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFeaturesRequest(p Header12) (FeaturesRequest, error) {
	if !IsFeaturesRequest(p) {
		return NewFeaturesRequestWithBuf(nil), errors.New("Cannot convert to of12.FeaturesRequest")
	}

	return NewFeaturesRequestWithBuf(p.Buf), nil
}

func IsFeaturesRequest(p Header12) bool {
	return p.Type() == 5 && true
}

func NewGetConfigRequestWithBuf(b []byte) GetConfigRequest {
	return GetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewGetConfigRequest() GetConfigRequest {
	s := 8
	b := make([]byte, s)
	p := GetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type GetConfigRequest struct {
	Header12
}

func (this GetConfigRequest) minSize() int {
	return 8
}

func (this GetConfigRequest) Clone() (GetConfigRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewGetConfigRequest(), err
	}

	return NewGetConfigRequestWithBuf(newBuf.Bytes()), nil
}

type GetConfigRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewGetConfigRequestConn(c net.Conn) GetConfigRequestConn {
	return GetConfigRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *GetConfigRequestConn) WriteGetConfigRequest(pkt GetConfigRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *GetConfigRequestConn) WriteGetConfigRequests(pkts []GetConfigRequest) error {
	for _, p := range pkts {
		if err := c.WriteGetConfigRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *GetConfigRequestConn) ReadGetConfigRequest() (GetConfigRequest, error) {
	pkts := make([]GetConfigRequest, 1)
	_, err := c.ReadGetConfigRequests(pkts)
	if err != nil {
		return NewGetConfigRequest(), err
	}

	return pkts[0], nil
}

func (c *GetConfigRequestConn) ReadGetConfigRequests(pkts []GetConfigRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewGetConfigRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *GetConfigRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(7))    // type
	this.SetVersion(uint8(3)) // version
}

func (this GetConfigRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToGetConfigRequest(p Header12) (GetConfigRequest, error) {
	if !IsGetConfigRequest(p) {
		return NewGetConfigRequestWithBuf(nil), errors.New("Cannot convert to of12.GetConfigRequest")
	}

	return NewGetConfigRequestWithBuf(p.Buf), nil
}

func IsGetConfigRequest(p Header12) bool {
	return p.Type() == 7 && true
}

func NewSwitchGetConfigReplyWithBuf(b []byte) SwitchGetConfigReply {
	return SwitchGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewSwitchGetConfigReply() SwitchGetConfigReply {
	s := 12
	b := make([]byte, s)
	p := SwitchGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type SwitchGetConfigReply struct {
	Header12
}

func (this SwitchGetConfigReply) minSize() int {
	return 12
}

func (this SwitchGetConfigReply) Clone() (SwitchGetConfigReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewSwitchGetConfigReply(), err
	}

	return NewSwitchGetConfigReplyWithBuf(newBuf.Bytes()), nil
}

type SwitchGetConfigReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewSwitchGetConfigReplyConn(c net.Conn) SwitchGetConfigReplyConn {
	return SwitchGetConfigReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *SwitchGetConfigReplyConn) WriteSwitchGetConfigReply(pkt SwitchGetConfigReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *SwitchGetConfigReplyConn) WriteSwitchGetConfigReplys(pkts []SwitchGetConfigReply) error {
	for _, p := range pkts {
		if err := c.WriteSwitchGetConfigReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *SwitchGetConfigReplyConn) ReadSwitchGetConfigReply() (SwitchGetConfigReply, error) {
	pkts := make([]SwitchGetConfigReply, 1)
	_, err := c.ReadSwitchGetConfigReplys(pkts)
	if err != nil {
		return NewSwitchGetConfigReply(), err
	}

	return pkts[0], nil
}

func (c *SwitchGetConfigReplyConn) ReadSwitchGetConfigReplys(pkts []SwitchGetConfigReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewSwitchGetConfigReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *SwitchGetConfigReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(8))    // type
	this.SetVersion(uint8(3)) // version
}

func (this SwitchGetConfigReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToSwitchGetConfigReply(p Header12) (SwitchGetConfigReply, error) {
	if !IsSwitchGetConfigReply(p) {
		return NewSwitchGetConfigReplyWithBuf(nil), errors.New("Cannot convert to of12.SwitchGetConfigReply")
	}

	return NewSwitchGetConfigReplyWithBuf(p.Buf), nil
}

func IsSwitchGetConfigReply(p Header12) bool {
	return p.Type() == 8 && true
}

func (this *SwitchGetConfigReply) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchGetConfigReply) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *SwitchGetConfigReply) FlagsOffset() int {
	offset := 8
	return offset
}

func (this *SwitchGetConfigReply) MissSendLen() uint16 {
	offset := this.MissSendLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchGetConfigReply) SetMissSendLen(m uint16) {
	offset := this.MissSendLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this *SwitchGetConfigReply) MissSendLenOffset() int {
	offset := 10
	return offset
}

func NewSwitchSetConfigWithBuf(b []byte) SwitchSetConfig {
	return SwitchSetConfig{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewSwitchSetConfig() SwitchSetConfig {
	s := 12
	b := make([]byte, s)
	p := SwitchSetConfig{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type SwitchSetConfig struct {
	Header12
}

func (this SwitchSetConfig) minSize() int {
	return 12
}

func (this SwitchSetConfig) Clone() (SwitchSetConfig, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewSwitchSetConfig(), err
	}

	return NewSwitchSetConfigWithBuf(newBuf.Bytes()), nil
}

type SwitchSetConfigConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewSwitchSetConfigConn(c net.Conn) SwitchSetConfigConn {
	return SwitchSetConfigConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *SwitchSetConfigConn) WriteSwitchSetConfig(pkt SwitchSetConfig) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *SwitchSetConfigConn) WriteSwitchSetConfigs(pkts []SwitchSetConfig) error {
	for _, p := range pkts {
		if err := c.WriteSwitchSetConfig(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *SwitchSetConfigConn) ReadSwitchSetConfig() (SwitchSetConfig, error) {
	pkts := make([]SwitchSetConfig, 1)
	_, err := c.ReadSwitchSetConfigs(pkts)
	if err != nil {
		return NewSwitchSetConfig(), err
	}

	return pkts[0], nil
}

func (c *SwitchSetConfigConn) ReadSwitchSetConfigs(pkts []SwitchSetConfig) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewSwitchSetConfigWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *SwitchSetConfig) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(9))    // type
	this.SetVersion(uint8(3)) // version
}

func (this SwitchSetConfig) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToSwitchSetConfig(p Header12) (SwitchSetConfig, error) {
	if !IsSwitchSetConfig(p) {
		return NewSwitchSetConfigWithBuf(nil), errors.New("Cannot convert to of12.SwitchSetConfig")
	}

	return NewSwitchSetConfigWithBuf(p.Buf), nil
}

func IsSwitchSetConfig(p Header12) bool {
	return p.Type() == 9 && true
}

func (this *SwitchSetConfig) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchSetConfig) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *SwitchSetConfig) FlagsOffset() int {
	offset := 8
	return offset
}

func (this *SwitchSetConfig) MissSendLen() uint16 {
	offset := this.MissSendLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchSetConfig) SetMissSendLen(m uint16) {
	offset := this.MissSendLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this *SwitchSetConfig) MissSendLenOffset() int {
	offset := 10
	return offset
}

func NewPortWithBuf(b []byte) Port {
	return Port{packet.Packet{Buf: b}}
}

func NewPort() Port {
	s := 64
	b := make([]byte, s)
	p := Port{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Port struct {
	packet.Packet
}

func (this Port) minSize() int {
	return 64
}

func (this Port) Clone() (Port, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPort(), err
	}

	return NewPortWithBuf(newBuf.Bytes()), nil
}

type PortConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortConn(c net.Conn) PortConn {
	return PortConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortConn) WritePort(pkt Port) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortConn) WritePorts(pkts []Port) error {
	for _, p := range pkts {
		if err := c.WritePort(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortConn) ReadPort() (Port, error) {
	pkts := make([]Port, 1)
	_, err := c.ReadPorts(pkts)
	if err != nil {
		return NewPort(), err
	}

	return pkts[0], nil
}

func (c *PortConn) ReadPorts(pkts []Port) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Port) Init() {
	// Invariants.
}

func (this Port) Size() int {
	return 64
}

func ToPort(p packet.Packet) (Port, error) {
	if !IsPort(p) {
		return NewPortWithBuf(nil), errors.New("Cannot convert to of12.Port")
	}

	return NewPortWithBuf(p.Buf), nil
}

func IsPort(p packet.Packet) bool {
	return true
}

func (this *Port) PortNo() uint32 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetPortNo(p uint32) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this *Port) PortNoOffset() int {
	offset := 0
	return offset
}

func (this *Port) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Port) PadOffset() int {
	offset := 4
	return offset
}

func (this *Port) HwAddr() [6]uint8 {
	offset := this.HwAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetHwAddr(h [6]uint8) {
	offset := this.HwAddrOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Port) HwAddrOffset() int {
	offset := 8
	return offset
}

func (this *Port) Pad2() [2]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetPad2(p [2]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Port) Pad2Offset() int {
	offset := 14
	return offset
}

func (this *Port) Name() [16]byte {
	offset := this.NameOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Port) SetName(n [16]byte) {
	offset := this.NameOffset()
	for _, e := range n {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Port) NameOffset() int {
	offset := 16
	return offset
}

func (this *Port) Config() uint32 {
	offset := this.ConfigOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetConfig(c uint32) {
	offset := this.ConfigOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *Port) ConfigOffset() int {
	offset := 32
	return offset
}

func (this *Port) State() uint32 {
	offset := this.StateOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetState(s uint32) {
	offset := this.StateOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], s)
	offset += 4
}

func (this *Port) StateOffset() int {
	offset := 36
	return offset
}

func (this *Port) Curr() uint32 {
	offset := this.CurrOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetCurr(c uint32) {
	offset := this.CurrOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *Port) CurrOffset() int {
	offset := 40
	return offset
}

func (this *Port) Advertised() uint32 {
	offset := this.AdvertisedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetAdvertised(a uint32) {
	offset := this.AdvertisedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *Port) AdvertisedOffset() int {
	offset := 44
	return offset
}

func (this *Port) Supported() uint32 {
	offset := this.SupportedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetSupported(s uint32) {
	offset := this.SupportedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], s)
	offset += 4
}

func (this *Port) SupportedOffset() int {
	offset := 48
	return offset
}

func (this *Port) Peer() uint32 {
	offset := this.PeerOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetPeer(p uint32) {
	offset := this.PeerOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this *Port) PeerOffset() int {
	offset := 52
	return offset
}

func (this *Port) CurrSpeed() uint32 {
	offset := this.CurrSpeedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetCurrSpeed(c uint32) {
	offset := this.CurrSpeedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *Port) CurrSpeedOffset() int {
	offset := 56
	return offset
}

func (this *Port) MaxSpeed() uint32 {
	offset := this.MaxSpeedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Port) SetMaxSpeed(m uint32) {
	offset := this.MaxSpeedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this *Port) MaxSpeedOffset() int {
	offset := 60
	return offset
}

func NewFeaturesReplyWithBuf(b []byte) FeaturesReply {
	return FeaturesReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFeaturesReply() FeaturesReply {
	s := 32
	b := make([]byte, s)
	p := FeaturesReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FeaturesReply struct {
	Header12
}

func (this FeaturesReply) minSize() int {
	return 32
}

func (this FeaturesReply) Clone() (FeaturesReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFeaturesReply(), err
	}

	return NewFeaturesReplyWithBuf(newBuf.Bytes()), nil
}

type FeaturesReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFeaturesReplyConn(c net.Conn) FeaturesReplyConn {
	return FeaturesReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FeaturesReplyConn) WriteFeaturesReply(pkt FeaturesReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FeaturesReplyConn) WriteFeaturesReplys(pkts []FeaturesReply) error {
	for _, p := range pkts {
		if err := c.WriteFeaturesReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FeaturesReplyConn) ReadFeaturesReply() (FeaturesReply, error) {
	pkts := make([]FeaturesReply, 1)
	_, err := c.ReadFeaturesReplys(pkts)
	if err != nil {
		return NewFeaturesReply(), err
	}

	return pkts[0], nil
}

func (c *FeaturesReplyConn) ReadFeaturesReplys(pkts []FeaturesReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFeaturesReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FeaturesReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(6))    // type
	this.SetVersion(uint8(3)) // version
}

func (this FeaturesReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFeaturesReply(p Header12) (FeaturesReply, error) {
	if !IsFeaturesReply(p) {
		return NewFeaturesReplyWithBuf(nil), errors.New("Cannot convert to of12.FeaturesReply")
	}

	return NewFeaturesReplyWithBuf(p.Buf), nil
}

func IsFeaturesReply(p Header12) bool {
	return p.Type() == 6 && true
}

func (this *FeaturesReply) DatapathId() uint64 {
	offset := this.DatapathIdOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetDatapathId(d uint64) {
	offset := this.DatapathIdOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], d)
	offset += 8
}

func (this *FeaturesReply) DatapathIdOffset() int {
	offset := 8
	return offset
}

func (this *FeaturesReply) NBuffers() uint32 {
	offset := this.NBuffersOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetNBuffers(n uint32) {
	offset := this.NBuffersOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this *FeaturesReply) NBuffersOffset() int {
	offset := 16
	return offset
}

func (this *FeaturesReply) NTables() uint8 {
	offset := this.NTablesOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FeaturesReply) SetNTables(n uint8) {
	offset := this.NTablesOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this *FeaturesReply) NTablesOffset() int {
	offset := 20
	return offset
}

func (this *FeaturesReply) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FeaturesReply) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FeaturesReply) PadOffset() int {
	offset := 21
	return offset
}

func (this *FeaturesReply) Capabilities() uint32 {
	offset := this.CapabilitiesOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetCapabilities(c uint32) {
	offset := this.CapabilitiesOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *FeaturesReply) CapabilitiesOffset() int {
	offset := 24
	return offset
}

func (this *FeaturesReply) Actions() uint32 {
	offset := this.ActionsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetActions(a uint32) {
	offset := this.ActionsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *FeaturesReply) ActionsOffset() int {
	offset := 28
	return offset
}

func (this *FeaturesReply) Ports() []Port {
	offset := this.PortsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Port
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewPortWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FeaturesReply) AddPorts(p Port) {
	offset := this.PortsOffset()
	offset += this.PortsSize()
	size := p.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], p.Buf[:p.Size()])
	offset += p.Size()
}

func (this *FeaturesReply) PortsOffset() int {
	offset := 32
	return offset
}

func (this *FeaturesReply) PortsSize() int {
	offset := this.PortsOffset()
	return this.Size() - offset
}

func NewPortStatusWithBuf(b []byte) PortStatus {
	return PortStatus{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPortStatus() PortStatus {
	s := 80
	b := make([]byte, s)
	p := PortStatus{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PortStatus struct {
	Header12
}

func (this PortStatus) minSize() int {
	return 80
}

func (this PortStatus) Clone() (PortStatus, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStatus(), err
	}

	return NewPortStatusWithBuf(newBuf.Bytes()), nil
}

type PortStatusConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortStatusConn(c net.Conn) PortStatusConn {
	return PortStatusConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatusConn) WritePortStatus(pkt PortStatus) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortStatusConn) WritePortStatuss(pkts []PortStatus) error {
	for _, p := range pkts {
		if err := c.WritePortStatus(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortStatusConn) ReadPortStatus() (PortStatus, error) {
	pkts := make([]PortStatus, 1)
	_, err := c.ReadPortStatuss(pkts)
	if err != nil {
		return NewPortStatus(), err
	}

	return pkts[0], nil
}

func (c *PortStatusConn) ReadPortStatuss(pkts []PortStatus) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatusWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortStatus) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(12))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PortStatus) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStatus(p Header12) (PortStatus, error) {
	if !IsPortStatus(p) {
		return NewPortStatusWithBuf(nil), errors.New("Cannot convert to of12.PortStatus")
	}

	return NewPortStatusWithBuf(p.Buf), nil
}

func IsPortStatus(p Header12) bool {
	return p.Type() == 12 && true
}

func (this *PortStatus) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PortStatus) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this *PortStatus) ReasonOffset() int {
	offset := 8
	return offset
}

func (this *PortStatus) Pad() [7]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 7
	i := 0
	var res [7]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStatus) SetPad(p [7]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortStatus) PadOffset() int {
	offset := 9
	return offset
}

func (this *PortStatus) Desc() Port {
	offset := this.DescOffset()
	res := NewPortWithBuf(this.Buf[offset:])
	return res
}

func (this *PortStatus) SetDesc(d Port) {
	offset := this.DescOffset()
	copy(this.Buf[offset:], d.Buf[:d.Size()])
	offset += d.Size()
}

func (this *PortStatus) DescOffset() int {
	offset := 16
	return offset
}

func NewPortModWithBuf(b []byte) PortMod {
	return PortMod{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPortMod() PortMod {
	s := 32
	b := make([]byte, s)
	p := PortMod{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PortMod struct {
	Header12
}

func (this PortMod) minSize() int {
	return 32
}

func (this PortMod) Clone() (PortMod, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortMod(), err
	}

	return NewPortModWithBuf(newBuf.Bytes()), nil
}

type PortModConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortModConn(c net.Conn) PortModConn {
	return PortModConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortModConn) WritePortMod(pkt PortMod) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortModConn) WritePortMods(pkts []PortMod) error {
	for _, p := range pkts {
		if err := c.WritePortMod(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortModConn) ReadPortMod() (PortMod, error) {
	pkts := make([]PortMod, 1)
	_, err := c.ReadPortMods(pkts)
	if err != nil {
		return NewPortMod(), err
	}

	return pkts[0], nil
}

func (c *PortModConn) ReadPortMods(pkts []PortMod) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortModWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortMod) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(16))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PortMod) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortMod(p Header12) (PortMod, error) {
	if !IsPortMod(p) {
		return NewPortModWithBuf(nil), errors.New("Cannot convert to of12.PortMod")
	}

	return NewPortModWithBuf(p.Buf), nil
}

func IsPortMod(p Header12) bool {
	return p.Type() == 16 && true
}

func (this *PortMod) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortMod) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PortMod) PortNoOffset() int {
	offset := 8
	return offset
}

func (this *PortMod) HwAddr() [6]uint8 {
	offset := this.HwAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortMod) SetHwAddr(h [6]uint8) {
	offset := this.HwAddrOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortMod) HwAddrOffset() int {
	offset := 10
	return offset
}

func (this *PortMod) Config() uint32 {
	offset := this.ConfigOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetConfig(c uint32) {
	offset := this.ConfigOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *PortMod) ConfigOffset() int {
	offset := 16
	return offset
}

func (this *PortMod) Mask() uint32 {
	offset := this.MaskOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetMask(m uint32) {
	offset := this.MaskOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this *PortMod) MaskOffset() int {
	offset := 20
	return offset
}

func (this *PortMod) Advertise() uint32 {
	offset := this.AdvertiseOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetAdvertise(a uint32) {
	offset := this.AdvertiseOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *PortMod) AdvertiseOffset() int {
	offset := 24
	return offset
}

func (this *PortMod) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortMod) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortMod) PadOffset() int {
	offset := 28
	return offset
}

func NewPacketInWithBuf(b []byte) PacketIn {
	return PacketIn{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPacketIn() PacketIn {
	s := 18
	b := make([]byte, s)
	p := PacketIn{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PacketIn struct {
	Header12
}

func (this PacketIn) minSize() int {
	return 18
}

func (this PacketIn) Clone() (PacketIn, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketIn(), err
	}

	return NewPacketInWithBuf(newBuf.Bytes()), nil
}

type PacketInConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPacketInConn(c net.Conn) PacketInConn {
	return PacketInConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketInConn) WritePacketIn(pkt PacketIn) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PacketInConn) WritePacketIns(pkts []PacketIn) error {
	for _, p := range pkts {
		if err := c.WritePacketIn(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PacketInConn) ReadPacketIn() (PacketIn, error) {
	pkts := make([]PacketIn, 1)
	_, err := c.ReadPacketIns(pkts)
	if err != nil {
		return NewPacketIn(), err
	}

	return pkts[0], nil
}

func (c *PacketInConn) ReadPacketIns(pkts []PacketIn) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketInWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PacketIn) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(10))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PacketIn) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPacketIn(p Header12) (PacketIn, error) {
	if !IsPacketIn(p) {
		return NewPacketInWithBuf(nil), errors.New("Cannot convert to of12.PacketIn")
	}

	return NewPacketInWithBuf(p.Buf), nil
}

func IsPacketIn(p Header12) bool {
	return p.Type() == 10 && true
}

func (this *PacketIn) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this *PacketIn) BufferIdOffset() int {
	offset := 8
	return offset
}

func (this *PacketIn) TotalLen() uint16 {
	offset := this.TotalLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetTotalLen(t uint16) {
	offset := this.TotalLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *PacketIn) TotalLenOffset() int {
	offset := 12
	return offset
}

func (this *PacketIn) InPort() uint16 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetInPort(i uint16) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *PacketIn) InPortOffset() int {
	offset := 14
	return offset
}

func (this *PacketIn) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PacketIn) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this *PacketIn) ReasonOffset() int {
	offset := 16
	return offset
}

func (this *PacketIn) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PacketIn) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *PacketIn) PadOffset() int {
	offset := 17
	return offset
}

func (this *PacketIn) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketIn) AddData(d uint8) {
	offset := this.DataOffset()
	offset += this.DataSize()
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this *PacketIn) DataOffset() int {
	offset := 18
	return offset
}

func (this *PacketIn) DataSize() int {
	offset := this.DataOffset()
	return this.Size() - offset
}

func NewActionWithBuf(b []byte) Action {
	return Action{packet.Packet{Buf: b}}
}

func NewAction() Action {
	s := 4
	b := make([]byte, s)
	p := Action{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Action struct {
	packet.Packet
}

func (this Action) minSize() int {
	return 4
}

func (this Action) Clone() (Action, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAction(), err
	}

	return NewActionWithBuf(newBuf.Bytes()), nil
}

type ActionConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionConn(c net.Conn) ActionConn {
	return ActionConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionConn) WriteAction(pkt Action) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ActionConn) WriteActions(pkts []Action) error {
	for _, p := range pkts {
		if err := c.WriteAction(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ActionConn) ReadAction() (Action, error) {
	pkts := make([]Action, 1)
	_, err := c.ReadActions(pkts)
	if err != nil {
		return NewAction(), err
	}

	return pkts[0], nil
}

func (c *ActionConn) ReadActions(pkts []Action) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Action) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this Action) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToAction(p packet.Packet) (Action, error) {
	if !IsAction(p) {
		return NewActionWithBuf(nil), errors.New("Cannot convert to of12.Action")
	}

	return NewActionWithBuf(p.Buf), nil
}

func IsAction(p packet.Packet) bool {
	return true
}

func (this *Action) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Action) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *Action) TypeOffset() int {
	offset := 0
	return offset
}

func (this *Action) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Action) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *Action) LenOffset() int {
	offset := 2
	return offset
}

func NewActionOutputWithBuf(b []byte) ActionOutput {
	return ActionOutput{Action{packet.Packet{Buf: b}}}
}

func NewActionOutput() ActionOutput {
	s := 16
	b := make([]byte, s)
	p := ActionOutput{Action{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionOutput struct {
	Action
}

func (this ActionOutput) minSize() int {
	return 16
}

func (this ActionOutput) Clone() (ActionOutput, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionOutput(), err
	}

	return NewActionOutputWithBuf(newBuf.Bytes()), nil
}

type ActionOutputConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionOutputConn(c net.Conn) ActionOutputConn {
	return ActionOutputConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionOutputConn) WriteActionOutput(pkt ActionOutput) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ActionOutputConn) WriteActionOutputs(pkts []ActionOutput) error {
	for _, p := range pkts {
		if err := c.WriteActionOutput(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ActionOutputConn) ReadActionOutput() (ActionOutput, error) {
	pkts := make([]ActionOutput, 1)
	_, err := c.ReadActionOutputs(pkts)
	if err != nil {
		return NewActionOutput(), err
	}

	return pkts[0], nil
}

func (c *ActionOutputConn) ReadActionOutputs(pkts []ActionOutput) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionOutputWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ActionOutput) Init() {
	this.Action.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(0)) // type
}

func (this ActionOutput) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionOutput(p Action) (ActionOutput, error) {
	if !IsActionOutput(p) {
		return NewActionOutputWithBuf(nil), errors.New("Cannot convert to of12.ActionOutput")
	}

	return NewActionOutputWithBuf(p.Buf), nil
}

func IsActionOutput(p Action) bool {
	return p.Type() == 0 && true
}

func (this *ActionOutput) Port() uint32 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *ActionOutput) SetPort(p uint32) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this *ActionOutput) PortOffset() int {
	offset := 4
	return offset
}

func (this *ActionOutput) MaxLen() uint16 {
	offset := this.MaxLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionOutput) SetMaxLen(m uint16) {
	offset := this.MaxLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this *ActionOutput) MaxLenOffset() int {
	offset := 8
	return offset
}

func (this *ActionOutput) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionOutput) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionOutput) PadOffset() int {
	offset := 10
	return offset
}

func NewInstructionWithBuf(b []byte) Instruction {
	return Instruction{packet.Packet{Buf: b}}
}

func NewInstruction() Instruction {
	s := 4
	b := make([]byte, s)
	p := Instruction{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Instruction struct {
	packet.Packet
}

func (this Instruction) minSize() int {
	return 4
}

func (this Instruction) Clone() (Instruction, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewInstruction(), err
	}

	return NewInstructionWithBuf(newBuf.Bytes()), nil
}

type InstructionConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewInstructionConn(c net.Conn) InstructionConn {
	return InstructionConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *InstructionConn) WriteInstruction(pkt Instruction) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *InstructionConn) WriteInstructions(pkts []Instruction) error {
	for _, p := range pkts {
		if err := c.WriteInstruction(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *InstructionConn) ReadInstruction() (Instruction, error) {
	pkts := make([]Instruction, 1)
	_, err := c.ReadInstructions(pkts)
	if err != nil {
		return NewInstruction(), err
	}

	return pkts[0], nil
}

func (c *InstructionConn) ReadInstructions(pkts []Instruction) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewInstructionWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Instruction) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this Instruction) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToInstruction(p packet.Packet) (Instruction, error) {
	if !IsInstruction(p) {
		return NewInstructionWithBuf(nil), errors.New("Cannot convert to of12.Instruction")
	}

	return NewInstructionWithBuf(p.Buf), nil
}

func IsInstruction(p packet.Packet) bool {
	return true
}

func (this *Instruction) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Instruction) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *Instruction) TypeOffset() int {
	offset := 0
	return offset
}

func (this *Instruction) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Instruction) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *Instruction) LenOffset() int {
	offset := 2
	return offset
}

func NewApplyActionsWithBuf(b []byte) ApplyActions {
	return ApplyActions{Instruction{packet.Packet{Buf: b}}}
}

func NewApplyActions() ApplyActions {
	s := 8
	b := make([]byte, s)
	p := ApplyActions{Instruction{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ApplyActions struct {
	Instruction
}

func (this ApplyActions) minSize() int {
	return 8
}

func (this ApplyActions) Clone() (ApplyActions, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewApplyActions(), err
	}

	return NewApplyActionsWithBuf(newBuf.Bytes()), nil
}

type ApplyActionsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewApplyActionsConn(c net.Conn) ApplyActionsConn {
	return ApplyActionsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ApplyActionsConn) WriteApplyActions(pkt ApplyActions) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ApplyActionsConn) WriteApplyActionss(pkts []ApplyActions) error {
	for _, p := range pkts {
		if err := c.WriteApplyActions(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ApplyActionsConn) ReadApplyActions() (ApplyActions, error) {
	pkts := make([]ApplyActions, 1)
	_, err := c.ReadApplyActionss(pkts)
	if err != nil {
		return NewApplyActions(), err
	}

	return pkts[0], nil
}

func (c *ApplyActionsConn) ReadApplyActionss(pkts []ApplyActions) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewApplyActionsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ApplyActions) Init() {
	this.Instruction.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(4)) // type
}

func (this ApplyActions) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToApplyActions(p Instruction) (ApplyActions, error) {
	if !IsApplyActions(p) {
		return NewApplyActionsWithBuf(nil), errors.New("Cannot convert to of12.ApplyActions")
	}

	return NewApplyActionsWithBuf(p.Buf), nil
}

func IsApplyActions(p Instruction) bool {
	return p.Type() == 4 && true
}

func (this *ApplyActions) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ApplyActions) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ApplyActions) PadOffset() int {
	offset := 4
	return offset
}

func (this *ApplyActions) Actions() []Action {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Action
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *ApplyActions) AddActions(a Action) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	this.OpenGap(offset, size)
	this.SetLen(uint16(this.Size() + size))
	copy(this.Buf[offset:], a.Buf[:a.Size()])
	offset += a.Size()
}

func (this *ApplyActions) ActionsOffset() int {
	offset := 8
	return offset
}

func (this *ApplyActions) ActionsSize() int {
	offset := this.ActionsOffset()
	return this.Size() - offset
}

func NewPacketOutWithBuf(b []byte) PacketOut {
	return PacketOut{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewPacketOut() PacketOut {
	s := 24
	b := make([]byte, s)
	p := PacketOut{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PacketOut struct {
	Header12
}

func (this PacketOut) minSize() int {
	return 24
}

func (this PacketOut) Clone() (PacketOut, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketOut(), err
	}

	return NewPacketOutWithBuf(newBuf.Bytes()), nil
}

type PacketOutConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPacketOutConn(c net.Conn) PacketOutConn {
	return PacketOutConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketOutConn) WritePacketOut(pkt PacketOut) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PacketOutConn) WritePacketOuts(pkts []PacketOut) error {
	for _, p := range pkts {
		if err := c.WritePacketOut(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PacketOutConn) ReadPacketOut() (PacketOut, error) {
	pkts := make([]PacketOut, 1)
	_, err := c.ReadPacketOuts(pkts)
	if err != nil {
		return NewPacketOut(), err
	}

	return pkts[0], nil
}

func (c *PacketOutConn) ReadPacketOuts(pkts []PacketOut) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketOutWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PacketOut) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(13))   // type
	this.SetVersion(uint8(3)) // version
}

func (this PacketOut) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPacketOut(p Header12) (PacketOut, error) {
	if !IsPacketOut(p) {
		return NewPacketOutWithBuf(nil), errors.New("Cannot convert to of12.PacketOut")
	}

	return NewPacketOutWithBuf(p.Buf), nil
}

func IsPacketOut(p Header12) bool {
	return p.Type() == 13 && true
}

func (this *PacketOut) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this *PacketOut) BufferIdOffset() int {
	offset := 8
	return offset
}

func (this *PacketOut) InPort() uint32 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetInPort(i uint32) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], i)
	offset += 4
}

func (this *PacketOut) InPortOffset() int {
	offset := 12
	return offset
}

func (this *PacketOut) ActionsLen() uint16 {
	offset := this.ActionsLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetActionsLen(a uint16) {
	offset := this.ActionsLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], a)
	offset += 2
}

func (this *PacketOut) ActionsLenOffset() int {
	offset := 16
	return offset
}

func (this *PacketOut) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PacketOut) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PacketOut) PadOffset() int {
	offset := 18
	return offset
}

func (this *PacketOut) Actions() []Action {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := int(this.ActionsLen())
	count := this.Size() - offset
	var res []Action
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketOut) AddActions(a Action) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], a.Buf[:a.Size()])
	offset += a.Size()
	this.SetActionsLen(this.ActionsLen() + uint16(size))
}

func (this *PacketOut) ActionsOffset() int {
	offset := 24
	return offset
}

func (this *PacketOut) ActionsSize() int {
	return int(this.ActionsLen())
}

func (this *PacketOut) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketOut) AddData(d uint8) {
	offset := this.DataOffset()
	offset += this.DataSize()
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this *PacketOut) DataOffset() int {
	offset := 24
	offset += this.ActionsSize()
	return offset
}

func (this *PacketOut) DataSize() int {
	offset := this.DataOffset()
	return this.Size() - offset
}

func NewOxmFieldWithBuf(b []byte) OxmField {
	return OxmField{packet.Packet{Buf: b}}
}

func NewOxmField() OxmField {
	s := 4
	b := make([]byte, s)
	p := OxmField{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type OxmField struct {
	packet.Packet
}

func (this OxmField) minSize() int {
	return 4
}

func (this OxmField) Clone() (OxmField, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmField(), err
	}

	return NewOxmFieldWithBuf(newBuf.Bytes()), nil
}

type OxmFieldConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewOxmFieldConn(c net.Conn) OxmFieldConn {
	return OxmFieldConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmFieldConn) WriteOxmField(pkt OxmField) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmFieldConn) WriteOxmFields(pkts []OxmField) error {
	for _, p := range pkts {
		if err := c.WriteOxmField(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmFieldConn) ReadOxmField() (OxmField, error) {
	pkts := make([]OxmField, 1)
	_, err := c.ReadOxmFields(pkts)
	if err != nil {
		return NewOxmField(), err
	}

	return pkts[0], nil
}

func (c *OxmFieldConn) ReadOxmFields(pkts []OxmField) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmFieldWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmField) Init() {
	// Invariants.
}

func (this OxmField) Size() int {
	return 4
}

func ToOxmField(p packet.Packet) (OxmField, error) {
	if !IsOxmField(p) {
		return NewOxmFieldWithBuf(nil), errors.New("Cannot convert to of12.OxmField")
	}

	return NewOxmFieldWithBuf(p.Buf), nil
}

func IsOxmField(p packet.Packet) bool {
	return true
}

func (this *OxmField) OxmClass() uint16 {
	offset := this.OxmClassOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *OxmField) SetOxmClass(o uint16) {
	offset := this.OxmClassOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this *OxmField) OxmClassOffset() int {
	offset := 0
	return offset
}

func (this *OxmField) OxmField() uint8 {
	offset := this.OxmFieldOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *OxmField) SetOxmField(o uint8) {
	offset := this.OxmFieldOffset()
	this.Buf[offset] = byte(o)
	offset++
}

func (this *OxmField) OxmFieldOffset() int {
	offset := 2
	return offset
}

func (this *OxmField) OxmLength() uint8 {
	offset := this.OxmLengthOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *OxmField) SetOxmLength(o uint8) {
	offset := this.OxmLengthOffset()
	this.Buf[offset] = byte(o)
	offset++
}

func (this *OxmField) OxmLengthOffset() int {
	offset := 3
	return offset
}

func NewOxmInPortWithBuf(b []byte) OxmInPort {
	return OxmInPort{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmInPort() OxmInPort {
	s := 8
	b := make([]byte, s)
	p := OxmInPort{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmInPort struct {
	OxmField
}

func (this OxmInPort) minSize() int {
	return 8
}

func (this OxmInPort) Clone() (OxmInPort, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmInPort(), err
	}

	return NewOxmInPortWithBuf(newBuf.Bytes()), nil
}

type OxmInPortConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewOxmInPortConn(c net.Conn) OxmInPortConn {
	return OxmInPortConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmInPortConn) WriteOxmInPort(pkt OxmInPort) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmInPortConn) WriteOxmInPorts(pkts []OxmInPort) error {
	for _, p := range pkts {
		if err := c.WriteOxmInPort(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmInPortConn) ReadOxmInPort() (OxmInPort, error) {
	pkts := make([]OxmInPort, 1)
	_, err := c.ReadOxmInPorts(pkts)
	if err != nil {
		return NewOxmInPort(), err
	}

	return pkts[0], nil
}

func (c *OxmInPortConn) ReadOxmInPorts(pkts []OxmInPort) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmInPortWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmInPort) Init() {
	this.OxmField.Init()
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(0))      // oxm_field
	this.SetOxmLength(uint8(4))     // oxm_length
}

func (this OxmInPort) Size() int {
	return 8
}

func ToOxmInPort(p OxmField) (OxmInPort, error) {
	if !IsOxmInPort(p) {
		return NewOxmInPortWithBuf(nil), errors.New("Cannot convert to of12.OxmInPort")
	}

	return NewOxmInPortWithBuf(p.Buf), nil
}

func IsOxmInPort(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 0 && p.OxmLength() == 4 && true
}

func (this *OxmInPort) InPort() uint32 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *OxmInPort) SetInPort(i uint32) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], i)
	offset += 4
}

func (this *OxmInPort) InPortOffset() int {
	offset := 4
	return offset
}

func NewOxmEthDstWithBuf(b []byte) OxmEthDst {
	return OxmEthDst{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthDst() OxmEthDst {
	s := 10
	b := make([]byte, s)
	p := OxmEthDst{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthDst struct {
	OxmField
}

func (this OxmEthDst) minSize() int {
	return 10
}

func (this OxmEthDst) Clone() (OxmEthDst, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthDst(), err
	}

	return NewOxmEthDstWithBuf(newBuf.Bytes()), nil
}

type OxmEthDstConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewOxmEthDstConn(c net.Conn) OxmEthDstConn {
	return OxmEthDstConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthDstConn) WriteOxmEthDst(pkt OxmEthDst) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthDstConn) WriteOxmEthDsts(pkts []OxmEthDst) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthDst(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthDstConn) ReadOxmEthDst() (OxmEthDst, error) {
	pkts := make([]OxmEthDst, 1)
	_, err := c.ReadOxmEthDsts(pkts)
	if err != nil {
		return NewOxmEthDst(), err
	}

	return pkts[0], nil
}

func (c *OxmEthDstConn) ReadOxmEthDsts(pkts []OxmEthDst) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthDstWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthDst) Init() {
	this.OxmField.Init()
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(6))      // oxm_field
	this.SetOxmLength(uint8(6))     // oxm_length
}

func (this OxmEthDst) Size() int {
	return 10
}

func ToOxmEthDst(p OxmField) (OxmEthDst, error) {
	if !IsOxmEthDst(p) {
		return NewOxmEthDstWithBuf(nil), errors.New("Cannot convert to of12.OxmEthDst")
	}

	return NewOxmEthDstWithBuf(p.Buf), nil
}

func IsOxmEthDst(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 6 && p.OxmLength() == 6 && true
}

func (this *OxmEthDst) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthDst) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *OxmEthDst) MacAddrOffset() int {
	offset := 4
	return offset
}

func NewOxmEthDstMaskedWithBuf(b []byte) OxmEthDstMasked {
	return OxmEthDstMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthDstMasked() OxmEthDstMasked {
	s := 16
	b := make([]byte, s)
	p := OxmEthDstMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthDstMasked struct {
	OxmField
}

func (this OxmEthDstMasked) minSize() int {
	return 16
}

func (this OxmEthDstMasked) Clone() (OxmEthDstMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthDstMasked(), err
	}

	return NewOxmEthDstMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmEthDstMaskedConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewOxmEthDstMaskedConn(c net.Conn) OxmEthDstMaskedConn {
	return OxmEthDstMaskedConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthDstMaskedConn) WriteOxmEthDstMasked(pkt OxmEthDstMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthDstMaskedConn) WriteOxmEthDstMaskeds(pkts []OxmEthDstMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthDstMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthDstMaskedConn) ReadOxmEthDstMasked() (OxmEthDstMasked, error) {
	pkts := make([]OxmEthDstMasked, 1)
	_, err := c.ReadOxmEthDstMaskeds(pkts)
	if err != nil {
		return NewOxmEthDstMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmEthDstMaskedConn) ReadOxmEthDstMaskeds(pkts []OxmEthDstMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthDstMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthDstMasked) Init() {
	this.OxmField.Init()
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(7))      // oxm_field
	this.SetOxmLength(uint8(12))    // oxm_length
}

func (this OxmEthDstMasked) Size() int {
	return 16
}

func ToOxmEthDstMasked(p OxmField) (OxmEthDstMasked, error) {
	if !IsOxmEthDstMasked(p) {
		return NewOxmEthDstMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmEthDstMasked")
	}

	return NewOxmEthDstMaskedWithBuf(p.Buf), nil
}

func IsOxmEthDstMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 7 && p.OxmLength() == 12 && true
}

func (this *OxmEthDstMasked) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthDstMasked) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *OxmEthDstMasked) MacAddrOffset() int {
	offset := 4
	return offset
}

func (this *OxmEthDstMasked) Mask() [6]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthDstMasked) SetMask(m [6]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *OxmEthDstMasked) MaskOffset() int {
	offset := 10
	return offset
}

func NewOxmEthSrcWithBuf(b []byte) OxmEthSrc {
	return OxmEthSrc{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthSrc() OxmEthSrc {
	s := 10
	b := make([]byte, s)
	p := OxmEthSrc{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthSrc struct {
	OxmField
}

func (this OxmEthSrc) minSize() int {
	return 10
}

func (this OxmEthSrc) Clone() (OxmEthSrc, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthSrc(), err
	}

	return NewOxmEthSrcWithBuf(newBuf.Bytes()), nil
}

type OxmEthSrcConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewOxmEthSrcConn(c net.Conn) OxmEthSrcConn {
	return OxmEthSrcConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthSrcConn) WriteOxmEthSrc(pkt OxmEthSrc) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthSrcConn) WriteOxmEthSrcs(pkts []OxmEthSrc) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthSrc(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthSrcConn) ReadOxmEthSrc() (OxmEthSrc, error) {
	pkts := make([]OxmEthSrc, 1)
	_, err := c.ReadOxmEthSrcs(pkts)
	if err != nil {
		return NewOxmEthSrc(), err
	}

	return pkts[0], nil
}

func (c *OxmEthSrcConn) ReadOxmEthSrcs(pkts []OxmEthSrc) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthSrcWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthSrc) Init() {
	this.OxmField.Init()
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(8))      // oxm_field
	this.SetOxmLength(uint8(6))     // oxm_length
}

func (this OxmEthSrc) Size() int {
	return 10
}

func ToOxmEthSrc(p OxmField) (OxmEthSrc, error) {
	if !IsOxmEthSrc(p) {
		return NewOxmEthSrcWithBuf(nil), errors.New("Cannot convert to of12.OxmEthSrc")
	}

	return NewOxmEthSrcWithBuf(p.Buf), nil
}

func IsOxmEthSrc(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 8 && p.OxmLength() == 6 && true
}

func (this *OxmEthSrc) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthSrc) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *OxmEthSrc) MacAddrOffset() int {
	offset := 4
	return offset
}

func NewOxmEthSrcMaskedWithBuf(b []byte) OxmEthSrcMasked {
	return OxmEthSrcMasked{OxmField{packet.Packet{Buf: b}}}
}

func NewOxmEthSrcMasked() OxmEthSrcMasked {
	s := 16
	b := make([]byte, s)
	p := OxmEthSrcMasked{OxmField{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type OxmEthSrcMasked struct {
	OxmField
}

func (this OxmEthSrcMasked) minSize() int {
	return 16
}

func (this OxmEthSrcMasked) Clone() (OxmEthSrcMasked, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewOxmEthSrcMasked(), err
	}

	return NewOxmEthSrcMaskedWithBuf(newBuf.Bytes()), nil
}

type OxmEthSrcMaskedConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewOxmEthSrcMaskedConn(c net.Conn) OxmEthSrcMaskedConn {
	return OxmEthSrcMaskedConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *OxmEthSrcMaskedConn) WriteOxmEthSrcMasked(pkt OxmEthSrcMasked) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *OxmEthSrcMaskedConn) WriteOxmEthSrcMaskeds(pkts []OxmEthSrcMasked) error {
	for _, p := range pkts {
		if err := c.WriteOxmEthSrcMasked(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *OxmEthSrcMaskedConn) ReadOxmEthSrcMasked() (OxmEthSrcMasked, error) {
	pkts := make([]OxmEthSrcMasked, 1)
	_, err := c.ReadOxmEthSrcMaskeds(pkts)
	if err != nil {
		return NewOxmEthSrcMasked(), err
	}

	return pkts[0], nil
}

func (c *OxmEthSrcMaskedConn) ReadOxmEthSrcMaskeds(pkts []OxmEthSrcMasked) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewOxmEthSrcMaskedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *OxmEthSrcMasked) Init() {
	this.OxmField.Init()
	// Invariants.
	this.SetOxmClass(uint16(32768)) // oxm_class
	this.SetOxmField(uint8(9))      // oxm_field
	this.SetOxmLength(uint8(12))    // oxm_length
}

func (this OxmEthSrcMasked) Size() int {
	return 16
}

func ToOxmEthSrcMasked(p OxmField) (OxmEthSrcMasked, error) {
	if !IsOxmEthSrcMasked(p) {
		return NewOxmEthSrcMaskedWithBuf(nil), errors.New("Cannot convert to of12.OxmEthSrcMasked")
	}

	return NewOxmEthSrcMaskedWithBuf(p.Buf), nil
}

func IsOxmEthSrcMasked(p OxmField) bool {
	return p.OxmClass() == 32768 && p.OxmField() == 9 && p.OxmLength() == 12 && true
}

func (this *OxmEthSrcMasked) MacAddr() [6]uint8 {
	offset := this.MacAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthSrcMasked) SetMacAddr(m [6]uint8) {
	offset := this.MacAddrOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *OxmEthSrcMasked) MacAddrOffset() int {
	offset := 4
	return offset
}

func (this *OxmEthSrcMasked) Mask() [6]uint8 {
	offset := this.MaskOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *OxmEthSrcMasked) SetMask(m [6]uint8) {
	offset := this.MaskOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *OxmEthSrcMasked) MaskOffset() int {
	offset := 10
	return offset
}

func NewMatchWithBuf(b []byte) Match {
	return Match{packet.Packet{Buf: b}}
}

func NewMatch() Match {
	s := packet.PaddedSize(4, 8)
	b := make([]byte, s)
	p := Match{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Match struct {
	packet.Packet
}

func (this Match) minSize() int {
	return 4
}

func (this Match) Clone() (Match, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewMatch(), err
	}

	return NewMatchWithBuf(newBuf.Bytes()), nil
}

type MatchConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewMatchConn(c net.Conn) MatchConn {
	return MatchConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *MatchConn) WriteMatch(pkt Match) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *MatchConn) WriteMatchs(pkts []Match) error {
	for _, p := range pkts {
		if err := c.WriteMatch(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *MatchConn) ReadMatch() (Match, error) {
	pkts := make([]Match, 1)
	_, err := c.ReadMatchs(pkts)
	if err != nil {
		return NewMatch(), err
	}

	return pkts[0], nil
}

func (c *MatchConn) ReadMatchs(pkts []Match) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewMatchWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Match) Init() {
	this.SetLength(uint16(this.minSize()))
	// Invariants.
}

func (this Match) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return packet.PaddedSize(size, 8)
}

func ToMatch(p packet.Packet) (Match, error) {
	if !IsMatch(p) {
		return NewMatchWithBuf(nil), errors.New("Cannot convert to of12.Match")
	}

	return NewMatchWithBuf(p.Buf), nil
}

func IsMatch(p packet.Packet) bool {
	return true
}

func (this *Match) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *Match) TypeOffset() int {
	offset := 0
	return offset
}

func (this *Match) Length() uint16 {
	offset := this.LengthOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetLength(l uint16) {
	offset := this.LengthOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *Match) LengthOffset() int {
	offset := 2
	return offset
}

func (this *Match) OxmFields() []OxmField {
	offset := this.OxmFieldsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []OxmField
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewOxmFieldWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *Match) AddOxmFields(o OxmField) {
	offset := this.OxmFieldsOffset()
	offset += this.OxmFieldsSize()
	size := o.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], o.Buf[:o.Size()])
	offset += o.Size()
}

func (this *Match) OxmFieldsOffset() int {
	offset := 4
	return offset
}

func (this *Match) OxmFieldsSize() int {
	offset := this.OxmFieldsOffset()
	return this.Size() - offset
}

func NewFlowModWithBuf(b []byte) FlowMod {
	return FlowMod{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFlowMod() FlowMod {
	s := 48
	b := make([]byte, s)
	p := FlowMod{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FlowMod struct {
	Header12
}

func (this FlowMod) minSize() int {
	return 48
}

func (this FlowMod) Clone() (FlowMod, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowMod(), err
	}

	return NewFlowModWithBuf(newBuf.Bytes()), nil
}

type FlowModConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowModConn(c net.Conn) FlowModConn {
	return FlowModConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowModConn) WriteFlowMod(pkt FlowMod) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowModConn) WriteFlowMods(pkts []FlowMod) error {
	for _, p := range pkts {
		if err := c.WriteFlowMod(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowModConn) ReadFlowMod() (FlowMod, error) {
	pkts := make([]FlowMod, 1)
	_, err := c.ReadFlowMods(pkts)
	if err != nil {
		return NewFlowMod(), err
	}

	return pkts[0], nil
}

func (c *FlowModConn) ReadFlowMods(pkts []FlowMod) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowModWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowMod) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(14))   // type
	this.SetVersion(uint8(3)) // version
}

func (this FlowMod) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowMod(p Header12) (FlowMod, error) {
	if !IsFlowMod(p) {
		return NewFlowModWithBuf(nil), errors.New("Cannot convert to of12.FlowMod")
	}

	return NewFlowModWithBuf(p.Buf), nil
}

func IsFlowMod(p Header12) bool {
	return p.Type() == 14 && true
}

func (this *FlowMod) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowMod) CookieOffset() int {
	offset := 8
	return offset
}

func (this *FlowMod) CookieMask() uint64 {
	offset := this.CookieMaskOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetCookieMask(c uint64) {
	offset := this.CookieMaskOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowMod) CookieMaskOffset() int {
	offset := 16
	return offset
}

func (this *FlowMod) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowMod) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *FlowMod) TableIdOffset() int {
	offset := 24
	return offset
}

func (this *FlowMod) Command() uint8 {
	offset := this.CommandOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowMod) SetCommand(c uint8) {
	offset := this.CommandOffset()
	this.Buf[offset] = byte(c)
	offset++
}

func (this *FlowMod) CommandOffset() int {
	offset := 25
	return offset
}

func (this *FlowMod) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *FlowMod) IdleTimeoutOffset() int {
	offset := 26
	return offset
}

func (this *FlowMod) HardTimeout() uint16 {
	offset := this.HardTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetHardTimeout(h uint16) {
	offset := this.HardTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], h)
	offset += 2
}

func (this *FlowMod) HardTimeoutOffset() int {
	offset := 28
	return offset
}

func (this *FlowMod) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *FlowMod) PriorityOffset() int {
	offset := 30
	return offset
}

func (this *FlowMod) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this *FlowMod) BufferIdOffset() int {
	offset := 32
	return offset
}

func (this *FlowMod) OutPort() uint32 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetOutPort(o uint32) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], o)
	offset += 4
}

func (this *FlowMod) OutPortOffset() int {
	offset := 36
	return offset
}

func (this *FlowMod) OutGroup() uint32 {
	offset := this.OutGroupOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetOutGroup(o uint32) {
	offset := this.OutGroupOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], o)
	offset += 4
}

func (this *FlowMod) OutGroupOffset() int {
	offset := 40
	return offset
}

func (this *FlowMod) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *FlowMod) FlagsOffset() int {
	offset := 44
	return offset
}

func (this *FlowMod) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowMod) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowMod) PadOffset() int {
	offset := 46
	return offset
}

func (this *FlowMod) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	this.SetLength(uint16(this.Size() + size))
	this.OpenGap(offset, size)
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowMod) MatchOffset() int {
	offset := 48
	return offset
}

func (this *FlowMod) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this *FlowMod) Instructions() []Instruction {
	offset := this.InstructionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Instruction
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewInstructionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowMod) AddInstructions(i Instruction) {
	offset := this.InstructionsOffset()
	offset += this.InstructionsSize()
	size := i.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], i.Buf[:i.Size()])
	offset += i.Size()
}

func (this *FlowMod) InstructionsOffset() int {
	offset := 48
	offset += this.MatchSize()
	return offset
}

func (this *FlowMod) InstructionsSize() int {
	offset := this.InstructionsOffset()
	return this.Size() - offset
}

func NewFlowRemovedWithBuf(b []byte) FlowRemoved {
	return FlowRemoved{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewFlowRemoved() FlowRemoved {
	s := 48
	b := make([]byte, s)
	p := FlowRemoved{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FlowRemoved struct {
	Header12
}

func (this FlowRemoved) minSize() int {
	return 48
}

func (this FlowRemoved) Clone() (FlowRemoved, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowRemoved(), err
	}

	return NewFlowRemovedWithBuf(newBuf.Bytes()), nil
}

type FlowRemovedConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowRemovedConn(c net.Conn) FlowRemovedConn {
	return FlowRemovedConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowRemovedConn) WriteFlowRemoved(pkt FlowRemoved) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowRemovedConn) WriteFlowRemoveds(pkts []FlowRemoved) error {
	for _, p := range pkts {
		if err := c.WriteFlowRemoved(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowRemovedConn) ReadFlowRemoved() (FlowRemoved, error) {
	pkts := make([]FlowRemoved, 1)
	_, err := c.ReadFlowRemoveds(pkts)
	if err != nil {
		return NewFlowRemoved(), err
	}

	return pkts[0], nil
}

func (c *FlowRemovedConn) ReadFlowRemoveds(pkts []FlowRemoved) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowRemovedWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowRemoved) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(11))   // type
	this.SetVersion(uint8(3)) // version
}

func (this FlowRemoved) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowRemoved(p Header12) (FlowRemoved, error) {
	if !IsFlowRemoved(p) {
		return NewFlowRemovedWithBuf(nil), errors.New("Cannot convert to of12.FlowRemoved")
	}

	return NewFlowRemovedWithBuf(p.Buf), nil
}

func IsFlowRemoved(p Header12) bool {
	return p.Type() == 11 && true
}

func (this *FlowRemoved) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	this.SetLength(uint16(this.Size() + size))
	this.OpenGap(offset, size)
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowRemoved) MatchOffset() int {
	offset := 8
	return offset
}

func (this *FlowRemoved) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this *FlowRemoved) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowRemoved) CookieOffset() int {
	offset := 8
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *FlowRemoved) PriorityOffset() int {
	offset := 16
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowRemoved) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this *FlowRemoved) ReasonOffset() int {
	offset := 18
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) Pad() [1]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 1
	i := 0
	var res [1]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowRemoved) SetPad(p [1]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowRemoved) PadOffset() int {
	offset := 19
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) DurationSec() uint32 {
	offset := this.DurationSecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetDurationSec(d uint32) {
	offset := this.DurationSecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowRemoved) DurationSecOffset() int {
	offset := 20
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) DurationNsec() uint32 {
	offset := this.DurationNsecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetDurationNsec(d uint32) {
	offset := this.DurationNsecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowRemoved) DurationNsecOffset() int {
	offset := 24
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *FlowRemoved) IdleTimeoutOffset() int {
	offset := 28
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) Pad2() [2]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowRemoved) SetPad2(p [2]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowRemoved) Pad2Offset() int {
	offset := 30
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this *FlowRemoved) PacketCountOffset() int {
	offset := 32
	offset += this.MatchSize()
	return offset
}

func (this *FlowRemoved) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this *FlowRemoved) ByteCountOffset() int {
	offset := 40
	offset += this.MatchSize()
	return offset
}

func NewErrorMsgWithBuf(b []byte) ErrorMsg {
	return ErrorMsg{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewErrorMsg() ErrorMsg {
	s := 12
	b := make([]byte, s)
	p := ErrorMsg{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type ErrorMsg struct {
	Header12
}

func (this ErrorMsg) minSize() int {
	return 12
}

func (this ErrorMsg) Clone() (ErrorMsg, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewErrorMsg(), err
	}

	return NewErrorMsgWithBuf(newBuf.Bytes()), nil
}

type ErrorMsgConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewErrorMsgConn(c net.Conn) ErrorMsgConn {
	return ErrorMsgConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ErrorMsgConn) WriteErrorMsg(pkt ErrorMsg) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *ErrorMsgConn) WriteErrorMsgs(pkts []ErrorMsg) error {
	for _, p := range pkts {
		if err := c.WriteErrorMsg(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *ErrorMsgConn) ReadErrorMsg() (ErrorMsg, error) {
	pkts := make([]ErrorMsg, 1)
	_, err := c.ReadErrorMsgs(pkts)
	if err != nil {
		return NewErrorMsg(), err
	}

	return pkts[0], nil
}

func (c *ErrorMsgConn) ReadErrorMsgs(pkts []ErrorMsg) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewErrorMsgWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *ErrorMsg) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(1))    // type
	this.SetVersion(uint8(3)) // version
}

func (this ErrorMsg) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToErrorMsg(p Header12) (ErrorMsg, error) {
	if !IsErrorMsg(p) {
		return NewErrorMsgWithBuf(nil), errors.New("Cannot convert to of12.ErrorMsg")
	}

	return NewErrorMsgWithBuf(p.Buf), nil
}

func IsErrorMsg(p Header12) bool {
	return p.Type() == 1 && true
}

func (this *ErrorMsg) ErrType() uint16 {
	offset := this.ErrTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ErrorMsg) SetErrType(e uint16) {
	offset := this.ErrTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], e)
	offset += 2
}

func (this *ErrorMsg) ErrTypeOffset() int {
	offset := 8
	return offset
}

func (this *ErrorMsg) Code() uint16 {
	offset := this.CodeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ErrorMsg) SetCode(c uint16) {
	offset := this.CodeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], c)
	offset += 2
}

func (this *ErrorMsg) CodeOffset() int {
	offset := 10
	return offset
}

func (this *ErrorMsg) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *ErrorMsg) AddData(d uint8) {
	offset := this.DataOffset()
	offset += this.DataSize()
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this *ErrorMsg) DataOffset() int {
	offset := 12
	return offset
}

func (this *ErrorMsg) DataSize() int {
	offset := this.DataOffset()
	return this.Size() - offset
}

func NewStatsRequestWithBuf(b []byte) StatsRequest {
	return StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewStatsRequest() StatsRequest {
	s := 12
	b := make([]byte, s)
	p := StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type StatsRequest struct {
	Header12
}

func (this StatsRequest) minSize() int {
	return 12
}

func (this StatsRequest) Clone() (StatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStatsRequest(), err
	}

	return NewStatsRequestWithBuf(newBuf.Bytes()), nil
}

type StatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewStatsRequestConn(c net.Conn) StatsRequestConn {
	return StatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StatsRequestConn) WriteStatsRequest(pkt StatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *StatsRequestConn) WriteStatsRequests(pkts []StatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *StatsRequestConn) ReadStatsRequest() (StatsRequest, error) {
	pkts := make([]StatsRequest, 1)
	_, err := c.ReadStatsRequests(pkts)
	if err != nil {
		return NewStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *StatsRequestConn) ReadStatsRequests(pkts []StatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *StatsRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(18))   // type
	this.SetVersion(uint8(3)) // version
}

func (this StatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToStatsRequest(p Header12) (StatsRequest, error) {
	if !IsStatsRequest(p) {
		return NewStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.StatsRequest")
	}

	return NewStatsRequestWithBuf(p.Buf), nil
}

func IsStatsRequest(p Header12) bool {
	return p.Type() == 18 && true
}

func (this *StatsRequest) StatsType() uint16 {
	offset := this.StatsTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsRequest) SetStatsType(s uint16) {
	offset := this.StatsTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], s)
	offset += 2
}

func (this *StatsRequest) StatsTypeOffset() int {
	offset := 8
	return offset
}

func (this *StatsRequest) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsRequest) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *StatsRequest) FlagsOffset() int {
	offset := 10
	return offset
}

func NewStatsReplyWithBuf(b []byte) StatsReply {
	return StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewStatsReply() StatsReply {
	s := 12
	b := make([]byte, s)
	p := StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type StatsReply struct {
	Header12
}

func (this StatsReply) minSize() int {
	return 12
}

func (this StatsReply) Clone() (StatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStatsReply(), err
	}

	return NewStatsReplyWithBuf(newBuf.Bytes()), nil
}

type StatsReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewStatsReplyConn(c net.Conn) StatsReplyConn {
	return StatsReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StatsReplyConn) WriteStatsReply(pkt StatsReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *StatsReplyConn) WriteStatsReplys(pkts []StatsReply) error {
	for _, p := range pkts {
		if err := c.WriteStatsReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *StatsReplyConn) ReadStatsReply() (StatsReply, error) {
	pkts := make([]StatsReply, 1)
	_, err := c.ReadStatsReplys(pkts)
	if err != nil {
		return NewStatsReply(), err
	}

	return pkts[0], nil
}

func (c *StatsReplyConn) ReadStatsReplys(pkts []StatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStatsReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *StatsReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(19))   // type
	this.SetVersion(uint8(3)) // version
}

func (this StatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToStatsReply(p Header12) (StatsReply, error) {
	if !IsStatsReply(p) {
		return NewStatsReplyWithBuf(nil), errors.New("Cannot convert to of12.StatsReply")
	}

	return NewStatsReplyWithBuf(p.Buf), nil
}

func IsStatsReply(p Header12) bool {
	return p.Type() == 19 && true
}

func (this *StatsReply) StatsType() uint16 {
	offset := this.StatsTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsReply) SetStatsType(s uint16) {
	offset := this.StatsTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], s)
	offset += 2
}

func (this *StatsReply) StatsTypeOffset() int {
	offset := 8
	return offset
}

func (this *StatsReply) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsReply) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *StatsReply) FlagsOffset() int {
	offset := 10
	return offset
}

func NewDescStatsWithBuf(b []byte) DescStats {
	return DescStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewDescStats() DescStats {
	s := 1068
	b := make([]byte, s)
	p := DescStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type DescStats struct {
	StatsReply
}

func (this DescStats) minSize() int {
	return 1068
}

func (this DescStats) Clone() (DescStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewDescStats(), err
	}

	return NewDescStatsWithBuf(newBuf.Bytes()), nil
}

type DescStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewDescStatsConn(c net.Conn) DescStatsConn {
	return DescStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *DescStatsConn) WriteDescStats(pkt DescStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *DescStatsConn) WriteDescStatss(pkts []DescStats) error {
	for _, p := range pkts {
		if err := c.WriteDescStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *DescStatsConn) ReadDescStats() (DescStats, error) {
	pkts := make([]DescStats, 1)
	_, err := c.ReadDescStatss(pkts)
	if err != nil {
		return NewDescStats(), err
	}

	return pkts[0], nil
}

func (c *DescStatsConn) ReadDescStatss(pkts []DescStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewDescStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *DescStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(0)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this DescStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToDescStats(p StatsReply) (DescStats, error) {
	if !IsDescStats(p) {
		return NewDescStatsWithBuf(nil), errors.New("Cannot convert to of12.DescStats")
	}

	return NewDescStatsWithBuf(p.Buf), nil
}

func IsDescStats(p StatsReply) bool {
	return p.StatsType() == 0 && true
}

func (this *DescStats) MfrDesc() [256]byte {
	offset := this.MfrDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetMfrDesc(m [256]byte) {
	offset := this.MfrDescOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) MfrDescOffset() int {
	offset := 12
	return offset
}

func (this *DescStats) HwDesc() [256]byte {
	offset := this.HwDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetHwDesc(h [256]byte) {
	offset := this.HwDescOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) HwDescOffset() int {
	offset := 268
	return offset
}

func (this *DescStats) SwDesc() [256]byte {
	offset := this.SwDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetSwDesc(s [256]byte) {
	offset := this.SwDescOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) SwDescOffset() int {
	offset := 524
	return offset
}

func (this *DescStats) SerialNum() [32]byte {
	offset := this.SerialNumOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 32
	i := 0
	var res [32]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetSerialNum(s [32]byte) {
	offset := this.SerialNumOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) SerialNumOffset() int {
	offset := 780
	return offset
}

func (this *DescStats) DpDesc() [256]byte {
	offset := this.DpDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetDpDesc(d [256]byte) {
	offset := this.DpDescOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) DpDescOffset() int {
	offset := 812
	return offset
}

func NewFlowStatsRequestWithBuf(b []byte) FlowStatsRequest {
	return FlowStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewFlowStatsRequest() FlowStatsRequest {
	s := 16
	b := make([]byte, s)
	p := FlowStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type FlowStatsRequest struct {
	StatsRequest
}

func (this FlowStatsRequest) minSize() int {
	return 16
}

func (this FlowStatsRequest) Clone() (FlowStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStatsRequest(), err
	}

	return NewFlowStatsRequestWithBuf(newBuf.Bytes()), nil
}

type FlowStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowStatsRequestConn(c net.Conn) FlowStatsRequestConn {
	return FlowStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsRequestConn) WriteFlowStatsRequest(pkt FlowStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowStatsRequestConn) WriteFlowStatsRequests(pkts []FlowStatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteFlowStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowStatsRequestConn) ReadFlowStatsRequest() (FlowStatsRequest, error) {
	pkts := make([]FlowStatsRequest, 1)
	_, err := c.ReadFlowStatsRequests(pkts)
	if err != nil {
		return NewFlowStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *FlowStatsRequestConn) ReadFlowStatsRequests(pkts []FlowStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(1)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this FlowStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStatsRequest(p StatsRequest) (FlowStatsRequest, error) {
	if !IsFlowStatsRequest(p) {
		return NewFlowStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.FlowStatsRequest")
	}

	return NewFlowStatsRequestWithBuf(p.Buf), nil
}

func IsFlowStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 1 && true
}

func (this *FlowStatsRequest) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	this.SetLength(uint16(this.Size() + size))
	this.OpenGap(offset, size)
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowStatsRequest) MatchOffset() int {
	offset := 12
	return offset
}

func (this *FlowStatsRequest) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this *FlowStatsRequest) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStatsRequest) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *FlowStatsRequest) TableIdOffset() int {
	offset := 12
	offset += this.MatchSize()
	return offset
}

func (this *FlowStatsRequest) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStatsRequest) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *FlowStatsRequest) PadOffset() int {
	offset := 13
	offset += this.MatchSize()
	return offset
}

func (this *FlowStatsRequest) OutPort() uint16 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetOutPort(o uint16) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this *FlowStatsRequest) OutPortOffset() int {
	offset := 14
	offset += this.MatchSize()
	return offset
}

func NewFlowStatsWithBuf(b []byte) FlowStats {
	return FlowStats{packet.Packet{Buf: b}}
}

func NewFlowStats() FlowStats {
	s := 48
	b := make([]byte, s)
	p := FlowStats{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type FlowStats struct {
	packet.Packet
}

func (this FlowStats) minSize() int {
	return 48
}

func (this FlowStats) Clone() (FlowStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStats(), err
	}

	return NewFlowStatsWithBuf(newBuf.Bytes()), nil
}

type FlowStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowStatsConn(c net.Conn) FlowStatsConn {
	return FlowStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsConn) WriteFlowStats(pkt FlowStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowStatsConn) WriteFlowStatss(pkts []FlowStats) error {
	for _, p := range pkts {
		if err := c.WriteFlowStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowStatsConn) ReadFlowStats() (FlowStats, error) {
	pkts := make([]FlowStats, 1)
	_, err := c.ReadFlowStatss(pkts)
	if err != nil {
		return NewFlowStats(), err
	}

	return pkts[0], nil
}

func (c *FlowStatsConn) ReadFlowStatss(pkts []FlowStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowStats) Init() {
	this.SetLength(uint16(this.minSize()))
	// Invariants.
}

func (this FlowStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStats(p packet.Packet) (FlowStats, error) {
	if !IsFlowStats(p) {
		return NewFlowStatsWithBuf(nil), errors.New("Cannot convert to of12.FlowStats")
	}

	return NewFlowStatsWithBuf(p.Buf), nil
}

func IsFlowStats(p packet.Packet) bool {
	return true
}

func (this *FlowStats) Length() uint16 {
	offset := this.LengthOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetLength(l uint16) {
	offset := this.LengthOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *FlowStats) LengthOffset() int {
	offset := 0
	return offset
}

func (this *FlowStats) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStats) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *FlowStats) TableIdOffset() int {
	offset := 2
	return offset
}

func (this *FlowStats) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStats) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *FlowStats) PadOffset() int {
	offset := 3
	return offset
}

func (this *FlowStats) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	this.SetLength(uint16(this.Size() + size))
	this.OpenGap(offset, size)
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowStats) MatchOffset() int {
	offset := 4
	return offset
}

func (this *FlowStats) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this *FlowStats) DurationSec() uint32 {
	offset := this.DurationSecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetDurationSec(d uint32) {
	offset := this.DurationSecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowStats) DurationSecOffset() int {
	offset := 4
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) DurationNsec() uint32 {
	offset := this.DurationNsecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetDurationNsec(d uint32) {
	offset := this.DurationNsecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowStats) DurationNsecOffset() int {
	offset := 8
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *FlowStats) PriorityOffset() int {
	offset := 12
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *FlowStats) IdleTimeoutOffset() int {
	offset := 14
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) HardTimeout() uint16 {
	offset := this.HardTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetHardTimeout(h uint16) {
	offset := this.HardTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], h)
	offset += 2
}

func (this *FlowStats) HardTimeoutOffset() int {
	offset := 16
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) Pad2() [6]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowStats) SetPad2(p [6]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowStats) Pad2Offset() int {
	offset := 18
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowStats) CookieOffset() int {
	offset := 24
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this *FlowStats) PacketCountOffset() int {
	offset := 32
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this *FlowStats) ByteCountOffset() int {
	offset := 40
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) Actions() []Action {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []Action
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowStats) AddActions(a Action) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], a.Buf[:a.Size()])
	offset += a.Size()
}

func (this *FlowStats) ActionsOffset() int {
	offset := 48
	offset += this.MatchSize()
	return offset
}

func (this *FlowStats) ActionsSize() int {
	offset := this.ActionsOffset()
	return this.Size() - offset
}

func NewFlowStatsReplyWithBuf(b []byte) FlowStatsReply {
	return FlowStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewFlowStatsReply() FlowStatsReply {
	s := 12
	b := make([]byte, s)
	p := FlowStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type FlowStatsReply struct {
	StatsReply
}

func (this FlowStatsReply) minSize() int {
	return 12
}

func (this FlowStatsReply) Clone() (FlowStatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStatsReply(), err
	}

	return NewFlowStatsReplyWithBuf(newBuf.Bytes()), nil
}

type FlowStatsReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowStatsReplyConn(c net.Conn) FlowStatsReplyConn {
	return FlowStatsReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsReplyConn) WriteFlowStatsReply(pkt FlowStatsReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *FlowStatsReplyConn) WriteFlowStatsReplys(pkts []FlowStatsReply) error {
	for _, p := range pkts {
		if err := c.WriteFlowStatsReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *FlowStatsReplyConn) ReadFlowStatsReply() (FlowStatsReply, error) {
	pkts := make([]FlowStatsReply, 1)
	_, err := c.ReadFlowStatsReplys(pkts)
	if err != nil {
		return NewFlowStatsReply(), err
	}

	return pkts[0], nil
}

func (c *FlowStatsReplyConn) ReadFlowStatsReplys(pkts []FlowStatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *FlowStatsReply) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(1)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this FlowStatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStatsReply(p StatsReply) (FlowStatsReply, error) {
	if !IsFlowStatsReply(p) {
		return NewFlowStatsReplyWithBuf(nil), errors.New("Cannot convert to of12.FlowStatsReply")
	}

	return NewFlowStatsReplyWithBuf(p.Buf), nil
}

func IsFlowStatsReply(p StatsReply) bool {
	return p.StatsType() == 1 && true
}

func (this *FlowStatsReply) FlowStats() []FlowStats {
	offset := this.FlowStatsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []FlowStats
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewFlowStatsWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowStatsReply) AddFlowStats(f FlowStats) {
	offset := this.FlowStatsOffset()
	offset += this.FlowStatsSize()
	size := f.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], f.Buf[:f.Size()])
	offset += f.Size()
}

func (this *FlowStatsReply) FlowStatsOffset() int {
	offset := 12
	return offset
}

func (this *FlowStatsReply) FlowStatsSize() int {
	offset := this.FlowStatsOffset()
	return this.Size() - offset
}

func NewAggregateStatsRequestWithBuf(b []byte) AggregateStatsRequest {
	return AggregateStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewAggregateStatsRequest() AggregateStatsRequest {
	s := 16
	b := make([]byte, s)
	p := AggregateStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type AggregateStatsRequest struct {
	StatsRequest
}

func (this AggregateStatsRequest) minSize() int {
	return 16
}

func (this AggregateStatsRequest) Clone() (AggregateStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAggregateStatsRequest(), err
	}

	return NewAggregateStatsRequestWithBuf(newBuf.Bytes()), nil
}

type AggregateStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewAggregateStatsRequestConn(c net.Conn) AggregateStatsRequestConn {
	return AggregateStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *AggregateStatsRequestConn) WriteAggregateStatsRequest(pkt AggregateStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *AggregateStatsRequestConn) WriteAggregateStatsRequests(pkts []AggregateStatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteAggregateStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *AggregateStatsRequestConn) ReadAggregateStatsRequest() (AggregateStatsRequest, error) {
	pkts := make([]AggregateStatsRequest, 1)
	_, err := c.ReadAggregateStatsRequests(pkts)
	if err != nil {
		return NewAggregateStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *AggregateStatsRequestConn) ReadAggregateStatsRequests(pkts []AggregateStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewAggregateStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *AggregateStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(2)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this AggregateStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToAggregateStatsRequest(p StatsRequest) (AggregateStatsRequest, error) {
	if !IsAggregateStatsRequest(p) {
		return NewAggregateStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.AggregateStatsRequest")
	}

	return NewAggregateStatsRequestWithBuf(p.Buf), nil
}

func IsAggregateStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 2 && true
}

func (this *AggregateStatsRequest) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *AggregateStatsRequest) SetMatch(m Match) {
	offset := this.MatchOffset()
	if this.MatchSize() != 0 {
		panic("Repeated field match is already set.")
	}
	size := m.Size()
	this.SetLength(uint16(this.Size() + size))
	this.OpenGap(offset, size)
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *AggregateStatsRequest) MatchOffset() int {
	offset := 12
	return offset
}

func (this *AggregateStatsRequest) MatchSize() int {
	offset := this.MatchOffset()
	if offset >= this.Size() {
		return 0
	}
	return this.Match().Size()
}

func (this *AggregateStatsRequest) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *AggregateStatsRequest) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *AggregateStatsRequest) TableIdOffset() int {
	offset := 12
	offset += this.MatchSize()
	return offset
}

func (this *AggregateStatsRequest) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *AggregateStatsRequest) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *AggregateStatsRequest) PadOffset() int {
	offset := 13
	offset += this.MatchSize()
	return offset
}

func (this *AggregateStatsRequest) OutPort() uint16 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *AggregateStatsRequest) SetOutPort(o uint16) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this *AggregateStatsRequest) OutPortOffset() int {
	offset := 14
	offset += this.MatchSize()
	return offset
}

func NewAggregateStatsReplyWithBuf(b []byte) AggregateStatsReply {
	return AggregateStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewAggregateStatsReply() AggregateStatsReply {
	s := 36
	b := make([]byte, s)
	p := AggregateStatsReply{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type AggregateStatsReply struct {
	StatsReply
}

func (this AggregateStatsReply) minSize() int {
	return 36
}

func (this AggregateStatsReply) Clone() (AggregateStatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAggregateStatsReply(), err
	}

	return NewAggregateStatsReplyWithBuf(newBuf.Bytes()), nil
}

type AggregateStatsReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewAggregateStatsReplyConn(c net.Conn) AggregateStatsReplyConn {
	return AggregateStatsReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *AggregateStatsReplyConn) WriteAggregateStatsReply(pkt AggregateStatsReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *AggregateStatsReplyConn) WriteAggregateStatsReplys(pkts []AggregateStatsReply) error {
	for _, p := range pkts {
		if err := c.WriteAggregateStatsReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *AggregateStatsReplyConn) ReadAggregateStatsReply() (AggregateStatsReply, error) {
	pkts := make([]AggregateStatsReply, 1)
	_, err := c.ReadAggregateStatsReplys(pkts)
	if err != nil {
		return NewAggregateStatsReply(), err
	}

	return pkts[0], nil
}

func (c *AggregateStatsReplyConn) ReadAggregateStatsReplys(pkts []AggregateStatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewAggregateStatsReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *AggregateStatsReply) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(2)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this AggregateStatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToAggregateStatsReply(p StatsReply) (AggregateStatsReply, error) {
	if !IsAggregateStatsReply(p) {
		return NewAggregateStatsReplyWithBuf(nil), errors.New("Cannot convert to of12.AggregateStatsReply")
	}

	return NewAggregateStatsReplyWithBuf(p.Buf), nil
}

func IsAggregateStatsReply(p StatsReply) bool {
	return p.StatsType() == 2 && true
}

func (this *AggregateStatsReply) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this *AggregateStatsReply) PacketCountOffset() int {
	offset := 12
	return offset
}

func (this *AggregateStatsReply) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this *AggregateStatsReply) ByteCountOffset() int {
	offset := 20
	return offset
}

func (this *AggregateStatsReply) FlowCount() uint32 {
	offset := this.FlowCountOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetFlowCount(f uint32) {
	offset := this.FlowCountOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], f)
	offset += 4
}

func (this *AggregateStatsReply) FlowCountOffset() int {
	offset := 28
	return offset
}

func (this *AggregateStatsReply) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *AggregateStatsReply) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *AggregateStatsReply) PadOffset() int {
	offset := 32
	return offset
}

func NewTableStatsWithBuf(b []byte) TableStats {
	return TableStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewTableStats() TableStats {
	s := 76
	b := make([]byte, s)
	p := TableStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type TableStats struct {
	StatsReply
}

func (this TableStats) minSize() int {
	return 76
}

func (this TableStats) Clone() (TableStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewTableStats(), err
	}

	return NewTableStatsWithBuf(newBuf.Bytes()), nil
}

type TableStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewTableStatsConn(c net.Conn) TableStatsConn {
	return TableStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *TableStatsConn) WriteTableStats(pkt TableStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *TableStatsConn) WriteTableStatss(pkts []TableStats) error {
	for _, p := range pkts {
		if err := c.WriteTableStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *TableStatsConn) ReadTableStats() (TableStats, error) {
	pkts := make([]TableStats, 1)
	_, err := c.ReadTableStatss(pkts)
	if err != nil {
		return NewTableStats(), err
	}

	return pkts[0], nil
}

func (c *TableStatsConn) ReadTableStatss(pkts []TableStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewTableStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *TableStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(3)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this TableStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToTableStats(p StatsReply) (TableStats, error) {
	if !IsTableStats(p) {
		return NewTableStatsWithBuf(nil), errors.New("Cannot convert to of12.TableStats")
	}

	return NewTableStatsWithBuf(p.Buf), nil
}

func IsTableStats(p StatsReply) bool {
	return p.StatsType() == 3 && true
}

func (this *TableStats) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *TableStats) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *TableStats) TableIdOffset() int {
	offset := 12
	return offset
}

func (this *TableStats) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *TableStats) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *TableStats) PadOffset() int {
	offset := 13
	return offset
}

func (this *TableStats) Name() [32]byte {
	offset := this.NameOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 32
	i := 0
	var res [32]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *TableStats) SetName(n [32]byte) {
	offset := this.NameOffset()
	for _, e := range n {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *TableStats) NameOffset() int {
	offset := 16
	return offset
}

func (this *TableStats) Wildcards() uint32 {
	offset := this.WildcardsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetWildcards(w uint32) {
	offset := this.WildcardsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], w)
	offset += 4
}

func (this *TableStats) WildcardsOffset() int {
	offset := 48
	return offset
}

func (this *TableStats) MaxEntries() uint32 {
	offset := this.MaxEntriesOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetMaxEntries(m uint32) {
	offset := this.MaxEntriesOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this *TableStats) MaxEntriesOffset() int {
	offset := 52
	return offset
}

func (this *TableStats) ActiveCount() uint32 {
	offset := this.ActiveCountOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetActiveCount(a uint32) {
	offset := this.ActiveCountOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *TableStats) ActiveCountOffset() int {
	offset := 56
	return offset
}

func (this *TableStats) LookupCount() uint64 {
	offset := this.LookupCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *TableStats) SetLookupCount(l uint64) {
	offset := this.LookupCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], l)
	offset += 8
}

func (this *TableStats) LookupCountOffset() int {
	offset := 60
	return offset
}

func (this *TableStats) MatchedCount() uint64 {
	offset := this.MatchedCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *TableStats) SetMatchedCount(m uint64) {
	offset := this.MatchedCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], m)
	offset += 8
}

func (this *TableStats) MatchedCountOffset() int {
	offset := 68
	return offset
}

func NewPortStatsRequestWithBuf(b []byte) PortStatsRequest {
	return PortStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewPortStatsRequest() PortStatsRequest {
	s := 20
	b := make([]byte, s)
	p := PortStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type PortStatsRequest struct {
	StatsRequest
}

func (this PortStatsRequest) minSize() int {
	return 20
}

func (this PortStatsRequest) Clone() (PortStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStatsRequest(), err
	}

	return NewPortStatsRequestWithBuf(newBuf.Bytes()), nil
}

type PortStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortStatsRequestConn(c net.Conn) PortStatsRequestConn {
	return PortStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatsRequestConn) WritePortStatsRequest(pkt PortStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortStatsRequestConn) WritePortStatsRequests(pkts []PortStatsRequest) error {
	for _, p := range pkts {
		if err := c.WritePortStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortStatsRequestConn) ReadPortStatsRequest() (PortStatsRequest, error) {
	pkts := make([]PortStatsRequest, 1)
	_, err := c.ReadPortStatsRequests(pkts)
	if err != nil {
		return NewPortStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *PortStatsRequestConn) ReadPortStatsRequests(pkts []PortStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(4)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this PortStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStatsRequest(p StatsRequest) (PortStatsRequest, error) {
	if !IsPortStatsRequest(p) {
		return NewPortStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.PortStatsRequest")
	}

	return NewPortStatsRequestWithBuf(p.Buf), nil
}

func IsPortStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 4 && true
}

func (this *PortStatsRequest) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortStatsRequest) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PortStatsRequest) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *PortStatsRequest) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStatsRequest) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortStatsRequest) PadOffset() int {
	offset := 14
	return offset
}

func NewPortStatsWithBuf(b []byte) PortStats {
	return PortStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewPortStats() PortStats {
	s := 116
	b := make([]byte, s)
	p := PortStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type PortStats struct {
	StatsReply
}

func (this PortStats) minSize() int {
	return 116
}

func (this PortStats) Clone() (PortStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStats(), err
	}

	return NewPortStatsWithBuf(newBuf.Bytes()), nil
}

type PortStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortStatsConn(c net.Conn) PortStatsConn {
	return PortStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatsConn) WritePortStats(pkt PortStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PortStatsConn) WritePortStatss(pkts []PortStats) error {
	for _, p := range pkts {
		if err := c.WritePortStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PortStatsConn) ReadPortStats() (PortStats, error) {
	pkts := make([]PortStats, 1)
	_, err := c.ReadPortStatss(pkts)
	if err != nil {
		return NewPortStats(), err
	}

	return pkts[0], nil
}

func (c *PortStatsConn) ReadPortStatss(pkts []PortStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PortStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(4)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this PortStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStats(p StatsReply) (PortStats, error) {
	if !IsPortStats(p) {
		return NewPortStatsWithBuf(nil), errors.New("Cannot convert to of12.PortStats")
	}

	return NewPortStatsWithBuf(p.Buf), nil
}

func IsPortStats(p StatsReply) bool {
	return p.StatsType() == 4 && true
}

func (this *PortStats) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortStats) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PortStats) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *PortStats) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStats) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortStats) PadOffset() int {
	offset := 14
	return offset
}

func (this *PortStats) RxPackets() uint64 {
	offset := this.RxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxPackets(r uint64) {
	offset := this.RxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxPacketsOffset() int {
	offset := 20
	return offset
}

func (this *PortStats) TxPackets() uint64 {
	offset := this.TxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxPackets(t uint64) {
	offset := this.TxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxPacketsOffset() int {
	offset := 28
	return offset
}

func (this *PortStats) RxBytes() uint64 {
	offset := this.RxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxBytes(r uint64) {
	offset := this.RxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxBytesOffset() int {
	offset := 36
	return offset
}

func (this *PortStats) TxBytes() uint64 {
	offset := this.TxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxBytes(t uint64) {
	offset := this.TxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxBytesOffset() int {
	offset := 44
	return offset
}

func (this *PortStats) RxDropped() uint64 {
	offset := this.RxDroppedOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxDropped(r uint64) {
	offset := this.RxDroppedOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxDroppedOffset() int {
	offset := 52
	return offset
}

func (this *PortStats) TxDropped() uint64 {
	offset := this.TxDroppedOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxDropped(t uint64) {
	offset := this.TxDroppedOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxDroppedOffset() int {
	offset := 60
	return offset
}

func (this *PortStats) RxErrors() uint64 {
	offset := this.RxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxErrors(r uint64) {
	offset := this.RxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxErrorsOffset() int {
	offset := 68
	return offset
}

func (this *PortStats) TxErrors() uint64 {
	offset := this.TxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxErrors(t uint64) {
	offset := this.TxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxErrorsOffset() int {
	offset := 76
	return offset
}

func (this *PortStats) RxFrameErr() uint64 {
	offset := this.RxFrameErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxFrameErr(r uint64) {
	offset := this.RxFrameErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxFrameErrOffset() int {
	offset := 84
	return offset
}

func (this *PortStats) RxOverErr() uint64 {
	offset := this.RxOverErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxOverErr(r uint64) {
	offset := this.RxOverErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxOverErrOffset() int {
	offset := 92
	return offset
}

func (this *PortStats) RxCrcErr() uint64 {
	offset := this.RxCrcErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxCrcErr(r uint64) {
	offset := this.RxCrcErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxCrcErrOffset() int {
	offset := 100
	return offset
}

func (this *PortStats) Collisions() uint64 {
	offset := this.CollisionsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetCollisions(c uint64) {
	offset := this.CollisionsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *PortStats) CollisionsOffset() int {
	offset := 108
	return offset
}

func NewVendorHeaderWithBuf(b []byte) VendorHeader {
	return VendorHeader{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewVendorHeader() VendorHeader {
	s := 12
	b := make([]byte, s)
	p := VendorHeader{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type VendorHeader struct {
	Header12
}

func (this VendorHeader) minSize() int {
	return 12
}

func (this VendorHeader) Clone() (VendorHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewVendorHeader(), err
	}

	return NewVendorHeaderWithBuf(newBuf.Bytes()), nil
}

type VendorHeaderConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewVendorHeaderConn(c net.Conn) VendorHeaderConn {
	return VendorHeaderConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *VendorHeaderConn) WriteVendorHeader(pkt VendorHeader) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *VendorHeaderConn) WriteVendorHeaders(pkts []VendorHeader) error {
	for _, p := range pkts {
		if err := c.WriteVendorHeader(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *VendorHeaderConn) ReadVendorHeader() (VendorHeader, error) {
	pkts := make([]VendorHeader, 1)
	_, err := c.ReadVendorHeaders(pkts)
	if err != nil {
		return NewVendorHeader(), err
	}

	return pkts[0], nil
}

func (c *VendorHeaderConn) ReadVendorHeaders(pkts []VendorHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewVendorHeaderWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *VendorHeader) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(4))    // type
	this.SetVersion(uint8(3)) // version
}

func (this VendorHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToVendorHeader(p Header12) (VendorHeader, error) {
	if !IsVendorHeader(p) {
		return NewVendorHeaderWithBuf(nil), errors.New("Cannot convert to of12.VendorHeader")
	}

	return NewVendorHeaderWithBuf(p.Buf), nil
}

func IsVendorHeader(p Header12) bool {
	return p.Type() == 4 && true
}

func (this *VendorHeader) Vendor() uint32 {
	offset := this.VendorOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *VendorHeader) SetVendor(v uint32) {
	offset := this.VendorOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], v)
	offset += 4
}

func (this *VendorHeader) VendorOffset() int {
	offset := 8
	return offset
}

func NewQueuePropHeaderWithBuf(b []byte) QueuePropHeader {
	return QueuePropHeader{packet.Packet{Buf: b}}
}

func NewQueuePropHeader() QueuePropHeader {
	s := 8
	b := make([]byte, s)
	p := QueuePropHeader{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type QueuePropHeader struct {
	packet.Packet
}

func (this QueuePropHeader) minSize() int {
	return 8
}

func (this QueuePropHeader) Clone() (QueuePropHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueuePropHeader(), err
	}

	return NewQueuePropHeaderWithBuf(newBuf.Bytes()), nil
}

type QueuePropHeaderConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueuePropHeaderConn(c net.Conn) QueuePropHeaderConn {
	return QueuePropHeaderConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueuePropHeaderConn) WriteQueuePropHeader(pkt QueuePropHeader) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueuePropHeaderConn) WriteQueuePropHeaders(pkts []QueuePropHeader) error {
	for _, p := range pkts {
		if err := c.WriteQueuePropHeader(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueuePropHeaderConn) ReadQueuePropHeader() (QueuePropHeader, error) {
	pkts := make([]QueuePropHeader, 1)
	_, err := c.ReadQueuePropHeaders(pkts)
	if err != nil {
		return NewQueuePropHeader(), err
	}

	return pkts[0], nil
}

func (c *QueuePropHeaderConn) ReadQueuePropHeaders(pkts []QueuePropHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueuePropHeaderWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueuePropHeader) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this QueuePropHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToQueuePropHeader(p packet.Packet) (QueuePropHeader, error) {
	if !IsQueuePropHeader(p) {
		return NewQueuePropHeaderWithBuf(nil), errors.New("Cannot convert to of12.QueuePropHeader")
	}

	return NewQueuePropHeaderWithBuf(p.Buf), nil
}

func IsQueuePropHeader(p packet.Packet) bool {
	return true
}

func (this *QueuePropHeader) Property() uint16 {
	offset := this.PropertyOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropHeader) SetProperty(p uint16) {
	offset := this.PropertyOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueuePropHeader) PropertyOffset() int {
	offset := 0
	return offset
}

func (this *QueuePropHeader) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropHeader) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *QueuePropHeader) LenOffset() int {
	offset := 2
	return offset
}

func (this *QueuePropHeader) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueuePropHeader) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueuePropHeader) PadOffset() int {
	offset := 4
	return offset
}

func NewQueuePropMinRateWithBuf(b []byte) QueuePropMinRate {
	return QueuePropMinRate{QueuePropHeader{packet.Packet{Buf: b}}}
}

func NewQueuePropMinRate() QueuePropMinRate {
	s := 16
	b := make([]byte, s)
	p := QueuePropMinRate{QueuePropHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type QueuePropMinRate struct {
	QueuePropHeader
}

func (this QueuePropMinRate) minSize() int {
	return 16
}

func (this QueuePropMinRate) Clone() (QueuePropMinRate, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueuePropMinRate(), err
	}

	return NewQueuePropMinRateWithBuf(newBuf.Bytes()), nil
}

type QueuePropMinRateConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueuePropMinRateConn(c net.Conn) QueuePropMinRateConn {
	return QueuePropMinRateConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueuePropMinRateConn) WriteQueuePropMinRate(pkt QueuePropMinRate) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueuePropMinRateConn) WriteQueuePropMinRates(pkts []QueuePropMinRate) error {
	for _, p := range pkts {
		if err := c.WriteQueuePropMinRate(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueuePropMinRateConn) ReadQueuePropMinRate() (QueuePropMinRate, error) {
	pkts := make([]QueuePropMinRate, 1)
	_, err := c.ReadQueuePropMinRates(pkts)
	if err != nil {
		return NewQueuePropMinRate(), err
	}

	return pkts[0], nil
}

func (c *QueuePropMinRateConn) ReadQueuePropMinRates(pkts []QueuePropMinRate) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueuePropMinRateWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueuePropMinRate) Init() {
	this.QueuePropHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetProperty(uint16(1)) // property
}

func (this QueuePropMinRate) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToQueuePropMinRate(p QueuePropHeader) (QueuePropMinRate, error) {
	if !IsQueuePropMinRate(p) {
		return NewQueuePropMinRateWithBuf(nil), errors.New("Cannot convert to of12.QueuePropMinRate")
	}

	return NewQueuePropMinRateWithBuf(p.Buf), nil
}

func IsQueuePropMinRate(p QueuePropHeader) bool {
	return p.Property() == 1 && true
}

func (this *QueuePropMinRate) Rate() uint16 {
	offset := this.RateOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropMinRate) SetRate(r uint16) {
	offset := this.RateOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], r)
	offset += 2
}

func (this *QueuePropMinRate) RateOffset() int {
	offset := 8
	return offset
}

func (this *QueuePropMinRate) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueuePropMinRate) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueuePropMinRate) PadOffset() int {
	offset := 10
	return offset
}

func NewPacketQueueWithBuf(b []byte) PacketQueue {
	return PacketQueue{packet.Packet{Buf: b}}
}

func NewPacketQueue() PacketQueue {
	s := 8
	b := make([]byte, s)
	p := PacketQueue{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type PacketQueue struct {
	packet.Packet
}

func (this PacketQueue) minSize() int {
	return 8
}

func (this PacketQueue) Clone() (PacketQueue, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketQueue(), err
	}

	return NewPacketQueueWithBuf(newBuf.Bytes()), nil
}

type PacketQueueConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPacketQueueConn(c net.Conn) PacketQueueConn {
	return PacketQueueConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketQueueConn) WritePacketQueue(pkt PacketQueue) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *PacketQueueConn) WritePacketQueues(pkts []PacketQueue) error {
	for _, p := range pkts {
		if err := c.WritePacketQueue(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *PacketQueueConn) ReadPacketQueue() (PacketQueue, error) {
	pkts := make([]PacketQueue, 1)
	_, err := c.ReadPacketQueues(pkts)
	if err != nil {
		return NewPacketQueue(), err
	}

	return pkts[0], nil
}

func (c *PacketQueueConn) ReadPacketQueues(pkts []PacketQueue) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketQueueWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *PacketQueue) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this PacketQueue) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToPacketQueue(p packet.Packet) (PacketQueue, error) {
	if !IsPacketQueue(p) {
		return NewPacketQueueWithBuf(nil), errors.New("Cannot convert to of12.PacketQueue")
	}

	return NewPacketQueueWithBuf(p.Buf), nil
}

func IsPacketQueue(p packet.Packet) bool {
	return true
}

func (this *PacketQueue) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketQueue) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *PacketQueue) QueueIdOffset() int {
	offset := 0
	return offset
}

func (this *PacketQueue) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketQueue) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *PacketQueue) LenOffset() int {
	offset := 4
	return offset
}

func (this *PacketQueue) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PacketQueue) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PacketQueue) PadOffset() int {
	offset := 6
	return offset
}

func (this *PacketQueue) Properties() []QueuePropHeader {
	offset := this.PropertiesOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []QueuePropHeader
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewQueuePropHeaderWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketQueue) AddProperties(p QueuePropHeader) {
	offset := this.PropertiesOffset()
	offset += this.PropertiesSize()
	size := p.Size()
	this.OpenGap(offset, size)
	this.SetLen(uint16(this.Size() + size))
	copy(this.Buf[offset:], p.Buf[:p.Size()])
	offset += p.Size()
}

func (this *PacketQueue) PropertiesOffset() int {
	offset := 8
	return offset
}

func (this *PacketQueue) PropertiesSize() int {
	offset := this.PropertiesOffset()
	return this.Size() - offset
}

func NewQueueGetConfigRequestWithBuf(b []byte) QueueGetConfigRequest {
	return QueueGetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewQueueGetConfigRequest() QueueGetConfigRequest {
	s := 10
	b := make([]byte, s)
	p := QueueGetConfigRequest{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type QueueGetConfigRequest struct {
	Header12
}

func (this QueueGetConfigRequest) minSize() int {
	return 10
}

func (this QueueGetConfigRequest) Clone() (QueueGetConfigRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueGetConfigRequest(), err
	}

	return NewQueueGetConfigRequestWithBuf(newBuf.Bytes()), nil
}

type QueueGetConfigRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueGetConfigRequestConn(c net.Conn) QueueGetConfigRequestConn {
	return QueueGetConfigRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueGetConfigRequestConn) WriteQueueGetConfigRequest(pkt QueueGetConfigRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueGetConfigRequestConn) WriteQueueGetConfigRequests(pkts []QueueGetConfigRequest) error {
	for _, p := range pkts {
		if err := c.WriteQueueGetConfigRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueGetConfigRequestConn) ReadQueueGetConfigRequest() (QueueGetConfigRequest, error) {
	pkts := make([]QueueGetConfigRequest, 1)
	_, err := c.ReadQueueGetConfigRequests(pkts)
	if err != nil {
		return NewQueueGetConfigRequest(), err
	}

	return pkts[0], nil
}

func (c *QueueGetConfigRequestConn) ReadQueueGetConfigRequests(pkts []QueueGetConfigRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueGetConfigRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueGetConfigRequest) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(23))   // type
	this.SetVersion(uint8(3)) // version
}

func (this QueueGetConfigRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueGetConfigRequest(p Header12) (QueueGetConfigRequest, error) {
	if !IsQueueGetConfigRequest(p) {
		return NewQueueGetConfigRequestWithBuf(nil), errors.New("Cannot convert to of12.QueueGetConfigRequest")
	}

	return NewQueueGetConfigRequestWithBuf(p.Buf), nil
}

func IsQueueGetConfigRequest(p Header12) bool {
	return p.Type() == 23 && true
}

func (this *QueueGetConfigRequest) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueGetConfigRequest) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueGetConfigRequest) PortOffset() int {
	offset := 8
	return offset
}

func (this *QueueGetConfigRequest) Pad() []uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *QueueGetConfigRequest) AddPad(p uint8) {
	offset := this.PadOffset()
	offset += this.PadSize()
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(p)
	offset++
}

func (this *QueueGetConfigRequest) PadOffset() int {
	offset := 10
	return offset
}

func (this *QueueGetConfigRequest) PadSize() int {
	offset := this.PadOffset()
	return this.Size() - offset
}

func NewQueueGetConfigReplyWithBuf(b []byte) QueueGetConfigReply {
	return QueueGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
}

func NewQueueGetConfigReply() QueueGetConfigReply {
	s := 16
	b := make([]byte, s)
	p := QueueGetConfigReply{Header12{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type QueueGetConfigReply struct {
	Header12
}

func (this QueueGetConfigReply) minSize() int {
	return 16
}

func (this QueueGetConfigReply) Clone() (QueueGetConfigReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueGetConfigReply(), err
	}

	return NewQueueGetConfigReplyWithBuf(newBuf.Bytes()), nil
}

type QueueGetConfigReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueGetConfigReplyConn(c net.Conn) QueueGetConfigReplyConn {
	return QueueGetConfigReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueGetConfigReplyConn) WriteQueueGetConfigReply(pkt QueueGetConfigReply) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueGetConfigReplyConn) WriteQueueGetConfigReplys(pkts []QueueGetConfigReply) error {
	for _, p := range pkts {
		if err := c.WriteQueueGetConfigReply(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueGetConfigReplyConn) ReadQueueGetConfigReply() (QueueGetConfigReply, error) {
	pkts := make([]QueueGetConfigReply, 1)
	_, err := c.ReadQueueGetConfigReplys(pkts)
	if err != nil {
		return NewQueueGetConfigReply(), err
	}

	return pkts[0], nil
}

func (c *QueueGetConfigReplyConn) ReadQueueGetConfigReplys(pkts []QueueGetConfigReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueGetConfigReplyWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueGetConfigReply) Init() {
	this.Header12.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(23))   // type
	this.SetVersion(uint8(3)) // version
}

func (this QueueGetConfigReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueGetConfigReply(p Header12) (QueueGetConfigReply, error) {
	if !IsQueueGetConfigReply(p) {
		return NewQueueGetConfigReplyWithBuf(nil), errors.New("Cannot convert to of12.QueueGetConfigReply")
	}

	return NewQueueGetConfigReplyWithBuf(p.Buf), nil
}

func IsQueueGetConfigReply(p Header12) bool {
	return p.Type() == 23 && true
}

func (this *QueueGetConfigReply) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueGetConfigReply) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueGetConfigReply) PortOffset() int {
	offset := 8
	return offset
}

func (this *QueueGetConfigReply) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueGetConfigReply) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueueGetConfigReply) PadOffset() int {
	offset := 10
	return offset
}

func (this *QueueGetConfigReply) Queues() []PacketQueue {
	offset := this.QueuesOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []PacketQueue
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewPacketQueueWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *QueueGetConfigReply) AddQueues(q PacketQueue) {
	offset := this.QueuesOffset()
	offset += this.QueuesSize()
	size := q.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], q.Buf[:q.Size()])
	offset += q.Size()
}

func (this *QueueGetConfigReply) QueuesOffset() int {
	offset := 16
	return offset
}

func (this *QueueGetConfigReply) QueuesSize() int {
	offset := this.QueuesOffset()
	return this.Size() - offset
}

func NewQueueStatsRequestWithBuf(b []byte) QueueStatsRequest {
	return QueueStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewQueueStatsRequest() QueueStatsRequest {
	s := 20
	b := make([]byte, s)
	p := QueueStatsRequest{StatsRequest{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type QueueStatsRequest struct {
	StatsRequest
}

func (this QueueStatsRequest) minSize() int {
	return 20
}

func (this QueueStatsRequest) Clone() (QueueStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueStatsRequest(), err
	}

	return NewQueueStatsRequestWithBuf(newBuf.Bytes()), nil
}

type QueueStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueStatsRequestConn(c net.Conn) QueueStatsRequestConn {
	return QueueStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueStatsRequestConn) WriteQueueStatsRequest(pkt QueueStatsRequest) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueStatsRequestConn) WriteQueueStatsRequests(pkts []QueueStatsRequest) error {
	for _, p := range pkts {
		if err := c.WriteQueueStatsRequest(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueStatsRequestConn) ReadQueueStatsRequest() (QueueStatsRequest, error) {
	pkts := make([]QueueStatsRequest, 1)
	_, err := c.ReadQueueStatsRequests(pkts)
	if err != nil {
		return NewQueueStatsRequest(), err
	}

	return pkts[0], nil
}

func (c *QueueStatsRequestConn) ReadQueueStatsRequests(pkts []QueueStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueStatsRequestWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(5)) // stats_type
	this.SetType(uint8(18))      // type
	this.SetVersion(uint8(3))    // version
}

func (this QueueStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueStatsRequest(p StatsRequest) (QueueStatsRequest, error) {
	if !IsQueueStatsRequest(p) {
		return NewQueueStatsRequestWithBuf(nil), errors.New("Cannot convert to of12.QueueStatsRequest")
	}

	return NewQueueStatsRequestWithBuf(p.Buf), nil
}

func IsQueueStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 5 && true
}

func (this *QueueStatsRequest) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueStatsRequest) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueStatsRequest) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *QueueStatsRequest) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueStatsRequest) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueueStatsRequest) PadOffset() int {
	offset := 14
	return offset
}

func (this *QueueStatsRequest) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *QueueStatsRequest) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *QueueStatsRequest) QueueIdOffset() int {
	offset := 16
	return offset
}

func NewQueueStatsWithBuf(b []byte) QueueStats {
	return QueueStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
}

func NewQueueStats() QueueStats {
	s := 44
	b := make([]byte, s)
	p := QueueStats{StatsReply{Header12{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type QueueStats struct {
	StatsReply
}

func (this QueueStats) minSize() int {
	return 44
}

func (this QueueStats) Clone() (QueueStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueStats(), err
	}

	return NewQueueStatsWithBuf(newBuf.Bytes()), nil
}

type QueueStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueStatsConn(c net.Conn) QueueStatsConn {
	return QueueStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueStatsConn) WriteQueueStats(pkt QueueStats) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.Conn.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *QueueStatsConn) WriteQueueStatss(pkts []QueueStats) error {
	for _, p := range pkts {
		if err := c.WriteQueueStats(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *QueueStatsConn) ReadQueueStats() (QueueStats, error) {
	pkts := make([]QueueStats, 1)
	_, err := c.ReadQueueStatss(pkts)
	if err != nil {
		return NewQueueStats(), err
	}

	return pkts[0], nil
}

func (c *QueueStatsConn) ReadQueueStatss(pkts []QueueStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueStatsWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *QueueStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(5)) // stats_type
	this.SetType(uint8(19))      // type
	this.SetVersion(uint8(3))    // version
}

func (this QueueStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueStats(p StatsReply) (QueueStats, error) {
	if !IsQueueStats(p) {
		return NewQueueStatsWithBuf(nil), errors.New("Cannot convert to of12.QueueStats")
	}

	return NewQueueStatsWithBuf(p.Buf), nil
}

func IsQueueStats(p StatsReply) bool {
	return p.StatsType() == 5 && true
}

func (this *QueueStats) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueStats) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *QueueStats) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueStats) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueueStats) PadOffset() int {
	offset := 14
	return offset
}

func (this *QueueStats) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *QueueStats) QueueIdOffset() int {
	offset := 16
	return offset
}

func (this *QueueStats) TxBytes() uint64 {
	offset := this.TxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxBytes(t uint64) {
	offset := this.TxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *QueueStats) TxBytesOffset() int {
	offset := 20
	return offset
}

func (this *QueueStats) TxPackets() uint64 {
	offset := this.TxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxPackets(t uint64) {
	offset := this.TxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *QueueStats) TxPacketsOffset() int {
	offset := 28
	return offset
}

func (this *QueueStats) TxErrors() uint64 {
	offset := this.TxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxErrors(t uint64) {
	offset := this.TxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *QueueStats) TxErrorsOffset() int {
	offset := 36
	return offset
}
