// Automatically generated by Packet Go code generator.
package ethernet

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"

	"github.com/packet/packet/src/go/packet"
)

type EtherType int

const (
	ETH_T_LLDP EtherType = 35020
)

func NewEthernetWithBuf(b []byte) Ethernet {
	return Ethernet{packet.Packet{Buf: b}}
}

func NewEthernet() Ethernet {
	s := 14
	b := make([]byte, s)
	p := Ethernet{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Ethernet struct {
	packet.Packet
}

func (this Ethernet) minSize() int {
	return 14
}

func (this Ethernet) Clone() (Ethernet, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEthernet(), err
	}

	return NewEthernetWithBuf(newBuf.Bytes()), nil
}

type EthernetConn struct {
	net.Conn
	w      *bufio.Writer
	buf    []byte
	offset int
}

func NewEthernetConn(c net.Conn) EthernetConn {
	return EthernetConn{
		Conn: c,
		w:    bufio.NewWriter(c),
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EthernetConn) WriteEthernet(pkt Ethernet) error {
	s := pkt.Size()
	b := pkt.Buffer()[:s]
	n := 0
	for s > 0 {
		var err error
		if n, err = c.w.Write(b); err != nil {
			return fmt.Errorf("Error in write: %v", err)
		}
		s -= n
	}

	return nil
}

func (c *EthernetConn) WriteEthernets(pkts []Ethernet) error {
	for _, p := range pkts {
		if err := c.WriteEthernet(p); err != nil {
			return err
		}
	}
	return nil
}

func (c *EthernetConn) Flush() error {
	return c.w.Flush()
}

func (c *EthernetConn) ReadEthernet() (Ethernet, error) {
	pkts := make([]Ethernet, 1)
	_, err := c.ReadEthernets(pkts)
	if err != nil {
		return NewEthernet(), err
	}

	return pkts[0], nil
}

func (c *EthernetConn) ReadEthernets(pkts []Ethernet) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEthernetWithBuf(c.buf[s:])

		pSize := p.Size()
		if pSize == 0 || r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	return n, nil
}

func (this *Ethernet) Init() {
	// Invariants.
}

func (this Ethernet) Size() int {
	return 14
}

func ToEthernet(p packet.Packet) (Ethernet, error) {
	if !IsEthernet(p) {
		return NewEthernetWithBuf(nil), errors.New("Cannot convert to ethernet.Ethernet")
	}

	return NewEthernetWithBuf(p.Buf), nil
}

func IsEthernet(p packet.Packet) bool {
	return true
}

func (this Ethernet) DstMac() [6]uint8 {
	offset := this.DstMacOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Ethernet) SetDstMac(d [6]uint8) {
	offset := this.DstMacOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this Ethernet) DstMacOffset() int {
	offset := 0
	return offset
}

func (this Ethernet) SrcMac() [6]uint8 {
	offset := this.SrcMacOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Ethernet) SetSrcMac(s [6]uint8) {
	offset := this.SrcMacOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this Ethernet) SrcMacOffset() int {
	offset := 6
	return offset
}

func (this Ethernet) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Ethernet) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this Ethernet) TypeOffset() int {
	offset := 12
	return offset
}
